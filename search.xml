<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>10X GENOMICS pipeline</title>
    <url>/2021/05/09/10X-GENOMICS-pipeline/</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="（一）环境搭建"><a href="#（一）环境搭建" class="headerlink" title="（一）环境搭建"></a>（一）环境搭建</h1><p><strong>下载Cell Ranger,下载10X GENOMICS配套的参考基因组.官网也提供了Cell Ranger Pipeline。</strong></p>
<p>官网下载链接： <a href="https://support.10xgenomics.com/single-cell-gene-expression/software/downloads/latest">https://support.10xgenomics.com/single-cell-gene-expression/software/downloads/latest</a></p>
<h4 id="1-下载、安装Cell-Ranger软件"><a href="#1-下载、安装Cell-Ranger软件" class="headerlink" title="(1)下载、安装Cell Ranger软件"></a>(1)下载、安装Cell Ranger软件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#下载</span></span><br><span class="line">curl -o cellranger-6.0.1.tar.gz <span class="string">&quot;https://cf.10xgenomics.com/releases/cell-exp/cellranger-6.0.1.tar.gz?Expires=1620565659&amp;Policy=eyJTdGF0ZW1lbnQiOlt7IlJlc291cmNlIjoiaHR0cHM6Ly9jZi4xMHhnZW5vbWljcy5jb20vcmVsZWFzZXMvY2VsbC1leHAvY2VsbHJhbmdlci02LjAuMS50YXIuZ3oiLCJDb25kaXRpb24iOnsiRGF0ZUxlc3NUaGFuIjp7IkFXUzpFcG9jaFRpbWUiOjE2MjA1NjU2NTl9fX1dfQ__&amp;Signature=IN508xcNVbAtoHul8SUog8KHmlAhg2lbR6-hCQeiwPs~-EfvTL1JmDurZ3dV-k3ry7TO9WP5Ae11yceDSzCfVIqglxHp6Pad4CftaStozIuEU7XJ0JbtDTO3DFVHRkpgNR8k48dNADA~JnhcHx8zOsT23VEeugqc7Z~35~05SOG8GJjxSJ8qGSTBdHYt7kPyqfZVs2apryxLOV-QBho66LvD4NLqNXFvzkPZ8t0e9Cv4rrV1JXseqY6PJnK8TPozTnDBnhfkop30FZ~jOLEY8wObOIA4b~EoyskSGjSfcvnp5urI7xjAyQNC6XtlJmRwDWEwWovgicScei2gkZqOGw__&amp;Key-Pair-Id=APKAI7S6A5RYOXBWRPDA&quot;</span></span><br><span class="line"><span class="comment">#安装</span></span><br><span class="line"><span class="comment">##解压</span></span><br><span class="line">tar zxvf cellranger-6.0.1.tar.gz</span><br><span class="line"><span class="comment">##添加环境变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=/home/gongyuqi/10X/cellranger-6.0.1:$PATH&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="comment">##永久生效环境变量</span></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line"><span class="comment">#查看本机的配置，看看是否满足跑单细胞数据的最低配置</span></span><br><span class="line">cellranger sitecheck &gt; sitecheck.txt</span><br><span class="line">less -N sitecheck.txt</span><br><span class="line"><span class="comment">#最后，测试一下下载安装的cellranger能否正常运行</span></span><br><span class="line">cellranger testrun --id=testcellranger </span><br></pre></td></tr></table></figure>
<p>标准输出最后两行为如下结果，表示cellranger可以正常使用<br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/test_cellranger.JPG" width="50%"></p>
<h4 id="2-下载人类参考基因组"><a href="#2-下载人类参考基因组" class="headerlink" title="(2)下载人类参考基因组"></a>(2)下载人类参考基因组</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -O https://cf.10xgenomics.com/supp/cell-exp/refdata-gex-GRCh38-2020-A.tar.gz</span><br><span class="line">tar -zxvf refdata-gex-GRCh38-2020-A.tar.gz</span><br></pre></td></tr></table></figure>
<p>查看一下文件的组成结构<br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/GRCh38.JPG" width="50%"></p>
<h4 id="3-下载小鼠参考基因组"><a href="#3-下载小鼠参考基因组" class="headerlink" title="(3)下载小鼠参考基因组"></a>(3)下载小鼠参考基因组</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -O https://cf.10xgenomics.com/supp/cell-exp/refdata-gex-mm10-2020-A.tar.gz</span><br><span class="line">tar -zxvf refdata-gex-mm10-2020-A.tar.gz</span><br></pre></td></tr></table></figure>
<h1 id="二-下载测试数据"><a href="#二-下载测试数据" class="headerlink" title="(二)下载测试数据"></a>(二)下载测试数据</h1><p><strong>在这里要用到prefetch和ascp的组合，详细的软件安装以及测试数据下载请参考<a href="https://mp.weixin.qq.com/s?__biz=MzI1Njk4ODE0MQ==&mid=2247484146&idx=1&sn=16e09b82d048eed1ff6100b22970abd5&chksm=ea1f0470dd688d66bdbfbaf2a2b9ae91f545992469996cfecf407a09492df32b4536fda7ca4f&scene=21#wechat_redirect">单细胞数据下载</a></strong></p>
<h4 id="1-pretch下载SRA文件"><a href="#1-pretch下载SRA文件" class="headerlink" title="(1)pretch下载SRA文件"></a>(1)pretch下载SRA文件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#refetch默认通过https的方式下载原始数据，速度上会有限制</span></span><br><span class="line"><span class="comment">#如果存在ascp，prefetch默认通过fasp的方式下载数据，速度一下载从骑自行车升级为开飞机</span></span><br><span class="line">cat sample.txt|<span class="keyword">while</span> <span class="built_in">read</span> id</span><br><span class="line"><span class="keyword">do</span> nohup prefetch <span class="variable">$id</span> -O ./ &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;id&#125;</span>.sra done&quot;</span> &amp;</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<h4 id="2-ascp下载"><a href="#2-ascp下载" class="headerlink" title="(2)ascp下载"></a>(2)ascp下载</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#其中两个样本不在ncbi中，所以我们这里用直接用ascp下载EBI中存储的SRA文件，两个样本就不写循环了</span></span><br><span class="line">ascp -QT -l 300m -P33001 -i ~/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/srr/SRR772/009/SRR7722939 ./</span><br><span class="line">ascp -QT -l 300m -P33001 -i ~/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/srr/SRR772/002/SRR7722942 ./</span><br></pre></td></tr></table></figure>
<h1 id="三-Cell-Ranger-使用"><a href="#三-Cell-Ranger-使用" class="headerlink" title="(三)Cell Ranger 使用"></a>(三)Cell Ranger 使用</h1><h2 id="1-SRA格式转成fastq格式"><a href="#1-SRA格式转成fastq格式" class="headerlink" title="(1)SRA格式转成fastq格式"></a>(1)SRA格式转成fastq格式</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/gongyuqi/project/scRNA-seq/raw_data</span><br><span class="line"><span class="comment">#--split-files生成三个文件，第一个文件的所有序列都是8bp，第二个文件都是26bp，第三个文件都是91bp，第三个文件是测序reads</span></span><br><span class="line">ls *.sra|<span class="keyword">while</span> <span class="built_in">read</span> id</span><br><span class="line"><span class="keyword">do</span> nohup fastq-dump --gzip --split-files -A <span class="variable">$id</span> &amp;</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<h2 id="2-重命名文件"><a href="#2-重命名文件" class="headerlink" title="(2)重命名文件"></a>(2)重命名文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls *.sra|<span class="keyword">while</span> <span class="built_in">read</span> id</span><br><span class="line"><span class="keyword">do</span> mv <span class="variable">$&#123;id&#125;</span>_1*.gz <span class="variable">$&#123;id&#125;</span>_S1_L001_I1_001.fastq.gz; mv <span class="variable">$&#123;id&#125;</span>_2*.gz <span class="variable">$&#123;id&#125;</span>_S1_L001_R1_001.fastq.gz; mv <span class="variable">$&#123;id&#125;</span>_3*.gz <span class="variable">$&#123;id&#125;</span>_S1_L001_R2_001.fastq.gz</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>命名前<br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/before_rename.JPG"/><br>命名后<br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/after_rename.JPG"/></p>
<h2 id="3-质控"><a href="#3-质控" class="headerlink" title="(3)质控"></a>(3)质控</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls *R1*.gz &gt; sample_fastq.txt</span><br><span class="line">ls *R2*.gz &gt;&gt; sample_fastq.txt</span><br></pre></td></tr></table></figure>
<h2 id="4-cellranger-count"><a href="#4-cellranger-count" class="headerlink" title="(4)cellranger count"></a>(4)cellranger count</h2><p><strong>cellranger是软件最核心的部分，可以完成细胞鉴定，基因组比对，过滤，UMI计数，细胞降维，聚类，差异分析等功能。内部流程很多，但是使用很简单。</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#首先进入到cellranger_count文件夹下面并建立存放各个样本结果的文件夹</span></span><br><span class="line"><span class="built_in">cd</span> /home/gongyuqi/project/scRNA-seq/cellranger_count</span><br><span class="line">cat sample.txt|<span class="keyword">while</span> <span class="built_in">read</span> id;<span class="keyword">do</span> mkdir <span class="variable">$id</span>;<span class="keyword">done</span></span><br><span class="line"><span class="comment">#将下列代码编辑到脚本文件cellranger_count.sh中</span></span><br><span class="line">cat sample.txt|<span class="keyword">while</span> <span class="built_in">read</span> id</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">cellranger count --id=<span class="variable">$id</span> \</span><br><span class="line">                 --transcriptome=/home/gongyuqi/10X/refdata-gex-GRCh38-2020-A \</span><br><span class="line">                 --fastqs=/home/gongyuqi/project/scRNA-seq/raw_data \</span><br><span class="line">                 --sample=<span class="variable">$id</span> \</span><br><span class="line">                 --nosecondary \</span><br><span class="line">                 --localcores=16 \</span><br><span class="line">                 --localmem=64 &gt; <span class="variable">$&#123;id&#125;</span>.<span class="built_in">log</span> 2&gt;&amp;1</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment">#给脚本文件执行权限</span></span><br><span class="line">chmod +x cellranger_count.sh</span><br><span class="line"><span class="comment">#后台运行脚本文件</span></span><br><span class="line">nohup ./cellranger_count.sh &amp;</span><br><span class="line"><span class="comment">#参数解析</span></span><br><span class="line"><span class="comment">#--id: 指定输出文件存放目录</span></span><br><span class="line"><span class="comment">#--transcriptome: cellranger兼容的参考基因组位置</span></span><br><span class="line"><span class="comment">#--fastqs：重命名好的fastq.gz文件位置</span></span><br><span class="line"><span class="comment">#--sample：fastq.gz文件文件前缀，以作为软件识别的标志</span></span><br><span class="line"><span class="comment">#--nosecondary：只获得表达矩阵，不进行后续的降维、聚类和可视化（这些工作用R包做，如Seurat）</span></span><br><span class="line"><span class="comment">#--jobmode=local: 指定cellranger在本地运行（cellranger默认也是在本地运行）。它会占用90%的空余内存和所有空余的CPU。如果要进行资源控制，使用--localmem或者--localcores</span></span><br><span class="line"><span class="comment">#--localcores: 限定cellranger最多同时使用的cpu个数</span></span><br><span class="line"><span class="comment">#--localmem：限定cellranger最多占用的内存大小</span></span><br></pre></td></tr></table></figure>
<p>以SRR7722937为例，来看一下cellranger count的结果总结：Barcode,UMI,mapping情况，样本的信息（使用v2试剂，参考基因组，cellranger版本），reads与测序饱和度、基因数量的关系（正相关，情理之中~）<br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/cellranger_count_summary_html.JPG"/><br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/cellranger_count_summary_html2.JPG"/></p>
<h2 id="5-cellranger-aggr"><a href="#5-cellranger-aggr" class="headerlink" title="(5)cellranger aggr"></a>(5)cellranger aggr</h2><p>第一步构建输入文件信息，文件内容如下。如果整合的样本既有v2试剂也有v3试剂，需要在第三列加上相应的试剂信息。如果都是用的同一种试剂，只需要保留前两列的信息即可。如本次测试数据。<br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/cellranger_aggr_input.JPG"/></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#--id为输出文件保存的位置</span></span><br><span class="line"><span class="comment">#--csv为输入文件的信息</span></span><br><span class="line">cellranger aggr --id=patient_2586-4 \</span><br><span class="line">                --csv=patient_2586-4_libbrary.csv \</span><br><span class="line">                --normalize=mapped</span><br></pre></td></tr></table></figure>
<p>同样的，来查看一下cellranger aggr的结果报告。报告的消息解读可参考：<a href="https://www.jianshu.com/p/30de2aea4b74?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation">https://www.jianshu.com/p/30de2aea4b74?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation</a>  </p>
<table><tr><td bgcolor=#DCDCDC>1、Count Summary</td></tr></table>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/cellranger_aggr_summary_html.JPG"/>
<table><tr><td bgcolor=#DCDCDC>2、Count Analysis</td></tr></table>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/cellranger_aggr_summary_html2.JPG"/>
<table><tr><td bgcolor=#FF6347>3、Alerts</td></tr></table>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/cellranger_aggr_summary_html_alert.JPG"/>

<h1 id="四-Cell-Ranger输出结果导入R"><a href="#四-Cell-Ranger输出结果导入R" class="headerlink" title="(四) Cell Ranger输出结果导入R"></a>(四) Cell Ranger输出结果导入R</h1><p>cellranger aggar运行完成之后，在outs文件夹下面的子文件夹filtered_feature_bc_matrix中的三个文件上传到本地，解压导入R中。<br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/cellranger_aggr_results.JPG"/></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(Matrix)</span><br><span class="line">barcode.path&lt;-paste0(<span class="string">&quot;barcodes.tsv&quot;</span>)</span><br><span class="line">feature.path&lt;-paste0(<span class="string">&quot;features.tsv&quot;</span>)</span><br><span class="line">matrix.path&lt;-paste0(<span class="string">&quot;matrix.mtx&quot;</span>)</span><br><span class="line">mat&lt;-readMM(file = matrix.path)</span><br><span class="line"></span><br><span class="line">feature.names&lt;-read.delim(feature.path,</span><br><span class="line">                          header = <span class="literal">FALSE</span>,</span><br><span class="line">                          stringsAsFactors = <span class="literal">FALSE</span>)</span><br><span class="line">barcode.names&lt;-read.delim(barcode.path,</span><br><span class="line">                          header = <span class="literal">FALSE</span>,</span><br><span class="line">                          stringsAsFactors = <span class="literal">FALSE</span>)</span><br><span class="line">colnames(mat)&lt;-barcode.names$V1</span><br><span class="line">rownames(mat)&lt;-feature.names$V2</span><br><span class="line">mat[<span class="number">1</span>:<span class="number">4</span>,<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line"><span class="built_in">dim</span>(mat)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/cellranger_R.JPG"/>
]]></content>
      <tags>
        <tag>NGS</tag>
      </tags>
  </entry>
  <entry>
    <title>ATAC_project</title>
    <url>/2021/03/30/ATAC-project/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="ch1"><a href="#ch1" class="headerlink" title="ch1"></a>ch1</h2>]]></content>
      <tags>
        <tag>tag1</tag>
      </tags>
  </entry>
  <entry>
    <title>ATAC-seq Analysis</title>
    <url>/2020/02/08/ATAC-seq%20Analysis/</url>
    <content><![CDATA[<p>ATAC-seq旧版处理流程</p>
<a id="more"></a>

<h1 id="ATAC-seq-Analysis"><a href="#ATAC-seq-Analysis" class="headerlink" title="ATAC-seq Analysis"></a>ATAC-seq Analysis</h1><p>表观测序数据中比较重要的就是ATAC-seq、Chip-seq。这两者的原理和分析过程类似。<br>具体的异同详见此链接：<a href="https://www.jianshu.com/p/87bc2002e82c">https://www.jianshu.com/p/87bc2002e82c</a></p>
<h2 id="一-数据下载"><a href="#一-数据下载" class="headerlink" title="(一)数据下载"></a>(一)数据下载</h2><p><font color=red>数据下载是我走过的最曲折的路</font></p>
<p>强烈不推荐wget、curl——需要向上天再借500年才能等的起。</p>
<p>不推荐prefetch——不知道为什么prefetch在我这里也不起作用！按理说有ascp环境后，prefetch会自动调用ascp进行数据下载呀！可是prefetch依然显示通过https进行数据下载，这就没法下载呀！直接timeout！</p>
<p><strong>正解——调用ascp下载数据</strong></p>
<p>（1）ascp下载NCBI的SRA文件</p>
<p>此方法亲测不行，但是就在2个月前还是可以的。官网给出的解释大致意思就是——不好意思，这段时间出现无法通过ascp下载NCBI数据属于正常现象…blablabla…</p>
<p>（2）ascp下载EBI的fastq文件（强烈推荐，省去了SRA转成fastq的麻烦，很耗资源，很耗时）</p>
<p>在此次数据分析中，下载SRR2927015、SRR2927016、SRR2927018、SRR3545580对应的fastq文件进行ATAC-seq数据分析的实战。</p>
<p>EBI官网输入对应SRR号（以SRR3545580为例），找到相应的fastq文件位置，复制连接地址。</p>
<p><a href="http://ftp.sra.ebi.ac.uk/vol1/fastq/SRR354/000/SRR3545580/SRR3545580_1.fastq.gz">http://ftp.sra.ebi.ac.uk/vol1/fastq/SRR354/000/SRR3545580/SRR3545580_1.fastq.gz</a></p>
<p><a href="http://ftp.sra.ebi.ac.uk/vol1/fastq/SRR354/000/SRR3545580/SRR3545580_2.fastq.gz">http://ftp.sra.ebi.ac.uk/vol1/fastq/SRR354/000/SRR3545580/SRR3545580_2.fastq.gz</a></p>
<p>下载方式如下（下载速递可达到每秒M级别，快的时候能到60M+，亲测此方法为目前最可取的方法）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ascp -QT -l 300m -P33001 -i /home/gongyuqi/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:/vol1/fastq/SRR354/000/SRR3545580/SRR3545580_1.fastq.gz .</span><br><span class="line">ascp -QT -l 300m -P33001 -i /home/gongyuqi/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:/vol1/fastq/SRR354/000/SRR3545580/SRR3545580_2.fastq.gz .</span><br></pre></td></tr></table></figure>
<p>最终下载结果</p>
<p><img src="https://gyq-images.oss-cn-hangzhou.aliyuncs.com/img/rawdata.png"></p>
<p>为了后续分析，将其改名为下</p>
<p>2-cell-1  SRR2927015<br>2-cell-2  SRR2927016<br>2-cell-4  SRR2927018<br>2-cell-5  SRR3545580</p>
<p><img src="https://gyq-images.oss-cn-hangzhou.aliyuncs.com/img/rename_rawdata.png"></p>
<p>附上测序数据下载方式的相关参考资料</p>
<p><a href="https://www.jianshu.com/p/df34b99cbd43">https://www.jianshu.com/p/df34b99cbd43</a></p>
<p><a href="https://www.bioinfo-scrounger.com/archives/171/">https://www.bioinfo-scrounger.com/archives/171/</a></p>
<h2 id="（二）自定义docker容器的启动与数据共享"><a href="#（二）自定义docker容器的启动与数据共享" class="headerlink" title="（二）自定义docker容器的启动与数据共享"></a>（二）自定义docker容器的启动与数据共享</h2><p>之前创建了具备ATAC-seq数据分析所需环境的docker容器，并push到阿里云。在此只需要pull该镜像，run即可使用。</p>
<p>但是！！！创建容器时并没有装ascp，因为只有普通用户才可以运行ascp。所以数据下载是在ubuntu主机进行的。为了能够在容器中使用下载的测试数据，运用数据卷，实现主机和容器间的数据共享。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看镜像</span><br><span class="line">docker images</span><br></pre></td></tr></table></figure>
<p><img src="https://gyq-images.oss-cn-hangzhou.aliyuncs.com/img/ubuntu-atac-seq-image.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 启动容器实现数据共享</span><br><span class="line">docker run -it -v &#x2F;home&#x2F;gongyuqi&#x2F;Downloads&#x2F;ATACdata&#x2F;:&#x2F;root&#x2F;project&#x2F;atac&#x2F;raw 608eafa789c8</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看容器内是否已经存在fastq数据</span><br><span class="line">cd root&#x2F;project&#x2F;atac&#x2F;raw</span><br><span class="line">ls</span><br></pre></td></tr></table></figure>
<p><img src="https://gyq-images.oss-cn-hangzhou.aliyuncs.com/img/raw-ls.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 激活ATAC环境（该环境配置有处理ATAC-seq数据的所需软件）</span><br><span class="line">conda activate ATAC</span><br><span class="line"># (base)变成了(ATAC)，即由最初的conda环境变成了ATAC环境</span><br></pre></td></tr></table></figure>
<p><img src="https://gyq-images.oss-cn-hangzhou.aliyuncs.com/img/ATAC-environment.png"></p>
<h2 id="（三）、数据过滤"><a href="#（三）、数据过滤" class="headerlink" title="（三）、数据过滤"></a>（三）、数据过滤</h2><p><strong>运用软件 Trim Galore</strong></p>
<p><strong>去除接头和质量不合格的reads</strong></p>
<blockquote>
<p>Trim Galore是对FastQC和Cutadapt的包装。适用于所有高通量测序，包括RRBS(Reduced Representation Bisulfite-Seq ), Illumina、Nextera 和smallRNA测序平台的双端和单端数据。</p>
</blockquote>
<blockquote>
<p>Trimmomatic是针对Illumina高通量测序平台设计的接头去除和低质量reads清洗软件。</p>
</blockquote>
<p>附上trim-galore相关参考资料: <a href="https://www.jianshu.com/p/7a3de6b8e503">https://www.jianshu.com/p/7a3de6b8e503</a></p>
<p>以下列数据为例</p>
<p>2-cell-1  SRR2927015</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">trim_galore -q 7 --phred33 --length 35 -e 0.1 --stringency 4 --paired -o &#x2F;root&#x2F;project&#x2F;atac&#x2F;clean&#x2F; 2-cell-1_1.fastq.gz  2-cell-1_2.fastq.gz</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>trim_galore</strong></p>
<p>–q：设置线程</p>
<p>–phred33：使用ASCII+33质量值作为Phred的分</p>
<p>–length：去除长度小于参数值的reads</p>
<p>-e：允许的最大误差</p>
<p>–stringency：设置与接头重叠的序列</p>
<p>–paired：对于双段测序文件，正反链质控通过才保留</p>
<p>-o：输出目录</p>
</blockquote>
<p>结果如下</p>
<p><img src="https://gyq-images.oss-cn-hangzhou.aliyuncs.com/img/clean-data.png"></p>
<p>因为本次数据是用本机（8线程，16G）跑的，要给机子休息的时间，同时实验样本少，所以一个一个样本手动跑。<br>但是！当样本量多了，在服务器上跑的时候，循环就要省事很多，比如跑的时候去睡个觉…</p>
<p><strong>拿本次样本写个循环，举个例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls &#x2F;root&#x2F;project&#x2F;raw&#x2F;*1.fq.gz &gt;1</span><br><span class="line">ls &#x2F;root&#x2F;project&#x2F;raw&#x2F;*2.fq.gz &gt;2</span><br><span class="line">paste 1 2 &gt; sample</span><br><span class="line">path&#x3D;&#x2F;root&#x2F;project&#x2F;atac&#x2F;clean</span><br><span class="line">cat sample | while read id; do echo $id arr&#x3D;($id) fq1&#x3D;$&#123;arr[0]&#125; fq2&#x3D;$&#123;arr[1]&#125; nohup trim_galore -q 30 --phred33 -e 0.1 --stringency 4 --paired -o $path $fq1 $fq2 &amp; done</span><br></pre></td></tr></table></figure>
<h2 id="四-、质量控制"><a href="#四-、质量控制" class="headerlink" title="(四)、质量控制"></a>(四)、质量控制</h2><p><font color=red>测试数据的质控真的非常重要！！！如果测序质量本身就很好，没有质空这一步也影响不大。如果测序质量不好，不进行质控的化，直接影响后续的比对率。一般情况下，90%+的比对率才算比较正常，太低的比对率往往是质控步骤有问题，会非常严重的影响最终结果。亲测过！！！！</font></p>
<p><strong>运用软件fastqc、multiqc</strong></p>
<p><strong>进行批处理</strong></p>
<ul>
<li>数据质控</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;root&#x2F;project&#x2F;atac&#x2F;qc &amp;&amp; mkdir rawqc trimqc</span><br><span class="line"># 对原始数据进行质控</span><br><span class="line">cd rawqc</span><br><span class="line">fastqc -t 7 &#x2F;root&#x2F;project&#x2F;atac&#x2F;raw&#x2F;*gz -o .&#x2F;</span><br><span class="line"># 对过滤数据进行质控</span><br><span class="line">cd .. &amp; cd trimqc</span><br><span class="line">fastqc -t 7 &#x2F;root&#x2F;project&#x2F;atac&#x2F;clean&#x2F;*gz -o .&#x2F;</span><br></pre></td></tr></table></figure>
<p>（1）原始数据质控结果</p>
<p><img src="https://gyq-images.oss-cn-hangzhou.aliyuncs.com/img/rawqc.png"></p>
<p>（2）过滤后数据质量控制结果</p>
<p><img src="https://gyq-images.oss-cn-hangzhou.aliyuncs.com/img/trimqc.png"></p>
<ul>
<li>质控结果整合</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 原始数据qc结果整合</span><br><span class="line">cd &#x2F;root&#x2F;project&#x2F;atac&#x2F;qc&#x2F;rawqc &amp;&amp; mkdir multiqc_results</span><br><span class="line">multiqc . -o multiqc_results&#x2F;</span><br><span class="line"># 过滤数据qc结果整合</span><br><span class="line">cd &#x2F;root&#x2F;project&#x2F;atac&#x2F;qc&#x2F;trimqc &amp;&amp; mkdir multiqc_results</span><br><span class="line">multiqc . -o multiqc_results&#x2F;</span><br></pre></td></tr></table></figure>
<p>（1）原始数据整合结果</p>
<p><img src="https://gyq-images.oss-cn-hangzhou.aliyuncs.com/img/raw_multiqc.png"></p>
<p>（2）过滤数据整合结果</p>
<p><img src="https://gyq-images.oss-cn-hangzhou.aliyuncs.com/img/trim_multiqc.png"></p>
<p>附上multiqc相关参考资料<br><a href="https://blog.csdn.net/ada0915/article/details/77201871">https://blog.csdn.net/ada0915/article/details/77201871</a></p>
<ul>
<li>mulitiqc整合结果解读</li>
</ul>
<p>(1)过滤前</p>
<p><img src="https://gyq-images.oss-cn-hangzhou.aliyuncs.com/img/multiqc-raw-heatmap.png"></p>
<p>（2）过滤后</p>
<p><img src="https://gyq-images.oss-cn-hangzhou.aliyuncs.com/img/multiqc-trim-heatmap.png"></p>
<p>（3）解读（随便一搜，各种解读教程实在太多了～）</p>
<p>trim-galore完美的去除了adaptor;去除了质量不合格的序列使得2-cell-1_2和2-cell-2_2的质量过关；2-cell-1_2的N含量超标的序列被去除了。</p>
<p>因为去除了adptor和质量不合格的序列，所以sequence length自然是不一致的了。另外，还没有PCR去重，所以sequence duplication是不过关的，这一点会在PCR去重步骤中得到解决。至于Per Base Sequence Content,前10个碱基总是异常的波动，比对序列长度远大于10，处理时也可以设定不比对前10个，所以这个关系不大。</p>
<p>（4）以Sequence Length和Per Base N Content展示过滤前后的区别</p>
<p>过滤前</p>
<p><img src="https://gyq-images.oss-cn-hangzhou.aliyuncs.com/img/raw-sequence-display.png"></p>
<p>过滤后</p>
<p><img src="https://gyq-images.oss-cn-hangzhou.aliyuncs.com/img/trim-sequence-display.png"></p>
<h2 id="五-比对参考基因组"><a href="#五-比对参考基因组" class="headerlink" title="(五)比对参考基因组"></a>(五)比对参考基因组</h2><p><strong>运用软件bowtie2、bedtools</strong></p>
<p>一般对于DNA数据，比对软件一般使用：<strong>bowtie2、bwa</strong></p>
<p>对于RNA数据，比对一般使用：<strong>hisat2、star</strong></p>
<p>使用<strong>bedtools</strong>将最终的bam文件转成bed文件</p>
<p><strong>（1）参考基因组及其注释文件的下载</strong></p>
<p>参考基因组（解压后）<br><img src="https://gyq-images.oss-cn-hangzhou.aliyuncs.com/img/genome.png"></p>
<p>参考基因组注释文件（解压后）<br><img src="https://gyq-images.oss-cn-hangzhou.aliyuncs.com/img/gtf.png"></p>
<p>本次分析用到的是小鼠的参考基因组及其注释文件</p>
<p>mm10.fa、gencode.vM24.annotation.gtf</p>
<p><strong>（2）参考基因组索引构建</strong>（将构建的参考基因组索引文件cp到容器中的/root/project/atac/reference/mm10_index目录下）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bowtie2-build &#x2F;home&#x2F;gongyuqi&#x2F;biosoftware&#x2F;reference&#x2F;genome&#x2F;mm10.fa mm10_index</span><br></pre></td></tr></table></figure>
<p><img src="https://gyq-images.oss-cn-hangzhou.aliyuncs.com/img/mm10_index.png"></p>
<p><strong>（3）参考基因组的比对，直接生成bam文件</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bowtie2 -p 7 -x &#x2F;root&#x2F;project&#x2F;atac&#x2F;reference&#x2F;mm10_index -1 ..&#x2F;clean&#x2F;2-cell-1_1_val_1.fq.gz -2 ..&#x2F;clean&#x2F;2-cell-1_2_val_2.fq.gz | samtools sort -@ 7 -O bam -o 2-cell-1.bam -</span><br><span class="line"># 此samtools sort默认按照reads比对到染色体上的坐标排序</span><br></pre></td></tr></table></figure>
<p>bowtie2直接比对的结果会生成sam文件，sam文件很大，比较占空间。在比对这一步就直接利用samtools sort将其转成bam文件。</p>
<p>另外，samtool排序过程中并不会丢弃一部分reads，但是排序后的bam文件相比排序前的体积会更小。</p>
<p>比对相关参考资料</p>
<p><a href="https://www.jianshu.com/p/6ed1bfbb7b72">https://www.jianshu.com/p/6ed1bfbb7b72</a></p>
<p><strong>比对结果</strong></p>
<p>以2-cell-1_1_val为例进行结果展示</p>
<p><img src="https://gyq-images.oss-cn-hangzhou.aliyuncs.com/img/align_result.png"></p>
<p><strong>（4）构建原始bam文件的索引文件、状态文件</strong></p>
<p>构建索引文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls *.bam | while read id; do samtools index -@ 7 $id; done</span><br></pre></td></tr></table></figure>
<p>.bai文件即位生成的索引文件</p>
<p><img src="https://gyq-images.oss-cn-hangzhou.aliyuncs.com/img/bam.bai.png"></p>
<p>构建状态文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls *.bam | while read id; do samtools flagstat -@ 7 $id &gt; $id.stat; done</span><br></pre></td></tr></table></figure>
<p><img src="https://gyq-images.oss-cn-hangzhou.aliyuncs.com/img/bam.stat.png"></p>
<p><strong>（5）去除PCR重复、构建去重后的索引文件、状态文件、</strong></p>
<p>sambamba软件去重，会同时生成了去重后的bam和bai文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls *.bam | while read id; do sambamba markdup -r -t 7 $id rmdup.$id; done</span><br></pre></td></tr></table></figure>
<p><img src="https://gyq-images.oss-cn-hangzhou.aliyuncs.com/img/rmdup-bam-bai.png"></p>
<p>构建状态文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls rmdup*.bam | while read id; do samtools flagstat -@ 7 $id &gt; $id.stat; done</span><br></pre></td></tr></table></figure>
<p><img src="https://gyq-images.oss-cn-hangzhou.aliyuncs.com/img/rmdup-stat.png"></p>
<p><strong>（6）去除同一样本的两条reads无法落在同一条染色体及测序质量低于30的reads、去除线粒体基因、构建索引文件、构建状态文件</strong></p>
<p>去除不符合要求的reads及线粒体基因</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls rm*.bam | while read id; do samtools view -@ 7 -h -f 2 -q 30 $id | grep -v chrM |samtools sort -O bam -@7 -o last.$id; done</span><br></pre></td></tr></table></figure>
<p>构建索引文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls last*.bam | while read id; do samtools index -@ 7 $id; done</span><br></pre></td></tr></table></figure>
<p>构建状态文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls last*.bam | while read id; do samtools flagstat -@ 7 $id &gt; $id.stat; done</span><br></pre></td></tr></table></figure>
<p><img src="https://gyq-images.oss-cn-hangzhou.aliyuncs.com/img/rmdup-last-all.png"></p>
<p><strong>（7）生成bed文件</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls last*.bam | while read id; do bedtools bamtobed -i $id &gt; $id.bed; done</span><br></pre></td></tr></table></figure>
<p><img src="https://gyq-images.oss-cn-hangzhou.aliyuncs.com/img/last-bed.png"></p>
<h2 id="（六）使用macs2找peaks"><a href="#（六）使用macs2找peaks" class="headerlink" title="（六）使用macs2找peaks"></a>（六）使用macs2找peaks</h2><p><strong>使用软件macs2</strong></p>
<p>以last.rmdup.2-cell-1.bam.bed进行演示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">macs2 callpeak -t last.rmdup.2-cell-1.bam.bed -g mm --nomodel --shift -100 --extsize 200 -n 2-cell-1 --outdir ..&#x2F;peaks&#x2F;</span><br></pre></td></tr></table></figure>
<p>最终生成文件<br><img src="https://gyq-images.oss-cn-hangzhou.aliyuncs.com/img/peaks.png"></p>
<h2 id="peaks注释"><a href="#peaks注释" class="headerlink" title="peaks注释"></a>peaks注释</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">setwd(<span class="string">&quot;path\\to\\.bed&quot;</span>)</span><br><span class="line">library(ChIPpeakAnno)</span><br><span class="line">library(TxDb.Mmusculus.UCSC.mm10.knownGene)</span><br><span class="line">library(org.Mm.eg.db)</span><br><span class="line">library(BiocInstaller)</span><br><span class="line">library(ChIPseeker)</span><br><span class="line">txdb &lt;- TxDb.Mmusculus.UCSC.mm10.knownGene</span><br><span class="line">promoter &lt;- getPromoters(TxDb=txdb, upstream=<span class="number">3000</span>, downstream=<span class="number">3000</span>)</span><br><span class="line">files = <span class="built_in">list</span>(cell_1_summits = <span class="string">&quot;2-cell-1_summits.bed&quot;</span>, cell_2_summits = <span class="string">&quot;2-cell-2_summits.bed&quot;</span>,</span><br><span class="line">             cell_4_summits = <span class="string">&quot;2-cell-4_summits.bed&quot;</span>, cell_5_summits = <span class="string">&quot;2-cell-5_summits.bed&quot;</span>)</span><br><span class="line">peakAnno &lt;- annotatePeak(files[[<span class="number">1</span>]], <span class="comment"># 分别改成2或者3或者4即可，分别对应四个文件</span></span><br><span class="line">                         tssRegion=<span class="built_in">c</span>(-<span class="number">3000</span>, <span class="number">3000</span>),</span><br><span class="line">                         TxDb=txdb, annoDb=<span class="string">&quot;org.Mm.eg.db&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>（1）拿到每个样本中peaks对应得基因名</strong></p>
<p>这一步非常重要，拿到基因名就可以根据课题需要进行差异分析等</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">genelist&lt;-peakAnno@anno@elementMetadata@listData[[<span class="string">&quot;SYMBOL&quot;</span>]]</span><br></pre></td></tr></table></figure>
<p><strong>（2）单个文件作图</strong></p>
<p>图片就不做展示了</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">plotAnnoPie(peakAnno)</span><br><span class="line">plotAnnoBar(peakAnno)</span><br><span class="line">vennpie(peakAnno)</span><br><span class="line">upsetplot(peakAnno)</span><br><span class="line">upsetplot(peakAnno, vennpie=<span class="literal">TRUE</span>)</span><br></pre></td></tr></table></figure>
<p><strong>（3）plotAnnoBar和plotDistToTSS这两个柱状图都支持多个数据同时展示，方便比较</strong></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">setwd(<span class="string">&quot;path\\to\\.bed&quot;</span>)</span><br><span class="line">library(ChIPpeakAnno)</span><br><span class="line">library(TxDb.Mmusculus.UCSC.mm10.knownGene)</span><br><span class="line">library(org.Mm.eg.db)</span><br><span class="line">library(BiocInstaller)</span><br><span class="line">library(ChIPseeker)</span><br><span class="line">txdb &lt;- TxDb.Mmusculus.UCSC.mm10.knownGene</span><br><span class="line">promoter &lt;- getPromoters(TxDb=txdb, upstream=<span class="number">3000</span>, downstream=<span class="number">3000</span>)</span><br><span class="line">files = <span class="built_in">list</span>(cell_1_summits = <span class="string">&quot;2-cell-1_summits.bed&quot;</span>, cell_2_summits = <span class="string">&quot;2-cell-2_summits.bed&quot;</span>,</span><br><span class="line">             cell_4_summits = <span class="string">&quot;2-cell-4_summits.bed&quot;</span>, cell_5_summits = <span class="string">&quot;2-cell-5_summits.bed&quot;</span>)</span><br><span class="line">peakAnnoList &lt;- lapply(files, annotatePeak, </span><br><span class="line">                       TxDb=txdb,tssRegion=<span class="built_in">c</span>(-<span class="number">3000</span>, <span class="number">3000</span>))</span><br><span class="line">plotAnnoBar(peakAnnoList)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/feature-distribution.JPG"/>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">plotDistToTSS(peakAnnoList, title = <span class="string">&quot;Distribution of transcription factor-binding loci\nrelative to TSS&quot;</span>)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/loci-to-TSS.JPG"/>

<p><strong>（4）查看peaks在全基因组的位置（以2-cell-1样本为例）</strong></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">chropeaks&lt;-readPeakFile(<span class="string">&quot;2-cell-1_peaks.narrowPeak&quot;</span>)</span><br><span class="line">covplot(chropeaks, weightCol=<span class="number">5</span>, title = <span class="string">&quot;Peaks over chromosomes&quot;</span>)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/peaks-over-chromsomes.JPG"/>


<p><strong>（4）重复样本间共同的peaks和注释基因</strong></p>
<p>也可以用拿到的各个样本的基因名，做韦恩图，会比这个图更美观。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">genes&lt;-lapply(peakAnnoList, <span class="keyword">function</span>(i) as.data.frame(i)$geneId)</span><br><span class="line">vennplot(genes)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/peaks-overlap.JPG"/>

<p>peaks注释相关参考资料</p>
<p><a href="https://www.jianshu.com/p/c83a38915afc">https://www.jianshu.com/p/c83a38915afc</a></p>
]]></content>
      <tags>
        <tag>NGS</tag>
      </tags>
  </entry>
  <entry>
    <title>LVM逻辑卷管理器</title>
    <url>/2020/02/08/LVM%E9%80%BB%E8%BE%91%E5%8D%B7%E7%AE%A1%E7%90%86%E5%99%A8/</url>
    <content><![CDATA[<p>磁盘管理（进阶篇）</p>
<a id="more"></a>

<h1 id="LVM逻辑卷管理器"><a href="#LVM逻辑卷管理器" class="headerlink" title="LVM逻辑卷管理器"></a>LVM逻辑卷管理器</h1><ul>
<li>前面的磁盘管理（基础篇）介绍的磁盘管理技术虽然能够有效地提高硬盘设备的读写速度以及数据的安全性，但是在硬盘分好区后，再想修改硬盘分区大小就不容易了。当用户想要随着实际需求的变化调整硬盘分区的大小时，会受到硬盘“灵活性”的限制。这时就需要用到另外一项非常普及的硬盘设备资源管理技术了—<strong>LVM（逻辑卷管理器）</strong>。LVM可以允许用户对硬盘资源进行动态调整。  </li>
<li>LVM技术是在硬盘分区和文件系统之间添加了一个逻辑层，它提供了一个抽象的卷组，可以把多块硬盘进行卷组合并。这样一来，用户不必关心物理硬盘设备的底层架构和布局，就可以实现对硬盘分区的动态调整。  <img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/LVMstructure.JPG"/></li>
</ul>
<p><strong>PV,Physical Volume</strong><br><strong>VG,Volume Group</strong><br><strong>LV,Logical Volume</strong> </p>
<ul>
<li>物理卷处于LVM中的最底层。卷组建立在物理卷之上，一个卷组可以包含多个物理卷，而且在卷组创建之后也可以继续向其中添加新的物理卷。逻辑卷是用卷组中空闲的资源建立的，并且逻辑卷在建立后可以动态地扩展或缩小空间。这就是LVM的核心理念。 </li>
</ul>
<h2 id="部署逻辑卷"><a href="#部署逻辑卷" class="headerlink" title="部署逻辑卷"></a>部署逻辑卷</h2><p>该实验在VMware中进行，首先<strong>拍摄快照</strong>，以便在实验结束后恢复原有状态。<br><strong>依次创建物理卷PV、卷组VG、逻辑卷LV</strong>  </p>
<ol>
<li>在虚拟机中添加两块新硬盘设备。我们先对这两块新硬盘进行创建物理卷的操作，可以将该操作简单理解成让硬盘设备支持LVM技术。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fdisk -l <span class="comment">#此时可以看出多出了/dev/sdb /dev/sdc的信息</span></span><br><span class="line">pvcreate /dev/sdb /dev/sdc <span class="comment">#让硬盘设备支持LVM技术</span></span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/pvcreate.JPG"/>


<ol start="2">
<li>把两块硬盘设备加入到newvg卷组中，然后查看卷组状态  </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vgcreate newvg /dev/sdb /dev/sdc</span><br><span class="line">vgdisplay</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/vgcreate.JPG"/>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/vgdispaly.JPG"/>

<ol start="3">
<li>切割出一个约160M的逻辑卷LV  <blockquote>
<p>在对逻辑卷进行切割时有两种计量单位。第一种是以容量为单位，所使用的参数为-L。例如，使用-L 150M生成一个大小为150MB的逻辑卷。另外一种是以基本单元的个数为单位，所使用的参数为-l。每个基本单元的大小默认为4MB。例如，使用-l 37可以生成一个大小为37×4MB=148MB的逻辑卷。</p>
</blockquote>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lvdisplay <span class="comment">#查看当前逻辑卷情况</span></span><br><span class="line">lvcreate -n newlv -l 40 newvg</span><br><span class="line">lvdisplay <span class="comment">#创建逻辑卷后查看逻辑卷情况</span></span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/lvcre.dis..JPG"/>

<ol start="4">
<li>把生成的逻辑卷格式化，然后挂载使用<blockquote>
<p>Linux系统会把LVM中的逻辑卷设备存放在/dev设备目录中（实际上是做了一个符号链接），同时会以卷组的名称来建立一个目录，其中保存了逻辑卷的设备映射文件（即/dev/卷组名称/逻辑卷名称）。  </p>
</blockquote>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkfs.xfs /dev/newvg/newlv</span><br><span class="line">mkdir /newlv</span><br><span class="line">mount /dev/newvg/newlv /newlv</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/lvmkfsmount.JPG"/>

<ol start="5">
<li>查看挂载状态，并写入配置文件  </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">df -h</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;/dev/newvg/newlv /newlv xfs defaults 0 0&quot;</span> &gt;&gt; /etc/fstab</span><br><span class="line">df -h</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/df_h.JPG"/>

<h2 id="扩容逻辑卷"><a href="#扩容逻辑卷" class="headerlink" title="扩容逻辑卷"></a>扩容逻辑卷</h2><blockquote>
<p>用户在使用存储设备时感知不到设备底层的架构和布局，更不用关心底层是由多少块硬盘组成的，只要卷组中有足够的资源，就可以一直为逻辑卷扩容。扩展前请一定要记得卸载设备和挂载点的关联。  </p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">umount /newlv</span><br></pre></td></tr></table></figure>
<ol>
<li>把上诉逻辑卷newlv扩展至30G  </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lvextend -L 30G /dev/newvg/newlv</span><br><span class="line">mount -a</span><br><span class="line">df -h</span><br><span class="line"><span class="comment">#xfs文件系统需要执行xfs_growfs操作，需要先挂载，所以上面先执行了mount -a命令</span></span><br><span class="line">xfs_growfs /dev/newvg/newlv</span><br><span class="line">df -h</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/lvextend.JPG"/>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/lvextendresult.JPG"/>

<p><strong>注意</strong><br><font color=blue>使用 resize2fs或xfs_growfs 对挂载目录在线扩容</font><br><font color=blue>resize2fs 针对文件系统ext2 ext3 ext4</font><br><font color=blue>xfs_growfs 针对文件系统xfs</font></p>
<p><strong>xfs文件系统是不支持缩减逻辑卷操作，所以为了演示缩小逻辑卷操作，先将xfs文件系统重新格式化成ext4文件系统</strong> </p>
<ol>
<li>ext4文件系统的扩容操作  </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">umount /newlv</span><br><span class="line">mkfs.ext4 /dev/newvg/newlv</span><br><span class="line">vim /etc/fstab <span class="comment">#将/dev/newvg/newlv对应的xfs改成ext4,改变文件系统类型并不会影响磁盘上的数据</span></span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/trans..JPG"/>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lvextend -L 35G /dev/newvg/newlv</span><br><span class="line">e2fsck -f /dev/newvg/newlv <span class="comment">#检查硬盘完整型，针对ext4执行</span></span><br><span class="line">mount -a</span><br><span class="line">df -h</span><br><span class="line">resize2fs /dev/newvg/newlv</span><br><span class="line">df -h</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/ext4lvextend.JPG"/>





<h2 id="缩小逻辑卷"><a href="#缩小逻辑卷" class="headerlink" title="缩小逻辑卷"></a>缩小逻辑卷</h2><p><strong>执行缩容前一定确保最终的大小要大于现有数据所占的空间</strong><br>执行缩容操作前记得先把文件系统卸载掉  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">umount /newlv</span><br></pre></td></tr></table></figure>
<ol>
<li>把逻辑卷newlv的容量减小到100M  </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">umount /newlv</span><br><span class="line">df -h</span><br><span class="line">e2fsck -f /dev/newvg/newlv</span><br><span class="line">resize2fs /dev/newvg/newlv 5G  </span><br><span class="line">lvreduce -L 5G /dev/newvg/newlv <span class="comment">##奇怪，我之前运行的时候没有加此操作，依然能够成功</span></span><br><span class="line">mount -a</span><br><span class="line">df -h</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/ext4lvreduce.JPG"/>

<h2 id="逻辑卷快照"><a href="#逻辑卷快照" class="headerlink" title="逻辑卷快照"></a>逻辑卷快照</h2><p>可以对某一个逻辑卷设备做一次快照，如果日后发现数据被改错了，就可以利用之前做好的快照卷进行覆盖还原。LVM的快照卷功能有两个特点：   </p>
<blockquote>
<p>快照卷的容量必须等同于逻辑卷的容量；<br> 快照卷仅一次有效，一旦执行还原操作后则会被立即自动删除。</p>
</blockquote>
<p>查看卷组信息<br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/vgdisplaysnap1.JPG"/><br>卷组输出结果显示已经使用5G的容量，空闲容量还有34.99GB.  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;This is a test about LVNSnap&quot;</span> &gt; /LVMtest/file  </span><br></pre></td></tr></table></figure>
<ol>
<li>使用-s参数生成一个快照卷，使用-L参数指定切割的大小。另外，还要在命令后面写上是针对哪个逻辑卷执行的快照操作。  </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lvcreate -L 5G -s -n SNAP /dev/volumegroup/logicalvolume</span><br><span class="line">vgdispaly</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/vgdisplaysnap2.JPG"/>

<ol start="2">
<li>在逻辑卷所挂载的目录中创建一个100MB的垃圾文件，然后再查看快照卷的状态。可以发现存储空间占的用量上升了。  </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/dev/zero of=/LVMtest/FILE count=1 bs=100M</span><br><span class="line">vgdisplay</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/vgdisplaysnap3.JPG"/>

<ol start="3">
<li>为了校验SNAP快照卷的效果，需要对逻辑卷进行快照还原操作。在此之前记得先卸载掉逻辑卷设备与目录的挂载</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">df -h</span><br><span class="line">umount /LVWtest</span><br><span class="line">lvconvert --merge /dev/volumegroup/SNAP </span><br><span class="line">mount -a</span><br><span class="line">ls /LVMtest </span><br><span class="line"><span class="comment">#此时我们之前创建的100M大小的垃圾文件FILE不见了，因为这个文件是LVM快照之后创建的文件</span></span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/SNAPlvm.JPG"/>


<h2 id="删除逻辑卷"><a href="#删除逻辑卷" class="headerlink" title="删除逻辑卷"></a>删除逻辑卷</h2><p><strong>依次删除逻辑卷、卷组、物理卷设备，顺序不可颠倒</strong>  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">umount /newlv</span><br><span class="line">vim /etc/fstab <span class="comment">#删除掉/dev/newvg/newlv相关信息</span></span><br><span class="line">lvremove /dev/newvg/newlv</span><br><span class="line">vgremove newvg</span><br><span class="line">pvremove /dev/sdb /dev/sdc</span><br><span class="line"><span class="comment">#执行下面的命令分别查看LV、VG、PV的情况，发现/dev/newvg/newlv相关信息消失</span></span><br><span class="line">lvdisplay</span><br><span class="line">vgdisplay</span><br><span class="line">pvdisplay</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/removelvm.JPG"/>



<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/qq_33932782/article/details/76612965">https://blog.csdn.net/qq_33932782/article/details/76612965</a></p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown学习教程</title>
    <url>/2020/02/01/Markdown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>基础教程，随便写写</p>
<a id="more"></a>

<h1 id="Markdown学习教程"><a href="#Markdown学习教程" class="headerlink" title="Markdown学习教程"></a>Markdown学习教程</h1><p><img src="https://ftp.bmp.ovh/imgs/2020/02/993e8d3010da3e06.jpg">  </p>
<blockquote>
<p>Markdown语言在2004年由John Gruber创建，是以一种轻量级标记语言，它允许人们使用易读写的纯文本格式编写文档。Markdown编写的文档可以导出HTML、Word、PDF、Epub等多种格式的文档，编写的文档后缀为<code>.md</code>，<code>.markdown</code>。       </p>
</blockquote>
<blockquote>
<p>本学习教程在<strong>Windows</strong>下使用<strong>visual studio code</strong>编辑器讲解Markdown的语法。<br>Visual Studio Code官网：<a href="https://aka.ms/win32-x64-user-stable">https://aka.ms/win32-x64-user-stable</a><br>Visual Studio Code(for windows)下载地址：<a href="https://aka.ms/win32-x64-user-stable">https://aka.ms/win32-x64-user-stable</a></p>
</blockquote>
<h2 id="Markdown-标题"><a href="#Markdown-标题" class="headerlink" title="Markdown 标题"></a>Markdown 标题</h2><p><strong>1、使用#号可表示1-6级标题，一级标题对应一个#号，六级标题对应六个#号。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br><span class="line">&#96;&#96;&#96;   </span><br><span class="line"></span><br><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题    </span><br><span class="line">**2、使用&#x3D;和-标记一级标题和二级标题**     </span><br></pre></td></tr></table></figure>
<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一级标题</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;   </span><br><span class="line">二级标题</span><br><span class="line">-------</span><br><span class="line"></span><br><span class="line">## Markdown 段落  </span><br><span class="line">**Markdown段落的换行是使用两个以上空格加上回车。**   </span><br><span class="line">**Markdown段落的换行也可以使用一个空行来开始新的一行**   </span><br><span class="line"></span><br><span class="line">## Markdown 列表</span><br><span class="line">Markdown支持无序列表和有序列表。</span><br><span class="line"></span><br><span class="line">**无序列表使用星号(*)、加号(+)、或是减号(-)作为列表标记。** 符号后面一定要空一格。 </span><br></pre></td></tr></table></figure>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项  </li>
</ul>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项  </li>
</ul>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 第一项</span><br><span class="line">* 第二项</span><br><span class="line">* 第三项  </span><br><span class="line">+ 第一项</span><br><span class="line">+ 第二项</span><br><span class="line">+ 第三项  </span><br><span class="line">- 第一项</span><br><span class="line">- 第二项</span><br><span class="line">- 第三项  </span><br><span class="line"></span><br><span class="line">**有序列表使用数字并加上&#96;.&#96;号表示。**  </span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li>第一项</li>
<li>第二项</li>
<li>第三项<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 第一项  </span><br><span class="line">2. 第二项</span><br><span class="line">3. 第三项         </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**列表嵌套**(注意使用tab键)</span><br></pre></td></tr></table></figure></li>
<li>第一项<ul>
<li>第一项嵌套的第一个元素</li>
<li>第一项嵌套的第二个元素</li>
</ul>
</li>
<li>第二项  <ul>
<li>第二项嵌套的第一个元素</li>
<li>第二项嵌套的第二个元素 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 第一项  </span><br><span class="line">   - 第一项嵌套的第一个元素</span><br><span class="line">   - 第一项嵌套的第二个元素  </span><br><span class="line">2. 第二项   </span><br><span class="line">   - 第二项嵌套的第一个元素</span><br><span class="line">   - 第二项嵌套的第二个元素  </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">## Markdown 区块  </span><br><span class="line">Markdown区块引用是在段落开头使用&#96;&gt;&#96;符号，然后后面紧跟一个**空格**符号(为什么亲测&#96;&gt;&#96;符号后面跟不跟空格都没关系呢)。  </span><br></pre></td></tr></table></figure>
<blockquote>
<p>区块引用<br>区块引用<br>区块引用</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; 区块引用  </span><br><span class="line">&gt; 区块引用  </span><br><span class="line">&gt; 区块引用    </span><br><span class="line"></span><br><span class="line">区块也可以嵌套，一个&#96;&gt;&#96;符号是最外层，两个&#96;&gt;&#96;符号是第一层嵌套，以此类推。  </span><br></pre></td></tr></table></figure>
<blockquote>
<p>最外层</p>
<blockquote>
<p>第一层嵌套</p>
<blockquote>
<p>第二层嵌套</p>
</blockquote>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; 最外层   </span><br><span class="line">&gt;&gt; 第一层嵌套   </span><br><span class="line">&gt;&gt;&gt; 第二层嵌套   </span><br><span class="line"></span><br><span class="line">区块中使用列表  </span><br></pre></td></tr></table></figure>
<blockquote>
<p>区块中使用列表</p>
<ol>
<li>第一项</li>
<li>第二项</li>
</ol>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; 区块中使用列表  </span><br><span class="line">&gt; 1. 第一项  </span><br><span class="line">&gt; 2. 第二项  </span><br><span class="line">&gt; + 第一项  </span><br><span class="line">&gt; + 第二项  </span><br><span class="line">&gt; + 第三项  </span><br><span class="line"></span><br><span class="line">列表中使用区块  </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<ul>
<li>第一项   <blockquote>
<p>第一项的第一步<br>第一项的第二部  </p>
</blockquote>
</li>
<li>第二项<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 第一项    </span><br><span class="line">    &gt; 第一项的第一步   </span><br><span class="line">    &gt; 第一项的第二部   </span><br><span class="line">* 第二项  </span><br><span class="line">    &gt; 第二项的第一步</span><br><span class="line">    &gt; 第二项的第二部   </span><br><span class="line"></span><br><span class="line">## Markdown 代码</span><br><span class="line">如果是段落上的一个函数或者片段的代码可以用引号把它包起来(&#96;&#96;).</span><br></pre></td></tr></table></figure>
<code>printf()</code> 函数<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;printf()&#96;函数  </span><br><span class="line"></span><br><span class="line">**代码区块**     </span><br><span class="line">代码区块使用4个空格或者一个制表符(tab键)。   </span><br><span class="line">&gt;      mkdir test  </span><br><span class="line">&gt;      touch test.txt  </span><br><span class="line">&gt;      echo &quot;This is a test&quot;   </span><br><span class="line">  </span><br><span class="line">    mkdir test  </span><br><span class="line">    touch test.txt  </span><br><span class="line">    echo &quot;This is a test&quot;  </span><br><span class="line"></span><br><span class="line">代码区块也可以用两个&#96; &#96;&#96;&#96; &#96;包裹一段代码，并指定一种语言（也可以不指定）  </span><br><span class="line">*&#96;&#96;&#96;*   </span><br><span class="line">mkdir test  </span><br><span class="line">touch test.txt  </span><br><span class="line">echo &quot;This is a test&quot;  </span><br><span class="line"></span><br><span class="line">*&#96;&#96;&#96;* </span><br></pre></td></tr></table></figure>
mkdir test<br>touch test.txt<br>echo “This is a test”<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">## Markdown 链接      </span><br><span class="line">**显示关键词，指向一个链接**</span><br></pre></td></tr></table></figure>
<a href="%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80" title="（可选）添加一个标题">关键词</a><br><a href="https://www.baidu.com/">百度</a>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[百度](https:&#x2F;&#x2F;www.baidu.com&#x2F;)  </span><br><span class="line"></span><br><span class="line">**展示链接地址**</span><br></pre></td></tr></table></figure>
&lt;链接地址&gt;<br>或者<br>链接地址<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;www.baidu.com&gt;       </span><br><span class="line">https:&#x2F;&#x2F;www.baidu.com&#x2F;   </span><br><span class="line"></span><br><span class="line">**引用**  </span><br><span class="line">如需多次添加某个链接，可以先给链接取个名字，下次再用到的时候就可以直接使用这个链接的名字，不用一直记住链接地址。  </span><br><span class="line">&#96;&#96;&#96;      </span><br><span class="line">给这个链接取个名字：</span><br><span class="line">[李老师]: https:&#x2F;&#x2F;lzqblog.top&#x2F;2020-01-31&#x2F;%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B-%E7%89%B9%E4%BE%9B%E7%89%88&#x2F;#more    </span><br><span class="line">使用这个链接名字       </span><br><span class="line">[一篇美好小文章][李老师]</span><br><span class="line">&#96;&#96;&#96;    </span><br><span class="line">[李老师]: https:&#x2F;&#x2F;lzqblog.top&#x2F;2020-01-31&#x2F;%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B-%E7%89%B9%E4%BE%9B%E7%89%88&#x2F;#more     </span><br><span class="line">重要的事情说三遍，嘿嘿  </span><br><span class="line">[一篇美好小文章][李老师]  </span><br><span class="line">[一篇美好小文章][李老师]  </span><br><span class="line">[一篇美好小文章][李老师]</span><br><span class="line"></span><br><span class="line">**将所有链接放文末**</span><br><span class="line">&#96;&#96;&#96;   </span><br><span class="line">I get 10 times more traffic from [Google] [1] than from</span><br><span class="line">[Yahoo] [2] or [MSN] [3].</span><br><span class="line"></span><br><span class="line">  [1]: http:&#x2F;&#x2F;google.com&#x2F;        &quot;Google&quot;</span><br><span class="line">  [2]: http:&#x2F;&#x2F;search.yahoo.com&#x2F;  &quot;Yahoo Search&quot;</span><br><span class="line">  [3]: http:&#x2F;&#x2F;search.msn.com&#x2F;    &quot;MSN Search&quot;</span><br></pre></td></tr></table></figure>
I get 10 times more traffic from [Google] <a href="http://google.com/" title="Google">1</a> than from<br>[Yahoo] <a href="http://search.yahoo.com/" title="Yahoo Search">2</a> or [MSN] <a href="http://search.msn.com/" title="MSN Search">3</a>.</li>
</ul>
<h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![]()</span><br><span class="line">![图片名称](图片地址 &quot;option title&quot;)</span><br><span class="line">&#96;&#96;&#96;  </span><br><span class="line">+ 开头一个感叹号！</span><br><span class="line">+ 接着一个方括号，里面放上图片的替代文字，可以不用写。</span><br><span class="line">+ 接着一个普通括号，里面放上图片地址。&quot;option title&quot;:鼠标悬置于图片上会出现的标题文字，可以不写。 </span><br><span class="line"></span><br><span class="line">目前有很多免费的在线图床网站。这里使用[ImgURL](https:&#x2F;&#x2F;imgurl.org&#x2F;)在线工具,上传要插入的图片，网页会自动生成URL等地址，如下图所示。 </span><br><span class="line"></span><br><span class="line">![](https:&#x2F;&#x2F;ftp.bmp.ovh&#x2F;imgs&#x2F;2020&#x2F;02&#x2F;160e2425ef881f4f.jpg)</span><br><span class="line"></span><br><span class="line">用上诉方法插图一张萌萌的图片</span><br></pre></td></tr></table></figure>
<p><img src="https://ftp.bmp.ovh/imgs/2020/02/4c9db7d1991a2aa7.jpg"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![](https:&#x2F;&#x2F;ftp.bmp.ovh&#x2F;imgs&#x2F;2020&#x2F;02&#x2F;4c9db7d1991a2aa7.jpg)  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">如果是firefox浏览器，右键鼠标点击复制图像地址，有的地址很长很长很长，但也不是每次复制的图像地址都能成功，所以这个方法比较悬。当然不同浏览器会有一定的区别。 </span><br></pre></td></tr></table></figure>
<p><img src="%E8%BF%99%E9%87%8C%E7%9A%84%E5%9C%B0%E5%9D%80%E6%9C%89%E6%97%B6%E5%80%99%E4%BC%9A%E9%9D%9E%E5%B8%B8%E9%95%BF%E5%BE%88%E9%95%BF%E5%8D%81%E5%88%86%E9%95%BF......"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">但是呢，我们家**可爱的李老师**用阿里oss搭建了自己的图床，还非常&lt;font color&#x3D;pink&gt;sweet&lt;&#x2F;font&gt;的教我用。所以呢，我现在就不用这么麻烦得用上面得方法啦！</span><br><span class="line">   </span><br><span class="line">**设置图片大小**    </span><br><span class="line">&#96;&#96;&#96;  </span><br><span class="line">设置图片大小方法一</span><br><span class="line">&lt;img src&#x3D;&quot;图片地址&quot; width&#x3D;&quot;30%&quot; height&#x3D;&quot;30%&quot;&gt;  </span><br><span class="line">原图大小  </span><br><span class="line">![](https:&#x2F;&#x2F;blog-image-host.oss-cn-shanghai.aliyuncs.com&#x2F;gyqblog&#x2F;pooh.gif)  </span><br><span class="line">改变图片大小  </span><br><span class="line">&lt;img src&#x3D;&quot;https:&#x2F;&#x2F;blog-image-host.oss-cn-shanghai.aliyuncs.com&#x2F;gyqblog&#x2F;pooh.gif&quot; width&#x3D;&quot;20%&quot; height&#x3D;&quot;20%&quot;&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;https:&#x2F;&#x2F;blog-image-host.oss-cn-shanghai.aliyuncs.com&#x2F;gyqblog&#x2F;pooh.gif&quot; width&#x3D;&quot;15%&quot; height&#x3D;&quot;15%&quot;&gt; </span><br><span class="line">&lt;img src&#x3D;&quot;https:&#x2F;&#x2F;blog-image-host.oss-cn-shanghai.aliyuncs.com&#x2F;gyqblog&#x2F;pooh.gif&quot; width&#x3D;&quot;10%&quot; height&#x3D;&quot;20%&quot;&gt;  </span><br><span class="line"></span><br><span class="line">设置图片大小方法二</span><br><span class="line">&lt;img src&#x3D;&quot;https:&#x2F;&#x2F;blog-image-host.oss-cn-shanghai.aliyuncs.com&#x2F;gyqblog&#x2F;pooh.gif&quot;&gt;   </span><br><span class="line">&lt;img src&#x3D;&quot;https:&#x2F;&#x2F;blog-image-host.oss-cn-shanghai.aliyuncs.com&#x2F;gyqblog&#x2F;pooh.gif&quot;  width&#x3D;&quot;200&quot; height&#x3D;&quot;200&quot;&gt;   </span><br><span class="line">&lt;img src&#x3D;&quot;https:&#x2F;&#x2F;blog-image-host.oss-cn-shanghai.aliyuncs.com&#x2F;gyqblog&#x2F;pooh.gif&quot;  width&#x3D;&quot;150&quot; height&#x3D;&quot;150&quot;&gt;  </span><br><span class="line">（方法二的结果就不展示了）</span><br><span class="line">&#96;&#96;&#96;  </span><br><span class="line">原图大小  </span><br><span class="line">![](https:&#x2F;&#x2F;blog-image-host.oss-cn-shanghai.aliyuncs.com&#x2F;gyqblog&#x2F;pooh.gif)    </span><br><span class="line">调整后大小   </span><br><span class="line">&lt;img src&#x3D;&quot;https:&#x2F;&#x2F;blog-image-host.oss-cn-shanghai.aliyuncs.com&#x2F;gyqblog&#x2F;pooh.gif&quot; width&#x3D;&quot;20%&quot; height&#x3D;&quot;20%&quot;&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;https:&#x2F;&#x2F;blog-image-host.oss-cn-shanghai.aliyuncs.com&#x2F;gyqblog&#x2F;pooh.gif&quot; width&#x3D;&quot;15%&quot; height&#x3D;&quot;10%&quot;&gt; </span><br><span class="line">&lt;img src&#x3D;&quot;https:&#x2F;&#x2F;blog-image-host.oss-cn-shanghai.aliyuncs.com&#x2F;gyqblog&#x2F;pooh.gif&quot; width&#x3D;&quot;10%&quot; height&#x3D;&quot;15%&quot;&gt;   </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;   </span><br><span class="line">图片位置设置  </span><br><span class="line">&lt;div align&#x3D;left&gt;&lt;img src&#x3D;&quot;https:&#x2F;&#x2F;blog-image-host.oss-cn-shanghai.aliyuncs.com&#x2F;gyqblog&#x2F;pooh.gif&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div align&#x3D;center&gt;&lt;img src&#x3D;&quot;https:&#x2F;&#x2F;blog-image-host.oss-cn-shanghai.aliyuncs.com&#x2F;gyqblog&#x2F;pooh.gif&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div align&#x3D;right&gt;&lt;img src&#x3D;&quot;https:&#x2F;&#x2F;blog-image-host.oss-cn-shanghai.aliyuncs.com&#x2F;gyqblog&#x2F;pooh.gif&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&#96;&#96;&#96;   </span><br><span class="line">&lt;div align&#x3D;left&gt;&lt;img src&#x3D;&quot;https:&#x2F;&#x2F;blog-image-host.oss-cn-shanghai.aliyuncs.com&#x2F;gyqblog&#x2F;pooh.gif&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div align&#x3D;center&gt;&lt;img src&#x3D;&quot;https:&#x2F;&#x2F;blog-image-host.oss-cn-shanghai.aliyuncs.com&#x2F;gyqblog&#x2F;pooh.gif&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div align&#x3D;right&gt;&lt;img src&#x3D;&quot;https:&#x2F;&#x2F;blog-image-host.oss-cn-shanghai.aliyuncs.com&#x2F;gyqblog&#x2F;pooh.gif&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## Markdown 表格   </span><br><span class="line">Markdown制作表格使用&#96;|&#96;来分隔不同的单元格，使用&#96;-&#96;来分隔表头和其他行。   </span><br><span class="line">&#96;&#96;&#96;  </span><br><span class="line">| 表头 | 表头 |   </span><br><span class="line">| ---- | ---- |   </span><br><span class="line">| 单元格 | 单元格 |   </span><br><span class="line">| 单元格 | 单元格 |</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>表头</th>
<th>表头</th>
</tr>
</thead>
<tbody><tr>
<td>单元格</td>
<td>单元格</td>
</tr>
<tr>
<td>单元格</td>
<td>单元格</td>
</tr>
</tbody></table>
<p>Markdown还可以设置表格的对其方式<br><code>-:</code>设置内容和标题栏居右对齐。<br><code>:-</code>设置内容和标题栏居左对齐。<br><code>:-:</code>设置内容和标题栏居中对齐。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| 左对齐 | 居中 | 右对齐|  </span><br><span class="line">| :---- | :----: | ----: |   </span><br><span class="line">| 单元格为左对齐 | 单元格居中 | 单元格右对齐 |   </span><br><span class="line">| 单元格为左对齐 | 单元格居中 | 单元格右对齐 |</span><br><span class="line">&#96;&#96;&#96;  </span><br><span class="line">| 左对齐 | 居中 | 右对齐|  </span><br><span class="line">| :---- | :----: | ----: |   </span><br><span class="line">| 单元格为左对齐 | 单元格居中 | 单元格右对齐 |   </span><br><span class="line">| 单元格为左对齐 | 单元格居中 | 单元格右对齐 |   </span><br><span class="line">## Markdown 初级技巧  </span><br><span class="line">**斜体、粗体**</span><br><span class="line">&#96;&#96;&#96;   </span><br><span class="line">*single asterisks*</span><br><span class="line"></span><br><span class="line">_single underscores_</span><br><span class="line"></span><br><span class="line">**double asterisks**</span><br><span class="line"></span><br><span class="line">__double underscores__  </span><br><span class="line"></span><br><span class="line">&lt;em&gt;single asterisks&lt;&#x2F;em&gt;</span><br><span class="line"></span><br><span class="line">&lt;em&gt;single underscores&lt;&#x2F;em&gt;</span><br><span class="line"></span><br><span class="line">&lt;strong&gt;double asterisks&lt;&#x2F;strong&gt;</span><br><span class="line"></span><br><span class="line">&lt;strong&gt;double underscores&lt;&#x2F;strong&gt;</span><br></pre></td></tr></table></figure>
<p><em>single asterisks</em></p>
<p><em>single underscores</em></p>
<p><strong>double asterisks</strong></p>
<p><strong>double underscores</strong>  </p>
<p><em>single asterisks</em></p>
<p><em>single underscores</em></p>
<p><strong>double asterisks</strong></p>
<p><strong>double underscores</strong>   </p>
<p><strong>删除线</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~~这是要删除的内容~~  </span><br><span class="line">&#96;&#96;&#96;  </span><br><span class="line">~~这是要删除的内容~~    </span><br><span class="line"></span><br><span class="line">**字体添加下划线**   </span><br><span class="line">&#96;&#96;&#96;  </span><br><span class="line">&lt;u&gt;需要添加下划线的字体&lt;&#x2F;u&gt;</span><br><span class="line">&#96;&#96;&#96;    </span><br><span class="line">&lt;u&gt;需要添加下划线的字体&lt;&#x2F;u&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## Markdown 高级技巧  </span><br><span class="line">**转义**  </span><br><span class="line">Markdown使用很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown使用反斜杠转义字符。  </span><br><span class="line">&#96;&#96;&#96;   </span><br><span class="line">**文本加粗**  </span><br><span class="line">\*\*正常显示星号\*\*</span><br><span class="line">&#96;&#96;&#96;    </span><br><span class="line">**文本加粗**  </span><br><span class="line">\*\*正常显示星号\*\*  </span><br><span class="line"></span><br><span class="line">Markdown支持以下这些符号前面加上反斜杠来帮助插入普通的符号。  </span><br><span class="line">\ 反斜线      </span><br><span class="line">&#96; 反引号  </span><br><span class="line">\* 星号  </span><br><span class="line">\- 下划线  </span><br><span class="line">&#123;&#125; 花括号  </span><br><span class="line">[] 方括号  </span><br><span class="line">() 小括号  </span><br><span class="line">\# 井号键   </span><br><span class="line">\+ 加号  </span><br><span class="line">\- 减号  </span><br><span class="line">. 英文句点  </span><br><span class="line">! 感叹号   </span><br><span class="line"></span><br><span class="line">**更改字体、大小、颜色**   </span><br><span class="line">&#96;&#96;&#96;   </span><br><span class="line">字体   </span><br><span class="line">&lt;font face&#x3D;&quot;字体名称&quot;&gt;显示的内容&lt;&#x2F;font&gt;</span><br><span class="line">&lt;font face&#x3D;&quot;黑体&quot;&gt;黑体&lt;&#x2F;font&gt;   </span><br><span class="line">&lt;font face&#x3D;&quot;Times New Roman&quot;&gt;Times New Roman&lt;&#x2F;font&gt;   </span><br><span class="line">&lt;font face&#x3D;&quot;Arial&quot;&gt;Arial&lt;&#x2F;font&gt;   </span><br><span class="line">颜色   </span><br><span class="line">&lt;font color&#x3D;red&gt;红色&lt;&#x2F;font&gt;  </span><br><span class="line">&lt;font color&#x3D;orange&gt;橙色&lt;&#x2F;font&gt;  </span><br><span class="line">&lt;font color&#x3D;yellow&gt;黄色&lt;&#x2F;font&gt;   </span><br><span class="line">$\color&#123;#FF0000&#125;&#123;红&#125;$ $\color&#123;#FF7D00&#125;&#123;橙&#125;$ $\color&#123;#FF0000&#125;&#123;黄&#125;$ $\color&#123;#00FF00&#125;&#123;绿&#125;$  $\color&#123;#0000FF&#125;&#123;蓝&#125;$ $\color&#123;#00FFFF&#125;&#123;靛&#125;$ $\color&#123;#FF00FF&#125;&#123;紫&#125;$</span><br><span class="line">尺寸（可能的值：从 1 到 7 的数字。浏览器默认值是 3）  </span><br><span class="line">&lt;font size&#x3D;1&gt;字体尺寸大小为1&lt;&#x2F;font&gt;  </span><br><span class="line">&lt;font size&#x3D;2&gt;字体尺寸大小为2&lt;&#x2F;font&gt;  </span><br><span class="line">&lt;font size&#x3D;3&gt;字体尺寸大小为3&lt;&#x2F;font&gt;</span><br><span class="line">&#96;&#96;&#96;        </span><br><span class="line">&lt;font face&#x3D;&quot;黑体&quot;&gt;黑体&lt;&#x2F;font&gt;  </span><br><span class="line">&lt;font face&#x3D;&quot;Times New Roman&quot;&gt;Times New Roman&lt;&#x2F;font&gt;   </span><br><span class="line">&lt;font face&#x3D;&quot;Arial&quot;&gt;Arial&lt;&#x2F;font&gt;  </span><br><span class="line">&lt;font color&#x3D;red&gt;红色&lt;&#x2F;font&gt;  </span><br><span class="line">&lt;font color&#x3D;orange&gt;橙色&lt;&#x2F;font&gt;  </span><br><span class="line">&lt;font color&#x3D;yellow&gt;黄色&lt;&#x2F;font&gt;   </span><br><span class="line">$\color&#123;#FF0000&#125;&#123;红&#125;$ $\color&#123;#FF7D00&#125;&#123;橙&#125;$ $\color&#123;#FF0000&#125;&#123;黄&#125;$ $\color&#123;#00FF00&#125;&#123;绿&#125;$  $\color&#123;#0000FF&#125;&#123;蓝&#125;$ $\color&#123;#00FFFF&#125;&#123;靛&#125;$ $\color&#123;#FF00FF&#125;&#123;紫&#125;$  </span><br><span class="line">&lt;font size&#x3D;1&gt;字体尺寸大小为1&lt;&#x2F;font&gt;  </span><br><span class="line">&lt;font size&#x3D;2&gt;字体尺寸大小为2&lt;&#x2F;font&gt;  </span><br><span class="line">&lt;font size&#x3D;3&gt;字体尺寸大小为3&lt;&#x2F;font&gt;   </span><br><span class="line"></span><br><span class="line">**为文字添加背景色**   </span><br><span class="line"></span><br><span class="line">借助table,tr,td等表格标签的bgcolor属性来实现背景色。这里对于文字背景色的设置，只是讲那一整行看作一个表格，更改了那个格子的背景色。   </span><br></pre></td></tr></table></figure>
<table><tr><td bgcolor=GreenYellow>GreenYellow</td></tr></table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;table&gt;&lt;tr&gt;&lt;td bgcolor&#x3D;GreenYellow&gt;GreenYellow&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;table&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**HTML标签&#39;&lt; span&gt;&#39;可同时实现更改字体、大小、颜色等要求** </span><br><span class="line">&#96;&#96;&#96;   </span><br><span class="line">&lt;span style&#x3D;&quot;color:Hotpink;font-family:Impact;font-style:Arial;cursor:crosshair;font-size:20px&quot;&gt;Impact font Hotpink Arial 20px with crosshair pointer&lt;&#x2F;span&gt; &lt;u&gt;&lt;font size&#x3D;1&gt;鼠标放上去试一试&lt;&#x2F;font&gt;&lt;&#x2F;u&gt;  </span><br><span class="line"></span><br><span class="line">&lt;span style&#x3D;&quot;color:Hotpink; font-family:Georgia; font-size:20px;&quot;&gt;Mr Li is so cute.&lt;&#x2F;span&gt;    </span><br><span class="line"></span><br><span class="line">&lt;span style&#x3D;&quot;color:Hotpink; font-family:Georgia;cursor:crosshair; font-size:20px;&quot;&gt;Mr Li is so cute.&lt;&#x2F;span&gt; &lt;u&gt;&lt;font size&#x3D;1&gt;鼠标放上去试一试&lt;&#x2F;font&gt;&lt;&#x2F;u&gt;</span><br></pre></td></tr></table></figure>
<span style="color:Hotpink;font-family:Impact;font-style:Arial;cursor:crosshair;font-size:20px">Impact font Hotpink Arial 20px with crosshair pointer</span> <u><font size=1>鼠标放上去试一试</font></u>  

<p><span style="color:Hotpink; font-family:Georgia; font-size:20px;">Mr Li is so cute.</span>    </p>
<p><span style="color:Hotpink; font-family:Georgia;cursor:crosshair; font-size:20px;">Mr Li is so cute.</span> <u><font size=1>鼠标放上去试一试</font></u></p>
<p><strong>复选框</strong><br>使用<code>- [ ]</code>和<code>- [×]</code>语法可以创建复选框  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- [x] Markdown  </span><br><span class="line">- [ ] JavaScript  </span><br><span class="line">+ [x] Markdown  </span><br><span class="line">+ [ ] JavaScript  </span><br><span class="line">* [x] Markdown  </span><br><span class="line">* [ ] JavaScript    </span><br></pre></td></tr></table></figure>
<ul>
<li><input checked="" disabled="" type="checkbox"> Markdown  </li>
<li><input disabled="" type="checkbox"> JavaScript     </li>
</ul>
<ul>
<li><input checked="" disabled="" type="checkbox"> Markdown  </li>
<li><input disabled="" type="checkbox"> JavaScript  </li>
</ul>
<ul>
<li><input checked="" disabled="" type="checkbox"> Markdown  </li>
<li><input disabled="" type="checkbox"> JavaScript     </li>
</ul>
<p>没有的以后想到再说吧~~~    </p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><strong><a href="https://lzqblog.top/2018-11-24/Markdown-frequently-used-syntax/">https://lzqblog.top/2018-11-24/Markdown-frequently-used-syntax/</a></strong><br><a href="https://www.runoob.com/markdown/md-tutorial.html">https://www.runoob.com/markdown/md-tutorial.html</a><br><a href="https://daringfireball.net/projects/markdown/syntax#html">https://daringfireball.net/projects/markdown/syntax#html</a><br><a href="https://blog.csdn.net/lewky_liu/article/details/85010827">https://blog.csdn.net/lewky_liu/article/details/85010827</a><br><a href="https://blog.csdn.net/qq_43731019/article/details/89385836">https://blog.csdn.net/qq_43731019/article/details/89385836</a><br><a href="https://www.jianshu.com/p/cdd313eebfd9">https://www.jianshu.com/p/cdd313eebfd9</a><br><a href="https://blog.csdn.net/heimu24/article/details/81189700">https://blog.csdn.net/heimu24/article/details/81189700</a>
    </p>
]]></content>
      <tags>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>MeRIP-Seq</title>
    <url>/2021/06/03/MeRIP-Seq/</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="MeRIP-Seq数据分析"><a href="#MeRIP-Seq数据分析" class="headerlink" title="MeRIP-Seq数据分析"></a>MeRIP-Seq数据分析</h1><ul>
<li><p><strong>看看推荐的MeRIP-seq数据分析流程</strong></p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/MeRIP-seq_pipeline.JPG"/>
</li>
<li><p><strong>今天要复现下面这篇文章中MeRIP-Seq相关的数据。</strong></p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/paper.JPG" width="50%">
</li>
<li><p><strong>看看文章作者如何处理MeRIP-seq数据的</strong></p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/method_MeRIP-seq.JPG"/>

</li>
</ul>
<h2 id="一-数据下载"><a href="#一-数据下载" class="headerlink" title="(一)数据下载"></a>(一)数据下载</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#GSE号：GSE133857</span></span><br><span class="line"><span class="comment">#简单的3个样本就不写脚本啦</span></span><br><span class="line"><span class="comment">#SRR9646136：HOC313 siControl_m6A_IP_replicate1</span></span><br><span class="line"><span class="comment">#SRR9646140：HOC313 siControl_m6A_IP_replicate2</span></span><br><span class="line"><span class="comment">#SRR9646137：HOC313 siControl_IgG_IP</span></span><br><span class="line">nohup preftch SRR9646136 &amp;</span><br><span class="line">nohup preftch SRR9646140 &amp;</span><br><span class="line">nohup preftch SRR9646137 &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment">#SRA文件转成fastq文件</span></span><br><span class="line">fastq-dump /path/to/xxx.sra </span><br><span class="line">ls *.sra|<span class="keyword">while</span> <span class="built_in">read</span> id; <span class="keyword">do</span> nohup fastq-dump --split-3 <span class="variable">$id</span>; <span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h2 id="二-数据比对"><a href="#二-数据比对" class="headerlink" title="(二) 数据比对"></a>(二) 数据比对</h2><h3 id="step-1、质量控制"><a href="#step-1、质量控制" class="headerlink" title="step 1、质量控制"></a>step 1、质量控制</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#质控，质控结果显示需要进一步过滤接头</span></span><br><span class="line"><span class="comment">#另外，GC含量很高，还出现双峰！！！</span></span><br><span class="line">fastqc -t 6 *fastq -o ./qc</span><br><span class="line"><span class="built_in">cd</span> ./qc</span><br><span class="line">multiqc *.zip -o ./</span><br><span class="line"><span class="comment">#trim-galore过滤</span></span><br><span class="line">cat fq.txt|<span class="keyword">while</span> <span class="built_in">read</span> id</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">arr=(<span class="variable">$&#123;id&#125;</span>)</span><br><span class="line">fq1=<span class="variable">$&#123;arr[0]&#125;</span></span><br><span class="line">fq2=<span class="variable">$&#123;arr[1]&#125;</span></span><br><span class="line">nohup trim_galore -q 20 --phred33 --length 20 -e 0.1 --stringency 3 --paired -o ../clean <span class="variable">$fq1</span> <span class="variable">$fq2</span> &amp;</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment">#过滤后质控,质控结果显示接头去除成功</span></span><br></pre></td></tr></table></figure>
<h3 id="step-2、HISAT2比对"><a href="#step-2、HISAT2比对" class="headerlink" title="step 2、HISAT2比对"></a>step 2、HISAT2比对</h3><p><strong>①、下载hisat2索引文件（含转录组信息）</strong></p>
<blockquote>
<p>首先去<a href="http://daehwankimlab.github.io/hisat2/download/#h-sapiens">HISAT2官网下载比对所需要的索引文件</a>。注意啦，因为我们是MeRIP-seq数据的比对，构建的索引需要把转录组信息加进去，所以我们这里下载UCSC的hg38：<a href="https://genome-idx.s3.amazonaws.com/hisat/hg38_tran.tar.gz">genome_tran</a>。注意了，这里选择UCSC的参考基因组，因为后面peak注释用到的工具——HOMER或者R包ChIPseeker内置的都是UCSC的参考基因组。如果你非要用到其他数据库的参考基因组，如NCBI的GRCh38，你就会在peaks注释阶段遇到染色体号相关的报错。当然，这个报错动动脑子也是可以解决的。</p>
</blockquote>
<blockquote>
<p>你也可以自己构建带有转录组信息的索引文件，HISAT2官网同样给出了<a href="http://daehwankimlab.github.io/hisat2/howto/#build-hgfm-index-with-transcripts">详细的教程</a>。但是，这个操作至少需要160G的内存😂，还是算了吧~~~没必要重复造轮子</p>
</blockquote>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/HISAT2_UCSC_hg38_index.JPG"/>




<p><strong>②、下载<a href="https://cloud.tencent.com/developer/article/1805475">rRNA的fastq文件</a>,构建rRNA文件的索引</strong></p>
<p>参考资料：<a href="https://cloud.tencent.com/developer/article/1805475">https://cloud.tencent.com/developer/article/1805475</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#HISAT2下载安装</span></span><br><span class="line"><span class="comment">#conda下载hisat2今天突然不好使了库😢，手动下载以下</span></span><br><span class="line">wget https://cloud.biohpc.swmed.edu/index.php/s/oTtGWbWjaxsQ2Ho/download</span><br><span class="line"><span class="comment">#file download发现其是zip文件</span></span><br><span class="line">unzip download</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=/home/gongyuqi/biosoft/HISAT2/hisat2-2.2.1:$PATH&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line"></span><br><span class="line"><span class="comment">#构建rRNA文件索引</span></span><br><span class="line"><span class="built_in">cd</span> /home/gongyuqi/ref/rRNA</span><br><span class="line">hisat2-build -p 4 rRNA.fasta ./index_hisat2/rRNA</span><br></pre></td></tr></table></figure>
<p><strong>③、去除rRNAs</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#--un-conc:输出没有比对到rRNA上的reads</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;36,40,37&#125;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">nohup hisat2 -x /home/gongyuqi/ref/rRNA/index_hisat2/rRNA \</span><br><span class="line">       -1 SRR96461<span class="variable">$&#123;i&#125;</span>_1_val_1.fq \</span><br><span class="line">       -2 SRR96461<span class="variable">$&#123;i&#125;</span>_2_val_2.fq \</span><br><span class="line">       --un-conc ../rmr_rRNA/SRR96461<span class="variable">$&#123;i&#125;</span>_rmr_%.fq \</span><br><span class="line">       -p 16 -S ../rmr_rRNA/SRR96461<span class="variable">$&#123;i&#125;</span>.sam &amp;</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#去除rRNA后再次质控后发现GC含量更加异常了！！！</span></span><br><span class="line"><span class="comment">#另外，参考基因组的比对率也挺低的，50-70%之间。这批数据感觉质量不是很OK呀😢先分析下去看看~</span></span><br></pre></td></tr></table></figure>
<p><strong>④、HISAT2比对含有转录组信息的参考基因组</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#hisat2比对</span></span><br><span class="line">ls *_1.fq&gt; rmr_fq1.txt</span><br><span class="line">ls *_2.fq&gt; rmr_fq2.txt</span><br><span class="line">paste rmr_fq1.txt rmr_fq2.txt &gt; rmr_fq.txt</span><br><span class="line">ref=/home/gongyuqi/ref/hg38/index/hisat2_UCSC/hg38_tran/genome_tran</span><br><span class="line">cat rmr_fq.txt|<span class="keyword">while</span> <span class="built_in">read</span> id</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">arr=(<span class="variable">$&#123;id&#125;</span>)</span><br><span class="line">fq1=<span class="variable">$&#123;arr[0]&#125;</span></span><br><span class="line">fq2=<span class="variable">$&#123;arr[1]&#125;</span></span><br><span class="line">sample=<span class="variable">$&#123;fq1%%_*&#125;</span>.sort.bam</span><br><span class="line">nohup hisat2 -p 8 -x <span class="variable">$ref</span> -1 <span class="variable">$fq1</span> -2 <span class="variable">$fq2</span> | samtools sort -@ 8 -o ../align/<span class="variable">$sample</span> - &amp;</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">nohup hisat2 -p 8 -x <span class="variable">$ref</span> -1 SRR9646139_rmr_1.fq -2 SRR9646139_rmr_2.fq | samtools sort -@ 8 -o ../align/SRR9646139.sort.bam - &amp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#构建索引,bam文件导入IGV时需要索引文件同时存在</span></span><br><span class="line">ls *.bam | <span class="keyword">while</span> <span class="built_in">read</span> id; <span class="keyword">do</span> nohup samtools flagstat <span class="variable">$id</span> &amp; <span class="keyword">done</span></span><br><span class="line">ls *.bam | <span class="keyword">while</span> <span class="built_in">read</span> id; <span class="keyword">do</span> nohup samtools index <span class="variable">$id</span> &amp; <span class="keyword">done</span></span><br><span class="line">ls *.bam | <span class="keyword">while</span> <span class="built_in">read</span> id; <span class="keyword">do</span> nohup bamCoverage -b <span class="variable">$id</span> -o <span class="variable">$&#123;id%%_*&#125;</span>.bw &amp; <span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<h2 id="三-MACS2-call-peaks"><a href="#三-MACS2-call-peaks" class="headerlink" title="(三)MACS2 call peaks"></a>(三)MACS2 call peaks</h2><p>MACS2<a href="https://pypi.org/project/MACS2/">官网参考资料</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#call peaks: siControl_m6A_IgG_replicate1</span></span><br><span class="line">macs2 callpeak -t SRR9646136.sort.bam -c SRR9646137.sort.bam -f BAM -g hs -n siControl_m6A_IgG_replicate1 -B -q 0.01 --outdir siControl_m6A_IgG</span><br><span class="line"><span class="comment">#call peaks: siControl_m6A_IgG_replicate2</span></span><br><span class="line">macs2 callpeak -t SRR9646140.sort.bam -c SRR9646137.sort.bam -f BAM -g hs -n siControl_m6A_IgG_replicate2 -B -q 0.01 --outdir siControl_m6A_IgG</span><br><span class="line"></span><br><span class="line">macs2 callpeak -t SRR9646138.sort.bam -c SRR9646139.sort.bam -f BAM -g hs -n siFTO_m6A_IgG -B -q 0.01 --outdir ../peaks</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="四-peaks注释"><a href="#四-peaks注释" class="headerlink" title="(四)peaks注释"></a>(四)peaks注释</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(org.Hs.eg.db)</span><br><span class="line">library(ChIPseeker)</span><br><span class="line">library(TxDb.Hsapiens.UCSC.hg38.knownGene)</span><br><span class="line"></span><br><span class="line">txdb &lt;- TxDb.Hsapiens.UCSC.hg38.knownGene</span><br><span class="line">files &lt;- <span class="built_in">list</span>(replicate1=<span class="string">&quot;siControl_m6A_IgG_replicate1_summits.bed&quot;</span>,</span><br><span class="line">              replicate2=<span class="string">&quot;siControl_m6A_IgG_replicate2_summits.bed&quot;</span>)</span><br><span class="line"></span><br><span class="line">peakAnno_replicate1 &lt;- annotatePeak(files[[<span class="number">1</span>]], TxDb=txdb, annoDb=<span class="string">&quot;org.Hs.eg.db&quot;</span>)</span><br><span class="line">peakAnno_replicate2 &lt;- annotatePeak(files[[<span class="number">2</span>]], TxDb=txdb, annoDb=<span class="string">&quot;org.Hs.eg.db&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#大部分情况下会出现多了peaks对应到同一个SYMBOL上，所以一定要记得unique一下</span></span><br><span class="line"></span><br><span class="line">siFTO_siControl_peak&lt;-peakAnno_siFTO_siControl_m6A@anno@elementMetadata@listData</span><br><span class="line">siFTO_siControl_peak&lt;-as.data.frame(siFTO_siControl_peak)</span><br><span class="line"></span><br><span class="line">replicate1_peak&lt;-as.data.frame(peakAnno_replicate1@anno@elementMetadata@listData)</span><br><span class="line">replicate1_peak_SYMBOL&lt;-peakAnno_replicate1@anno@elementMetadata@listData$SYMBOL</span><br><span class="line">replicate1_peak_SYMBOL&lt;-unique(na.omit(replicate1_peak_SYMBOL))</span><br><span class="line"></span><br><span class="line">replicate2_peak&lt;-as.data.frame(peakAnno_replicate2@anno@elementMetadata@listData)</span><br><span class="line">replicate2_peak_SYMBOL&lt;-peakAnno_replicate2@anno@elementMetadata@listData$SYMBOL</span><br><span class="line">replicate2_peak_SYMBOL&lt;-unique(na.omit(replicate2_peak_SYMBOL))</span><br><span class="line"></span><br><span class="line">common_peaks&lt;-intersect(replicate1_peak_SYMBOL,replicate2_peak_SYMBOL)</span><br><span class="line">table(<span class="string">&quot;CCND1&quot;</span>%in%common_peaks)<span class="comment">#在此，结果为TRUE</span></span><br></pre></td></tr></table></figure>
<p><strong>将bam文件导入IGV,可视化CCND1上m6A的情况</strong><br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/IGV_CCND1.png"/></p>
]]></content>
      <tags>
        <tag>NGS</tag>
      </tags>
  </entry>
  <entry>
    <title>Mutect2</title>
    <url>/2021/05/27/Mutect2/</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="Mutect2最新使用教程"><a href="#Mutect2最新使用教程" class="headerlink" title="Mutect2最新使用教程"></a>Mutect2最新使用教程</h1><p><strong><a href="https://gatk.broadinstitute.org/hc/en-us/articles/360035889791?id=11136">Mutect2 v4.1.0.0的教程</a>目前已经被GATK官方弃用了。下面我们采用官方更新推荐的<a href="https://gatk.broadinstitute.org/hc/en-us/articles/360035531132">Mutect2 v4.1.1.0 and later版本的使用教程</a>。</strong></p>
<h2 id="一-Create-a-panel-of-normal"><a href="#一-Create-a-panel-of-normal" class="headerlink" title="(一) Create a panel of normal"></a>(一) Create a panel of normal</h2><h3 id="step-1-Run-Mutect2-in-tumor-only-mode-for-each-normal-sample"><a href="#step-1-Run-Mutect2-in-tumor-only-mode-for-each-normal-sample" class="headerlink" title="step 1: Run Mutect2 in tumor-only mode for each normal sample"></a>step 1: Run Mutect2 in tumor-only mode for each normal sample</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ref=/home/gongyuqi/ref/GATK/hg38/v0/Homo_sapiens_assembly38.fasta</span><br><span class="line">nohup gatk Mutect2 -R <span class="variable">$ref</span> -I SRR12135911_bqsr.bam --max-mnp-distance 0 -O ../Mutect2/PON/untreated.vcf.gz &amp;</span><br></pre></td></tr></table></figure>
<h3 id="step-2-Create-a-GenomicsDB-from-the-normal-Mutect2-calls"><a href="#step-2-Create-a-GenomicsDB-from-the-normal-Mutect2-calls" class="headerlink" title="step 2: Create a GenomicsDB from the normal Mutect2 calls"></a>step 2: Create a GenomicsDB from the normal Mutect2 calls</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">interval=/home/gongyuqi/ref/GATK/hg38/v0/HybSelOligos/hg38_v0_HybSelOligos_whole_exome_illumina_coding_v1_whole_exome_illumina_coding_v1.Homo_sapiens_assembly38.targets.interval_list</span><br><span class="line">nohup gatk --java-options <span class="string">&quot;-Xmx20G -Djava.io.tmpdir=./&quot;</span> \</span><br><span class="line">      GenomicsDBImport -R <span class="variable">$ref</span> \</span><br><span class="line">      -L <span class="variable">$interval</span> \</span><br><span class="line">      --genomicsdb-workspace-path pon_db \</span><br><span class="line">      -V untreated.vcf.gz &amp;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#option 1</span></span><br><span class="line">gatk --java-options <span class="string">&quot;-Xmx20G&quot;</span> \</span><br><span class="line">      GenomicsDBImport -R <span class="variable">$ref</span> \</span><br><span class="line">      -L <span class="variable">$interval</span> \</span><br><span class="line">      --genomicsdb-workspace-path pon_db \</span><br><span class="line">      -V untreated.vcf.gz &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment">#option 2</span></span><br><span class="line">gatk --java-options <span class="string">&quot;-Xmx20G -Djava.io.tmpdir=./&quot;</span> \</span><br><span class="line">      GenomicsDBImport -R <span class="variable">$ref</span> \</span><br><span class="line">      -L <span class="variable">$interval</span> \</span><br><span class="line">      --genomicsdb-workspace-path pon_db \</span><br><span class="line">      -V untreated.vcf.gz &amp;</span><br></pre></td></tr></table></figure>








<h3 id="必需文件准备"><a href="#必需文件准备" class="headerlink" title="必需文件准备"></a>必需文件准备</h3><p><a href="https://console.cloud.google.com/storage/browser/gcp-public-data--broad-references/hg38/v0/HybSelOligos">interval文件</a>：基因组间隔信息</p>
<p><a href="https://console.cloud.google.com/storage/browser/gatk-best-practices/somatic-hg38">af-only-gnomad.vcf文件</a>: a copy of the gnomAD VCF stripped of all unnecessary INFO fields.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gatk Mutect2 -R ref.fasta \</span><br><span class="line">        -L intervals.interval_list \</span><br><span class="line">        -I tumor.bam \</span><br><span class="line">        -germline-resource af-only-gnomad.vcf \</span><br><span class="line">        -pon panel_of_normals.vcf   \</span><br><span class="line">        --f1r2-tar-gz f1r2.tar.gz \</span><br><span class="line">        -O unfiltered.vcf</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>tag1</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL中事物的隔离级别</title>
    <url>/2020/03/03/MySQL-transaction-isolation/</url>
    <content><![CDATA[<p>····</p>
<a id="more"></a>

<h1 id="MySQL中事物的隔离级别"><a href="#MySQL中事物的隔离级别" class="headerlink" title="MySQL中事物的隔离级别"></a>MySQL中事物的隔离级别</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">事物的隔离界别</span><br><span class="line">					脏读		不可重复读		幻读</span><br><span class="line">read uncommited 	√			√				√</span><br><span class="line">read commited		×			√				√</span><br><span class="line">repeatable read		×			×				√</span><br><span class="line">serialization		×			×				×</span><br><span class="line"></span><br><span class="line">mysql中默认 repeatable read</span><br><span class="line">oracle中默认 read commited</span><br><span class="line"></span><br><span class="line">查看隔离级别：select @@tx_isolation;</span><br><span class="line">设置隔离级别：set session|global transaction isolation level 隔离级别;</span><br></pre></td></tr></table></figure>
<h2 id="read-uncommitted"><a href="#read-uncommitted" class="headerlink" title="read uncommitted"></a>read uncommitted</h2><p><strong>无隔离</strong><br>脏读（演示）、不可重复读（演示）、幻读（这里不演示）  </p>
<ul>
<li>终端1中显示当前隔离级别  </li>
<li>设置当前隔离级别为read committed  </li>
<li>在此查看当前隔离级别  </li>
<li>进入test数据库  </li>
<li>查看accout表信息  </li>
<li>开启事物  </li>
<li>在此事物中进行列的修改  </li>
<li>回退  </li>
</ul>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/read_uncommitted1.png"/>

<ul>
<li>终端2显示当前隔离级别</li>
<li>设置当前隔离级别为read committed</li>
<li>在此查看当前隔离级别</li>
<li>进入test数据库</li>
<li>查看account表信息（在终端1做出修改前）</li>
<li>查看account表信息（在终端1做出修改后）</li>
<li>查看account表信息（在终端1回退后）</li>
</ul>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/read_uncommited2.png"/>


<h2 id="read-committed"><a href="#read-committed" class="headerlink" title="read committed"></a>read committed</h2><p>不脏读（演示）、不可重复读（不演示）、幻读（这里不演示）  </p>
<ul>
<li>设置终端1类型read committed</li>
<li>开启事物</li>
<li>修改列</li>
<li>结束事务</li>
</ul>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/read_commited1.png"/>

<ul>
<li>设置终端2类型read committed   </li>
<li>开启事务  </li>
<li>查看account表信息（终端做修改后。但未结束事务，不脏读）  </li>
<li>查看account表信息（终端1做修改后，结束事务，终端2还处于同一事务中，此隔离级别下不可重复读）  </li>
<li>结束事务</li>
</ul>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/read_commited2.png"/>

<h2 id="repeatable-read"><a href="#repeatable-read" class="headerlink" title="repeatable read"></a>repeatable read</h2><p>不脏读（演示）、不可重复读（演示）、幻读（这里不演示）  </p>
<ul>
<li>设置终端1类型repeatable read</li>
<li>开启事物</li>
<li>修改列</li>
<li>结束事务</li>
</ul>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/repeatable_read1.png"/>

<ul>
<li>设置终端2类型repeatable read</li>
<li>开启事务</li>
<li>查看account表信息（终端1做修改后，未结束事务）</li>
<li>查看account表信息（终端1做修改后，结束事务，终端2未结束事务，此隔离级别下可重复读）</li>
<li>结束事务</li>
</ul>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/repeatable_read2.png"/>

<ul>
<li>终端1开启事务</li>
<li>查看account表信息</li>
<li>插入一行信息</li>
<li>查看account表信息</li>
<li>结束事务</li>
</ul>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/repeatable_read_illusion1.png"/>

<ul>
<li>终端2开启事务  </li>
<li>查看account表信息（终端1做出修改后）  </li>
<li>修改表中的列信息（终端1做出修改，但未结束事务，时间长了终端2会出现来纳瑟方框报错）  </li>
<li>在此尝试修改表中列信息（终端1做出修改并结束事务，出现红色下划线提示，4个改变，但在终端2事务中最初只有3行信息，此处却出现4行，说明出现幻读）</li>
</ul>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/repeatable_read_illusion2.png"/>


<h2 id="serialization"><a href="#serialization" class="headerlink" title="serialization"></a>serialization</h2><p>不脏读、可重复度、不幻读</p>
<ul>
<li>设置终端1类型serialization</li>
<li>查看当前隔离级别</li>
<li>开启事务</li>
<li>查看account表信息</li>
<li>修改表的列信息（此处并未提交执行此语句）</li>
</ul>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/serializable1.png"/>

<ul>
<li>设置终端1类型serialization</li>
<li>开启事务</li>
<li>修改表的列信息（终端1的表修改操作在终端2前，此时终端2列修改无法操作，红色方框未报错信息，等待时间过长，只有端事务1事务结束才能进行此操作）</li>
</ul>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/serializable2.png"/>
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL简单介绍</title>
    <url>/2020/02/25/MySQL%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>MySQL的下载安装<br>简单命令介绍<br>SQLyog的下载安装</p>
<a id="more"></a>

<h1 id="MySQL简单介绍"><a href="#MySQL简单介绍" class="headerlink" title="MySQL简单介绍"></a>MySQL简单介绍</h1><h3 id="MySQL下载安装"><a href="#MySQL下载安装" class="headerlink" title="MySQL下载安装"></a>MySQL下载安装</h3><p><a href="https://baijiahao.baidu.com/s?id=1629661608981614271&wfr=spider&for=pc">下载安装教程</a><br>Choose Setup Type一栏，我选择的是<strong>Custom</strong><br>安装路径自定义到了非系统盘</p>
<h3 id="MySQL服务的启动和停止"><a href="#MySQL服务的启动和停止" class="headerlink" title="MySQL服务的启动和停止"></a>MySQL服务的启动和停止</h3><ul>
<li><p>方式一：计算机—右击管理—服务  </p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/MySQL服务.png"/>
右击MySQL会显示启动、停止等选项

</li>
<li><p>方式二：通过管理员身份运行cmd  </p>
<pre><code>  net restart 服务名称（启动服务）  
  net stop 服务名称（停止服务）
</code></pre>
</li>
</ul>
<h3 id="MySQL服务的登陆和退出"><a href="#MySQL服务的登陆和退出" class="headerlink" title="MySQL服务的登陆和退出"></a>MySQL服务的登陆和退出</h3><ul>
<li><p>方式一：通过MySQL自带的客户端，只限于root用户</p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/MySQL_Command_Line.png"/>
</li>
<li><p>方式二：通过windows自带的客户端（cmd）<br>mysql [-h 主机名 -P 端口号] -u 用户名 -p密码<br>如果是本机的话，<code>[]</code>中的内容可以省去  </p>
</li>
</ul>
<p>退出：exit或者ctrl+C<br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/MySQL_cmd_login.png"/></p>
<h3 id="MySQL配置环境变量"><a href="#MySQL配置环境变量" class="headerlink" title="MySQL配置环境变量"></a>MySQL配置环境变量</h3><p>my.ini文件为MySQL的配置文件</p>
<h3 id="MySQL常见命令介绍"><a href="#MySQL常见命令介绍" class="headerlink" title="MySQL常见命令介绍"></a>MySQL常见命令介绍</h3><ul>
<li>显示数据库信息</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> databases;</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/show_databases.JPG"/>


<p>information_schema：保存源数据细信息。<br>mysql：保存用户信息。<br>performance_schema：搜集性能信息，性能参数。<br>test：测试数据哭，为空。可以在次建表，修改库，删除库。  </p>
<ul>
<li>进入数据库mysql</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">use mysql;</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/use_mysql.JPG"/>


<ul>
<li>查看数据库中的表信息</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> tables;</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/show_tables.JPG"/>


<ul>
<li>查看当前属于哪个数据库</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> database();</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/select_database().JPG"/>


<ul>
<li>在数据库中新建一张表（test数据库）</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">use test;</span><br><span class="line"><span class="keyword">select</span> database()；</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/use_test.JPG"/>


<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">creat <span class="keyword">table</span> friends(</span><br><span class="line">    id <span class="type">int</span>,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">20</span>));</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/creat_friends.JPG"/>


<ul>
<li>查看当前数据库中的表</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> tables();</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/show_table_friends1.JPG"/>


<ul>
<li>查看friends表的结构</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">desc</span> friends;</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/desc_friends.JPG"/>


<ul>
<li>查看friends表的信息</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> friends</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/select_friends1.JPG"/>


<ul>
<li>为friends表添加数据信息</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> friends(id,name) <span class="keyword">values</span>(<span class="number">1</span>,&quot;susu&quot;);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> friends(id,name) <span class="keyword">values</span>(<span class="number">2</span>,&quot;zhengrong&quot;);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> friends(id,name) <span class="keyword">values</span>(<span class="number">3</span>,&quot;yinyu&quot;);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> friends(id,name) <span class="keyword">values</span>(<span class="number">4</span>,&quot;jiaru&quot;);</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/insert_friends.JPG"/>


<ul>
<li>查看friends表中的信息</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> friends;</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/select-friends2.JPG"/>


<ul>
<li>修改friends表中的信息</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">update friends <span class="keyword">set</span> name<span class="operator">=</span>&quot;SUSU&quot; <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> friends</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/updatesusu.JPG"/>

<ul>
<li>删除friends表中某项信息</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> friends <span class="keyword">where</span> id<span class="operator">=</span><span class="number">4</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> friends</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/deletejiaru.JPG"/>


<h3 id="查看MySQL服务端版本"><a href="#查看MySQL服务端版本" class="headerlink" title="查看MySQL服务端版本"></a>查看MySQL服务端版本</h3><ul>
<li>方法一： mysql里面查询</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> version();</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/select_version().JPG"/>


<ul>
<li>方法二： cmd里面查询</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql <span class="comment">--version</span></span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/mysql__version.JPG"/>


<h3 id="MySQL的语法规范"><a href="#MySQL的语法规范" class="headerlink" title="MySQL的语法规范"></a>MySQL的语法规范</h3><ol>
<li>不区分大小写</li>
<li>每条命令最好用分号结尾</li>
<li>每条命令根据需要，可以进行换行或缩进</li>
<li>注释<pre><code> 单行注释：#注释文字
 单行注释：-- 注释文字
 多行注释：/*注释文字*/
</code></pre>
</li>
</ol>
<h2 id="SQLyog的下载安装"><a href="#SQLyog的下载安装" class="headerlink" title="SQLyog的下载安装"></a>SQLyog的下载安装</h2><p><a href="https://www.cnblogs.com/chunguang-yao/p/10666429.html">SQLyog下载安装教程</a><br><font color=red>注意</font>：在进行连接的时候一定要保证MySQL服务是开启的。如果经常用到可以改成<strong>自动开启模式</strong>，如果不常用可以改成<strong>手动开启模式</strong>，手动开启模式下就要注意用之前要保证服务是开启的。</p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/SQLyogintroduction.png"/>

<ul>
<li>1——以root用户的方式进行登陆</li>
<li>2——SQL语句框，在此可以输入语句，自动将输入的语句规范化</li>
<li>3——执行完语句后会在此处收到相应的消息</li>
<li>4——当前处于mysql数据库，1中加粗字体<strong>mysql</strong>也表明当前处于mysql数据库，2中最后一条执行语句为<code>USE mysql;</code></li>
</ul>
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>NGS数据分析之表观</title>
    <url>/2020/05/14/NGS%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8B%E8%A1%A8%E8%A7%82/</url>
    <content><![CDATA[<p> NGS数据分析之表观中的一些注意事项</p>
<a id="more"></a>

<h2 id="一、参考基因组及注释文件的准备"><a href="#一、参考基因组及注释文件的准备" class="headerlink" title="一、参考基因组及注释文件的准备"></a>一、参考基因组及注释文件的准备</h2><p>以果蝇为例</p>
<p>(1)下载果蝇参考基因组</p>
<p>打开谷歌(<strong>用谷歌用谷歌</strong>)，输入：drosophila_melanogaster ftp ensembl</p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/1-果蝇基因组.JPG"/>

<p>点击红色箭头所指方向进入正确的下载网页（这个需要自己悟，总是要多试的）</p>
<p>①<br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/2-果蝇基因组.JPG"/></p>
<p>②<br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/3-果蝇基因组.JPG"/></p>
<p>(2)下载参考基因组索引</p>
<p>打开谷歌，输入：drosophila_melanogaster ftp hisat2</p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/4-果蝇基因组索引.JPG"/>

<p>点击红色箭头所指方向进入正确的下载网页（这个需要自己悟，总是要多试的）</p>
<p>①<br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/5-果蝇基因组索引.JPG"/></p>
<p>②<br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/6-果蝇基因组索引.JPG"/></p>
<p><font color=blue><strong>总结</strong>：参考基因组下载方式很多，版本也不唯一，重要的是知道自己需要那个版本，这一点需要悟……就参考基因组索引而言，不同比对软件需要的索引文件不一样，可以自己构建，也可以网页下载，推荐按直接下载。</font></p>
]]></content>
      <tags>
        <tag>NGS</tag>
      </tags>
  </entry>
  <entry>
    <title>RNA-seq数据分析流程</title>
    <url>/2020/02/23/RNA-seq%20analysis/</url>
    <content><![CDATA[<p>普通RNA-seq数据分析</p>
<a id="more"></a>

<h1 id="RNA-seq数据分析流程"><a href="#RNA-seq数据分析流程" class="headerlink" title="RNA-seq数据分析流程"></a>RNA-seq数据分析流程</h1><h2 id="（一）原始数据的质控"><a href="#（一）原始数据的质控" class="headerlink" title="（一）原始数据的质控"></a>（一）原始数据的质控</h2><p>以其中一个样本为例（其他样本指控结果基本类似）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/raw-data</span><br><span class="line"><span class="comment">#对每个样本进行质控</span></span><br><span class="line">fastqc -t 7 /root/project/atac/raw/*gz -o ./</span><br><span class="line"><span class="comment">#统计合并所有指控结果</span></span><br><span class="line">multiqc *fastqc.zip --ignore *.html</span><br></pre></td></tr></table></figure>
<img src="https://gyq-images.oss-cn-hangzhou.aliyuncs.com/img/1qc.png"/>

<img src="https://gyq-images.oss-cn-hangzhou.aliyuncs.com/img/2qc.png"/>

<img src="https://gyq-images.oss-cn-hangzhou.aliyuncs.com/img/3qc.png"/>

<img src="https://gyq-images.oss-cn-hangzhou.aliyuncs.com/img/4qc.png"/>

<img src="https://gyq-images.oss-cn-hangzhou.aliyuncs.com/img/5qc.png"/>


<ul>
<li>1、帮忙分析的数据，从公司给的结果的样本名中包含“clean”，我猜想公司大概已经进行过一次过滤，而且也完全没有接头。</li>
<li>2、另外，没有过关的这些数据也很难通过过滤得到改善（因为我使用trim_galore过滤，质控结果更差了）</li>
<li><strong>3、但是我还是不死心呀，我分别取了一个原始的和自己过滤的样本的前10000条reads,进行比对。结果发现原始的比对率可以达到95%+，自己过滤后的样本比对率比较低。</strong></li>
<li>4、所以，这批数据，公司应该已经进行过滤操作了。</li>
</ul>
<h2 id="（二）比对"><a href="#（二）比对" class="headerlink" title="（二）比对"></a>（二）比对</h2><p><strong>比对软件：hisat2</strong></p>
<p><font color=blue>不同数据类型所需要使用的比对软件也是有讲究的呢，可千万不能乱使用，会出问题的，刚开始接触数据分析时，知道有很多比对软件，但一直用bowtie2进行比对，后面就翻车啦～～～～～～</font></p>
<p>比对软件的选择：<br><a href="https://www.jianshu.com/p/849f8ada0ab7">https://www.jianshu.com/p/849f8ada0ab7</a><br><a href="https://www.jianshu.com/p/681e02e7f9af">https://www.jianshu.com/p/681e02e7f9af</a><br><a href="https://zhuanlan.zhihu.com/p/26506787">https://zhuanlan.zhihu.com/p/26506787</a> </p>
<p><font color=blue>NGS—-bwa<br>Chip（也包括ATAC）—-bowtie2<br>RNA—-hisat2（推荐）、star、Tophat、subjunc</font></p>
<h3 id="第一步：序列比对"><a href="#第一步：序列比对" class="headerlink" title="第一步：序列比对"></a>第一步：序列比对</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#cat sample</span></span><br><span class="line">KO1455_FRAS190065880-1a_1.clean.fq.gz	KO1455_FRAS190065880-1a_2.clean.fq.gz</span><br><span class="line">KO1462_FRAS190065881-1a_1.clean.fq.gz	KO1462_FRAS190065881-1a_2.clean.fq.gz</span><br><span class="line">KO1471_FRAS190065882-1a_1.clean.fq.gz	KO1471_FRAS190065882-1a_2.clean.fq.gz</span><br><span class="line">WT1441_FRAS190065878-1a_1.clean.fq.gz	WT1441_FRAS190065878-1a_2.clean.fq.gz</span><br><span class="line">WT1465_FRAS190065879-1a_1.clean.fq.gz	WT1465_FRAS190065879-1a_2.clean.fq.gz</span><br><span class="line">WT1474_FRAS190065877-1a_1.clean.fq.gz	WT1474_FRAS190065877-1a_2.clean.fq.gz</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#因为不想让本机太辛苦，要让它歇息一会儿,所以将KO和WT分批次跑</span></span><br><span class="line">cat sample | head -n 3 &gt; KO_sample</span><br><span class="line">cat sample | tail -n 3 &gt; WT_sample</span><br><span class="line">ref=/home/reference/mm10/genome</span><br><span class="line"></span><br><span class="line">cat KO_sample|<span class="keyword">while</span> <span class="built_in">read</span> id</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">arr=(<span class="variable">$&#123;id&#125;</span>)</span><br><span class="line">fq1=<span class="variable">$&#123;arr[0]&#125;</span></span><br><span class="line">fq2=<span class="variable">$&#123;arr[1]&#125;</span></span><br><span class="line">sample=<span class="variable">$&#123;fq1%%_*&#125;</span>.sort.bam</span><br><span class="line">hisat2 -p 7 -x <span class="variable">$ref</span> -1 <span class="variable">$fq1</span> -2 <span class="variable">$fq2</span> | samtools sort -@ 7 -o /home/align/<span class="variable">$sample</span> -</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">cat WT_sample|<span class="keyword">while</span> <span class="built_in">read</span> id</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">arr=(<span class="variable">$&#123;id&#125;</span>)</span><br><span class="line">fq1=<span class="variable">$&#123;arr[0]&#125;</span></span><br><span class="line">fq2=<span class="variable">$&#123;arr[1]&#125;</span></span><br><span class="line">sample=<span class="variable">$&#123;fq1%%_*&#125;</span>.sort.bam</span><br><span class="line">hisat2 -p 7 -x <span class="variable">$ref</span> -1 <span class="variable">$fq1</span> -2 <span class="variable">$fq2</span> | samtools sort -@ 7 -o /home/align/<span class="variable">$sample</span> -</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#各样本比对率都在95%以上，这样的比对结果才可以比较有信心的进行后续分析了。</span></span><br></pre></td></tr></table></figure>
<h3 id="第二步：构建索引"><a href="#第二步：构建索引" class="headerlink" title="第二步：构建索引"></a>第二步：构建索引</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls *.bam|xargs -i samtools index &#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第三部：生成状态文件-统计比对情况"><a href="#第三部：生成状态文件-统计比对情况" class="headerlink" title="第三部：生成状态文件(统计比对情况)"></a>第三部：生成状态文件(统计比对情况)</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls *.bam|xargs -i samtools flagstat -@ 7 &#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="（三）制作表达矩阵"><a href="#（三）制作表达矩阵" class="headerlink" title="（三）制作表达矩阵"></a>（三）制作表达矩阵</h2><p>参考资料：<a href="https://www.bioinfo-scrounger.com/archives/407/">https://www.bioinfo-scrounger.com/archives/407/</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ref=/home/reference/gtf/gencode.v33.annotation.gtf  </span><br><span class="line">featureCounts -T 8 -p -t exon -g gene_id -a <span class="variable">$gtf</span> -o RNA-matrix.txt *.bam 1&gt;counts.id.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure>
<p>查看featureCounts的情况</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat counts.id.log</span><br></pre></td></tr></table></figure>

<p>在此，要记录一个错误。第一次操作时误使用了人类的gtf文件，结果日志文件显示比对率在10%左右……使用小鼠gtf文件后，比对结果正常多了（因为这批数据是小鼠组织细胞测序的结果）。如下所示。<br><img src="https://gyq-images.oss-cn-hangzhou.aliyuncs.com/img/featureCounts.png"/></p>
<h1 id="（四）差异分析"><a href="#（四）差异分析" class="headerlink" title="（四）差异分析"></a>（四）差异分析</h1><h3 id="第一步：将reads矩阵导入R中"><a href="#第一步：将reads矩阵导入R中" class="headerlink" title="第一步：将reads矩阵导入R中"></a>第一步：将reads矩阵导入R中</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">rm(<span class="built_in">list</span> = ls())</span><br><span class="line">options(stringsAsFactors = <span class="built_in">F</span>)</span><br><span class="line">setwd(<span class="string">&quot;G:\\seq-analysis-data\\RNA-seq&quot;</span>)</span><br><span class="line">a=read.table(<span class="string">&#x27;RNA-matrix.txt&#x27;</span>,header = <span class="built_in">T</span>)</span><br><span class="line">ckeck_a=a[<span class="number">1</span>:<span class="number">4</span>,<span class="number">1</span>:<span class="number">12</span>]</span><br></pre></td></tr></table></figure>
<h3 id="第二步：获取正确的Geneid"><a href="#第二步：获取正确的Geneid" class="headerlink" title="第二步：获取正确的Geneid"></a>第二步：获取正确的Geneid</h3><ul>
<li>首先看看矩阵中的Geneid长什么样</li>
</ul>
<img width="20%" height="20%" src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/raw_geneid.JPG"/>


<ul>
<li>所以要去掉小数点及后面的数字，获取正确的Geneid<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(stringr)</span><br><span class="line"><span class="built_in">class</span>(str_split(a$Geneid,<span class="string">&#x27;[.]&#x27;</span>,simplify = <span class="built_in">T</span>))</span><br><span class="line">a$ensembl_id=str_split(a$Geneid,<span class="string">&#x27;[.]&#x27;</span>,simplify = <span class="built_in">T</span>)[,<span class="number">1</span>]</span><br><span class="line">rownames(a)&lt;-a$ensembl_id</span><br><span class="line">check_a_again=a[<span class="number">1</span>:<span class="number">4</span>,<span class="number">1</span>:<span class="number">12</span>]</span><br><span class="line">exprSet&lt;-a[,<span class="number">7</span>:<span class="number">12</span>]</span><br><span class="line">ckeck_exprSet&lt;-head(exprSet)</span><br></pre></td></tr></table></figure>
表达矩阵现在的样子（Geneid名去掉了多余的部分）</li>
</ul>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/raw_exprSet.JPG"/>


<h2 id="第三步：id转换"><a href="#第三步：id转换" class="headerlink" title="第三步：id转换"></a>第三步：id转换</h2><p>Geneid和symbol并不是完全一一对应的，存在部分多个Geneid对应同一个基因名的情况。</p>
<p>因为rownames必须唯一，所以就要去掉重复的Geneid或者只保留其中一个（这个保留就比较的人为了~）</p>
<ul>
<li><p>方法一：使用biomaRt包</p>
<p>此方法几乎可以转换全部的id(<font color=orange>推荐</font>)</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(biomaRt)</span><br><span class="line">library(curl)</span><br><span class="line"><span class="comment">#此步骤需要网速，网速不好会报错（curl相关的），多试几遍，会有好运气的</span></span><br><span class="line">mart &lt;- useDataset(<span class="string">&quot;mmusculus_gene_ensembl&quot;</span>, useMart(<span class="string">&quot;ensembl&quot;</span>))<span class="comment">##人类选择hsapiens_gene_ensembl</span></span><br><span class="line">gene&lt;-row.names(exprSet)<span class="comment">#要转换成SYMBOL的Geneid</span></span><br><span class="line">gene_name&lt;-getBM(<span class="built_in">attributes</span>=<span class="built_in">c</span>(<span class="string">&quot;description&quot;</span>,<span class="string">&quot;external_gene_name&quot;</span>,<span class="string">&quot;ensembl_gene_id&quot;</span>),</span><br><span class="line">                 filters = <span class="string">&quot;ensembl_gene_id&quot;</span>,</span><br><span class="line">                 values = gene, mart = mart)</span><br><span class="line">head(gene_name)</span><br><span class="line">exprSet&lt;-a[,<span class="number">7</span>:<span class="number">12</span>]</span><br><span class="line">head(exprSet)</span><br><span class="line">table(rownames(exprSet)%in%gene_name$ensembl_gene_id)</span><br><span class="line"><span class="built_in">dim</span>(exprSet)</span><br><span class="line">exprSet&lt;-exprSet[rownames(exprSet)%in%gene_name$ensembl_gene_id,]</span><br><span class="line"><span class="built_in">dim</span>(exprSet)</span><br><span class="line">symbol&lt;-gene_name[match(rownames(exprSet),gene_name$ensembl_gene_id),]</span><br><span class="line">head(symbol)</span><br><span class="line">exprSet[<span class="number">1</span>:<span class="number">6</span>,<span class="number">1</span>:<span class="number">6</span>]</span><br><span class="line">tmp&lt;-by(exprSet,symbol$external_gene_name,<span class="keyword">function</span>(x)rownames(x)[which.max(rowMeans(x))])</span><br><span class="line">probes&lt;-<span class="built_in">as.character</span>(tmp)</span><br><span class="line"><span class="built_in">dim</span>(exprSet)</span><br><span class="line">exprSet&lt;-exprSet[rownames(exprSet)%in%probes,]</span><br><span class="line"><span class="built_in">dim</span>(exprSet)</span><br><span class="line">rownames(exprSet)&lt;-symbol[match(rownames(exprSet),symbol$ensembl_gene_id),<span class="number">2</span>]</span><br><span class="line">exprSet[<span class="number">1</span>:<span class="number">5</span>,<span class="number">1</span>:<span class="number">5</span>]</span><br><span class="line">write.csv(exprSet,<span class="string">&#x27;raw_exprSet.csv&#x27;</span>)</span><br><span class="line"><span class="comment">#exprSet&lt;-read.csv(&#x27;raw_exprSet.csv&#x27;)</span></span><br><span class="line"><span class="comment">#rownames(exprSet)&lt;-exprSet$X</span></span><br><span class="line"><span class="comment">#exprSet&lt;-exprSet[,-1]</span></span><br></pre></td></tr></table></figure></li>
<li><p>方法二：使用org.Mm.eg.db包<br>可能因为此包不怎么更新，id转换率只有50%左右，这样回丢掉很多信息的，可能会导致后续分析不可靠（不推荐）</p>
</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(clusterProfiler)</span><br><span class="line">library(org.Mm.eg.db)</span><br><span class="line">symbol&lt;-bitr(rownames(exprSet),fromType = <span class="string">&quot;ENSEMBL&quot;</span>,</span><br><span class="line">             toType=<span class="built_in">c</span>(<span class="string">&quot;SYMBOL&quot;</span>,<span class="string">&quot;ENTREZID&quot;</span>),OrgDb = org.Mm.eg.db)</span><br><span class="line">colnames(symbol)&lt;-<span class="built_in">c</span>(<span class="string">&quot;ensembl_id&quot;</span>,<span class="string">&quot;SYMBOL&quot;</span>,<span class="string">&quot;ENTREZID&quot;</span>)</span><br><span class="line">check_symbol&lt;-symbol[<span class="number">1</span>:<span class="number">10</span>,<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">table(rownames(exprSet)%in%symbol$ensembl_id)</span><br><span class="line"><span class="built_in">dim</span>(exprSet)</span><br><span class="line">exprSet&lt;-exprSet[rownames(exprSet)%in%symbol$ensembl_id,]</span><br><span class="line"><span class="built_in">dim</span>(exprSet)</span><br><span class="line">symbol&lt;-symbol[match(rownames(exprSet),symbol$ensembl_id),]</span><br><span class="line">head(symbol)</span><br><span class="line">exprSet[<span class="number">1</span>:<span class="number">6</span>,<span class="number">1</span>:<span class="number">6</span>]</span><br><span class="line">tmp&lt;-by(exprSet,symbol$SYMBOL,<span class="keyword">function</span>(x)rownames(x)[which.max(rowMeans(x))])</span><br><span class="line">probes&lt;-<span class="built_in">as.character</span>(tmp)</span><br><span class="line"><span class="built_in">dim</span>(exprSet)</span><br><span class="line">exprSet&lt;-exprSet[rownames(exprSet)%in%probes,]</span><br><span class="line"><span class="built_in">dim</span>(exprSet)</span><br><span class="line">rownames(exprSet)&lt;-symbol[match(rownames(exprSet),symbol$ensembl_id),<span class="number">2</span>]</span><br><span class="line">exprSet[<span class="number">1</span>:<span class="number">5</span>,<span class="number">1</span>:<span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<p><a href="https://www.jianshu.com/p/3a0e1e3e41d0">https://www.jianshu.com/p/3a0e1e3e41d0</a></p>
<p><a href="https://www.jianshu.com/p/c06fea33b60f">https://www.jianshu.com/p/c06fea33b60f</a></p>
<ul>
<li>在进行后续分析之前，检验目的基因的敲除效果<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Ang表达量探索</span></span><br><span class="line">Ang&lt;-raw_exprSet[rownames(raw_exprSet)==<span class="string">&quot;Ang&quot;</span>,]</span><br><span class="line">colnames(Ang)&lt;-<span class="built_in">c</span>(<span class="string">&quot;KO1455&quot;</span>,<span class="string">&quot;KO1462&quot;</span>,<span class="string">&quot;KO1471&quot;</span>,<span class="string">&quot;WT1441&quot;</span>,<span class="string">&quot;WT1465&quot;</span>,<span class="string">&quot;WT1474&quot;</span>)</span><br><span class="line">ang&lt;-as.data.frame(t(Ang))</span><br><span class="line">ang$Group&lt;-<span class="built_in">c</span>(<span class="built_in">rep</span>(<span class="string">&quot;KO&quot;</span>,<span class="number">3</span>),<span class="built_in">rep</span>(<span class="string">&quot;WT&quot;</span>,<span class="number">3</span>))</span><br><span class="line">ang$Sample&lt;-rownames(ang)</span><br><span class="line">colnames(ang)&lt;-<span class="built_in">c</span>(<span class="string">&quot;Counts&quot;</span>,<span class="string">&quot;Group&quot;</span>,<span class="string">&quot;Sample&quot;</span>)</span><br><span class="line">library(ggplot2)</span><br><span class="line">p&lt;-ggplot(ang,aes(Sample,Counts,group=Group))+</span><br><span class="line">  geom_bar(aes(fill=Group),stat=<span class="string">&#x27;identity&#x27;</span>)+</span><br><span class="line">  scale_fill_manual(values = <span class="built_in">c</span>(<span class="string">&quot;#FFA500&quot;</span>,<span class="string">&quot;#228B22&quot;</span>))+</span><br><span class="line">  ylab(<span class="string">&quot;The expression of Ang&quot;</span>)+</span><br><span class="line">  xlab(<span class="string">&quot;&quot;</span>)</span><br><span class="line">p+theme_bw()+theme(panel.border = element_blank(),panel.grid.major = element_blank(),panel.grid.minor = element_blank(),axis.line = element_line(colour = <span class="string">&quot;black&quot;</span>))</span><br></pre></td></tr></table></figure>
由图可看出：目的基因敲除效果显著；另外，也可以一定程度上反应上游数据分析的可靠性（因为在做测序之前，一定是先实验验证过敲低效率的）。</li>
</ul>
<img width="50%" height="50%" src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/ggplot2_ang_counts.jpeg"/>


<p><a href="https://zhuanlan.zhihu.com/p/92473504">https://zhuanlan.zhihu.com/p/92473504</a></p>
<p><a href="https://www.sohu.com/a/319083452_785442">https://www.sohu.com/a/319083452_785442</a></p>
<h2 id="第四步：DESeq2进行差异分析"><a href="#第四步：DESeq2进行差异分析" class="headerlink" title="第四步：DESeq2进行差异分析"></a>第四步：DESeq2进行差异分析</h2><p>1、DESeq2差异分析的主要步骤</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(DESeq2)</span><br><span class="line"><span class="comment">#DEseq2要求输入数据是由整数组成的矩阵。</span></span><br><span class="line"><span class="comment">#DESeq2要求矩阵是没有标准化的。</span></span><br><span class="line"><span class="comment">##构建一个dds对象</span></span><br><span class="line">exprSet_integer=<span class="built_in">round</span>(exprSet)  </span><br><span class="line">(colData &lt;- data.frame(row.names=colnames(exprSet_integer), </span><br><span class="line">                       group_list=group_list) )</span><br><span class="line">dds &lt;- DESeqDataSetFromMatrix(countData = exprSet_integer,</span><br><span class="line">                              colData = colData,</span><br><span class="line">                              design = ~ group_list)</span><br><span class="line">dds2 &lt;- DESeq(dds)<span class="comment">##使用DESeq函数对dds进行normalize</span></span><br><span class="line">resultsNames(dds2)<span class="comment">##查看结果的名称 </span></span><br><span class="line"></span><br><span class="line">res &lt;- results(dds2, contrast=<span class="built_in">c</span>(<span class="string">&quot;group_list&quot;</span>,<span class="string">&quot;KO&quot;</span>,<span class="string">&quot;WT&quot;</span>))</span><br><span class="line"><span class="comment">##提取想要的差异分析结果，这里是&quot;KO&quot;组对&quot;WT&quot;组进行比较。</span></span><br><span class="line">resOrdered &lt;- res[order(res$padj),]<span class="comment">##按padj从小到大排序</span></span><br><span class="line">summary(res)</span><br><span class="line">DEG&lt;-data.frame(resOrdered)<span class="comment">##得到差异分析的data.frame</span></span><br><span class="line">head(DEG)</span><br><span class="line">DEG = na.omit(DEG)</span><br><span class="line">write.csv(DEG,<span class="string">&#x27;DESeq2_KO_VS_WT DEG.csv&#x27;</span>)</span><br><span class="line"><span class="comment">#DEG&lt;-read.csv(&quot;DESeq2_KO_VS_WT DEG.csv&quot;)</span></span><br><span class="line"><span class="comment">#rownames(DEG)&lt;-DEG$X</span></span><br><span class="line"><span class="comment">#DEG&lt;-DEG[,-1]</span></span><br></pre></td></tr></table></figure>
<p>2、DESeq2标准化前后的对比</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#数据离散度非常大的RNA-seq的基因的reads的counts矩阵经过normalization后</span></span><br><span class="line"><span class="comment">#变成了类似于芯片表达矩阵的表达矩阵。生成的2行2列的图可以看出normalization前后的变化</span></span><br><span class="line">rld&lt;-rlogTransformation(dds2)<span class="comment">##得到经过DESeq2软件normalization的表达矩阵。</span></span><br><span class="line">exprSet_normalized&lt;-assay(rld)</span><br><span class="line">par(cex = <span class="number">0.7</span>)</span><br><span class="line">n.sample=ncol(exprSet)</span><br><span class="line"><span class="keyword">if</span>(n.sample&gt;<span class="number">40</span>) par(cex = <span class="number">0.5</span>)</span><br><span class="line">cols &lt;- rainbow(n.sample*<span class="number">1.2</span>)</span><br><span class="line">par(mfrow=<span class="built_in">c</span>(<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line">colnames(exprSet_integer)&lt;-<span class="built_in">c</span>(<span class="string">&quot;KO1455&quot;</span>,<span class="string">&quot;KO1462&quot;</span>,<span class="string">&quot;KO1471&quot;</span>,<span class="string">&quot;WT1441&quot;</span>,<span class="string">&quot;WT1465&quot;</span>,<span class="string">&quot;WT1474&quot;</span>)</span><br><span class="line">colnames(exprSet_normalized)&lt;-<span class="built_in">c</span>(<span class="string">&quot;KO1455&quot;</span>,<span class="string">&quot;KO1462&quot;</span>,<span class="string">&quot;KO1471&quot;</span>,<span class="string">&quot;WT1441&quot;</span>,<span class="string">&quot;WT1465&quot;</span>,<span class="string">&quot;WT1474&quot;</span>)</span><br><span class="line">boxplot(exprSet_integer, col = cols,main=<span class="string">&quot;expression value&quot;</span>,las=<span class="number">2</span>)</span><br><span class="line">boxplot(exprSet_normalized, col = cols,main=<span class="string">&quot;expression value&quot;</span>,las=<span class="number">2</span>)</span><br><span class="line">hist(as.matrix(exprSet))</span><br><span class="line">hist(exprSet_normalized)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/normalization.jpeg"/>

<p><a href="https://zhuanlan.zhihu.com/p/30350531">https://zhuanlan.zhihu.com/p/30350531</a></p>
<h2 id="第五步：可视化-……"><a href="#第五步：可视化-……" class="headerlink" title="第五步：可视化 ……"></a>第五步：可视化 ……</h2><ul>
<li>富集分析（可以使用KEGG、GO，这里使用GO）<br>大致看一下受目的基因影响的信号通路<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1、差异基因的提取</span></span><br><span class="line">topT &lt;- as.data.frame(DEG)</span><br><span class="line">logFC_Cutoff&lt;-with(topT,mean(<span class="built_in">abs</span>(log2FoldChange))+<span class="number">2</span>*sd(<span class="built_in">abs</span>(log2FoldChange)))</span><br><span class="line">logFC_cutoff&lt;-logFC_Cutoff</span><br><span class="line">select_gene=(<span class="built_in">abs</span>(DEG$log2FoldChange)&gt;=logFC_cutoff)&amp;(DEG$pvalue&lt;<span class="number">0.05</span>)</span><br><span class="line">select_gene.sig=DEG[select_gene,]</span><br><span class="line">write.csv(select_gene.sig,<span class="string">&#x27;DESeq2_select_gene.sig.csv&#x27;</span>)</span><br><span class="line">gene=rownames(select_gene.sig)</span><br><span class="line"><span class="comment">#2、差异基因的通路富集</span></span><br><span class="line">library(clusterProfiler)</span><br><span class="line">library(topGO)</span><br><span class="line">library(Rgraphviz)</span><br><span class="line">library(pathview)</span><br><span class="line">library(org.Mm.eg.db)</span><br><span class="line">DEG.entrez_id = mapIds(x = org.Mm.eg.db,</span><br><span class="line">                       keys = gene,</span><br><span class="line">                       keytype = <span class="string">&quot;SYMBOL&quot;</span>,</span><br><span class="line">                       column = <span class="string">&quot;ENTREZID&quot;</span>)</span><br><span class="line">DEG.entrez_id = na.omit(DEG.entrez_id)</span><br><span class="line">erich.go.BP = enrichGO(gene = DEG.entrez_id,</span><br><span class="line">                       OrgDb = org.Mm.eg.db,</span><br><span class="line">                       keyType = <span class="string">&quot;ENTREZID&quot;</span>,</span><br><span class="line">                       ont = <span class="string">&quot;BP&quot;</span>,</span><br><span class="line">                       pvalueCutoff = <span class="number">0.5</span>,</span><br><span class="line">                       qvalueCutoff = <span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">##分析完成后，作图</span></span><br><span class="line">dotplot(erich.go.BP)</span><br></pre></td></tr></table></figure>
<img width="80%" height="80%" src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/GO.jpeg"/>

</li>
</ul>
<p><a href="https://www.jianshu.com/p/47b5ea646932?utm_source=desktop&amp;utm_medium=timeline">https://www.jianshu.com/p/47b5ea646932?utm_source=desktop&amp;utm_medium=timeline</a></p>
<ul>
<li>热图绘制<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(pheatmap)</span><br><span class="line">colnames(exprSet)&lt;-<span class="built_in">c</span>(<span class="string">&quot;KO1455&quot;</span>,<span class="string">&quot;KO1462&quot;</span>,<span class="string">&quot;KO1471&quot;</span>,<span class="string">&quot;WT1441&quot;</span>,<span class="string">&quot;WT1465&quot;</span>,<span class="string">&quot;WT1474&quot;</span>)</span><br><span class="line">choose_upgene=<span class="built_in">names</span>(sort(apply(up_gene, <span class="number">1</span>, mad),decreasing = <span class="built_in">T</span>)[<span class="number">1</span>:<span class="number">40</span>])</span><br><span class="line">choose_upgene_matrix=exprSet[choose_upgene,]</span><br><span class="line">choose_downgene=<span class="built_in">names</span>(sort(apply(down_gene, <span class="number">1</span>, mad),decreasing = <span class="built_in">T</span>)[<span class="number">1</span>:<span class="number">40</span>])</span><br><span class="line">choose_downgene_matrix=exprSet[choose_downgene,]</span><br><span class="line">choose_matrix=rbind(choose_upgene_matrix,choose_downgene_matrix)</span><br><span class="line">choose_matrix=t(scale(t(choose_matrix)))</span><br><span class="line">annotation_col = data.frame(CellType = factor(<span class="built_in">rep</span>(<span class="built_in">c</span>(<span class="string">&quot;KO&quot;</span>, <span class="string">&quot;WT&quot;</span>), each=<span class="number">3</span>)),Time = <span class="number">1</span>:<span class="number">3</span>)</span><br><span class="line">rownames(annotation_col)&lt;-colnames(exprSet)</span><br><span class="line">pheatmap(choose_matrix,fontsize = <span class="number">6</span>,cexCol=<span class="number">1</span>,cellwidth=<span class="number">10</span>,cellheigh=<span class="number">5</span>,color = colorRampPalette(<span class="built_in">c</span>(<span class="string">&#x27;navy&#x27;</span>,<span class="string">&#x27;white&#x27;</span>,<span class="string">&#x27;firebrick3&#x27;</span>))(<span class="number">50</span>),annotation_col=annotation_col)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/heatmap.jpeg"/>

</li>
</ul>
]]></content>
      <tags>
        <tag>NGS</tag>
      </tags>
  </entry>
  <entry>
    <title>R语言apply、lapply、strsplit、&amp;#37in&amp;#37用法介绍</title>
    <url>/2020/02/23/R%E8%AF%AD%E8%A8%80apply%E3%80%81lapply%E3%80%81strsplit%E3%80%81%25in%25%E7%94%A8%E6%B3%95%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>生信分析下游过程中，为了构建好可用于个性化分析的数据，往往要对原有数据进行整理，这个时候<code>apply</code>、<code>lapply</code>、<code>strsplit</code>、<code>%in%</code>就会在不同的地方发光✨发热🔥啦</p>
<a id="more"></a>

<h1 id="R语言apply、lapply、strsplit、-in-用法介绍"><a href="#R语言apply、lapply、strsplit、-in-用法介绍" class="headerlink" title="R语言apply、lapply、strsplit、%in%用法介绍"></a>R语言apply、lapply、strsplit、%in%用法介绍</h1><h2 id="apply函数"><a href="#apply函数" class="headerlink" title="apply函数"></a>apply函数</h2><p><strong>用于遍历数组中的行或列，并且使用指定函数来对其元素进行处理</strong></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">apply(x,MARGIN,FUN,...)</span><br></pre></td></tr></table></figure>
<p>x：数组、矩阵、数据框等<br>MARGIN：1表示行，2表示列<br>FUN：自定义的函数</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">x&lt;-matrix(rnorm(<span class="number">20</span>),<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">x</span><br><span class="line">rowmean&lt;-apply(x, <span class="number">1</span>, mean)</span><br><span class="line">rowmean</span><br><span class="line">colmean&lt;-apply(x, <span class="number">2</span>, mean)</span><br><span class="line">colmean</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/apply.JPG"/>

<h2 id="lapply函数"><a href="#lapply函数" class="headerlink" title="lapply函数"></a>lapply函数</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">lapply(x,FUN)</span><br></pre></td></tr></table></figure>
<p><strong>lapply()函数中多出来的l代表的是list，所以lapply()和apply()的区别在于输出的格式，lapply()的输出是一个列表（list），所以lapply()函数不需要MARGIN参数</strong></p>
<p><strong>遍历列表向量内的每个元素，并且使用指定函数来对其元素进行处理。返回列表向量。</strong></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">y&lt;-matrix(<span class="number">1</span>:<span class="number">10</span>,<span class="number">2</span>,<span class="number">5</span>)</span><br><span class="line">plus3&lt;-lapply(y, <span class="keyword">function</span>(x) x+<span class="number">3</span>)</span><br><span class="line">plus3</span><br><span class="line">unlist(plus3)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/lapply.JPG"/>


<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">y&lt;-<span class="built_in">c</span>(<span class="string">&quot;BABA&quot;</span>,<span class="string">&quot;MAMA&quot;</span>,<span class="string">&quot;YEYE&quot;</span>,<span class="string">&quot;NAINAI&quot;</span>)</span><br><span class="line">lower&lt;-lapply(y, tolower)</span><br><span class="line">lower</span><br><span class="line">unlist(lower)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/lapply2.JPG"/>


<p><strong>特定情况下，apply族函数比for、while函数更方便。</strong></p>
<h2 id="strsplit函数"><a href="#strsplit函数" class="headerlink" title="strsplit函数"></a>strsplit函数</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">strsplit(x, split, fixed= <span class="built_in">F</span>, perl= <span class="built_in">F</span>, useBytes= <span class="built_in">F</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>参数x为字符串格式向量，函数依次对向量的每个元素进行拆分。</p>
</li>
<li><p>参数split为拆分位置的字串向量，即在哪个字串处开始拆分。</p>
</li>
<li><p>fixed= T则表示是用普通文本匹配或者正则表达式的精确匹配,用普通文本来匹配的运算速度要快些。</p>
</li>
<li><p>参数useBytes表示是否逐字节进行匹配，默认为FALSE，表示是按字符匹配而不是按字节进行匹配。</p>
</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">s&lt;-as.data.frame(<span class="built_in">c</span>(<span class="string">&quot;444.dady_good-tempered.444&quot;</span>,<span class="string">&quot;222.mom_bad-tempered.222&quot;</span>,<span class="string">&quot;111.me_completely-lazy.111&quot;</span>))</span><br><span class="line">colnames(s)&lt;-<span class="string">&quot;family&quot;</span></span><br><span class="line">rownames(s)&lt;-<span class="built_in">c</span>(<span class="string">&quot;dady&quot;</span>,<span class="string">&quot;mom&quot;</span>,<span class="string">&quot;me&quot;</span>)</span><br><span class="line"><span class="built_in">list</span>&lt;-strsplit(<span class="built_in">as.character</span>(s$family),<span class="string">&quot;[.]&quot;</span>)</span><br><span class="line"><span class="built_in">list</span></span><br><span class="line">final&lt;-as.data.frame(<span class="built_in">list</span>)</span><br><span class="line">final</span><br><span class="line">disposition&lt;-final[<span class="number">2</span>,]</span><br><span class="line">disposition</span><br><span class="line">x&lt;-as.data.frame(t(final[<span class="number">2</span>,]))</span><br><span class="line">x</span><br><span class="line">colnames(x)&lt;-<span class="string">&quot;strsplit&quot;</span></span><br><span class="line">rownames(x)&lt;-<span class="built_in">c</span>(<span class="string">&quot;dady&quot;</span>,<span class="string">&quot;mom&quot;</span>,<span class="string">&quot;me&quot;</span>)</span><br><span class="line">x</span><br><span class="line">s$disposition&lt;-x$strsplit</span><br><span class="line">s</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/strsplit.JPG"/>

<h2 id="in-函数"><a href="#in-函数" class="headerlink" title="%in%函数"></a>%in%函数</h2><p><strong><code>%in%</code>函数在不同数据集间取相同的差异基因中非常有用！</strong></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">rm(<span class="built_in">list</span> = ls())</span><br><span class="line">a&lt;-<span class="built_in">c</span>(<span class="string">&#x27;p&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;l&#x27;</span>)</span><br><span class="line">b&lt;-<span class="built_in">c</span>(<span class="string">&#x27;w&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;p&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">a%in%b</span><br><span class="line">a[a%in%b]</span><br><span class="line">b%in%a</span><br><span class="line">b[b%in%a]</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/intersect.JPG"/>


]]></content>
      <tags>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title>SSH服务</title>
    <url>/2020/02/24/SSH%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<p>远程控制服务：配置sshd服务、 安全密钥验证、远程传输命令<br>不间断会话服务：管理远程会话、会话共享功能</p>
<a id="more"></a>

<h1 id="远程控制服务"><a href="#远程控制服务" class="headerlink" title="远程控制服务"></a>远程控制服务</h1><ul>
<li>linux中一切皆是文件，配置服务即是对配置文件进行修改</li>
<li>主配置文件：最重要的配置文件<br>一般情况下在/etc/服务名称/服务名称.config  </li>
<li>普通文件：主要被调用，常规参数</li>
</ul>
<h2 id="（一）配置sshd服务"><a href="#（一）配置sshd服务" class="headerlink" title="（一）配置sshd服务"></a>（一）配置sshd服务</h2><p><strong>想要使用SSH协议来远程管理Linux系统，则需要部署配置sshd服务程序。</strong></p>
<blockquote>
<p>一般的服务程序并不会在配置文件修改之后立即获得最新的参数。如果想让新配置文件生效，则需要手动<strong>重启相应的服务程序</strong>。最好也<strong>将这个服务程序加入到开机启动项</strong>中，这样系统在下一次启动时，该服务程序便会自动运行，继续为用户提供服务。  </p>
</blockquote>
<ol>
<li>查看主配置文件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>Xshell远程登陆服务器,此时是需要密码验证的。 </li>
</ol>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ssh <span class="number">192.168</span>.12.136</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/PermitRootLogin_yes.JPG"/>



<ol start="3">
<li>修改主配置文件内容如下，使得不可以通过root用户方式远程登陆服务器。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/beforemodification.JPG"/>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/modification.JPG"/>

<ol start="4">
<li>在此远程连接服务器，发现依然可以通过root用户方式远程登陆服务器。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh 192.168.12.64</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/PermitRootLogin_no_without_systemctl_restart_sshd.JPG"/>


<ol start="5">
<li><strong>重启服务</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#这里以sshd服务为例</span></span><br><span class="line">systemctl restart sshd</span><br><span class="line">systemctl <span class="built_in">enable</span> sshd</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>再次进行远程登陆</li>
</ol>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ssh <span class="number">192.168</span>.12.64</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/PermitRootLogin_no.JPG"/>

<p>每次输入密码后，会再次弹出界面框要求输入密码，进入死循环。。。。。。</p>
<h2 id="（二）安全密钥验证"><a href="#（二）安全密钥验证" class="headerlink" title="（二）安全密钥验证"></a>（二）安全密钥验证</h2><ol>
<li>客户端主机中生成“密钥对”</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/ssh-keygen.JPG"/>

<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/sshkeygenfile.JPG"/>


<ol start="2">
<li>把客户端主机生成的<strong>公钥文件</strong>传送至远程主机</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-copy-id 116.63.129.7</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/ssh-copy-id.JPG"/>

<ol start="3">
<li>查看服务器端认证的文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;root&#x2F;.ssh&#x2F;authorized_keys</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/cat_root_.ssh_authorized_key.JPG"/>

<ol start="4">
<li>客户端登陆服务端</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh 116.63.129.7</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/ssh116.JPG"/>

<p>此时就会发现，客户端远程访问服务器就<strong>不需要密码</strong>登陆了。因为密钥的优先级是高于密码的。这样是不是很方便呢？嘿嘿😁 </p>
<p>而且，<strong>密钥方式登陆</strong>更安全哦！😊</p>
<ol start="5">
<li>修改<strong>服务器端配置文件</strong>，使其只支持密钥方式登陆</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#注意啦，一定要是服务器端的配置文件</span></span><br><span class="line">vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/server_passwordauthentication_yes.JPG"/>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/server_passwordauthentication_no.JPG"/>

<ol start="6">
<li>重启相应服务</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart sshd</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>Xshell远程登陆服务器（验证）</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh 116.63.129.7</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/xshell116with_sysytemctl___.JPG"/>

<p>登陆界面默认无法输入密码！</p>
<p><strong>注意啦，有对应私钥的客户端无需密码即可登陆拥有对应公钥的服务端</strong></p>
<h2 id="远程传输命令"><a href="#远程传输命令" class="headerlink" title="远程传输命令"></a>远程传输命令</h2><p>scp（secure copy）是一个基于SSH协议在网络之间进行安全传输的命令。</p>
<ol>
<li>将客户端文件传给服务器端</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#一下操作在客户端进行</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;this is a test about scp&quot;</span>&gt;scptest</span><br><span class="line">scp /root/scptest 116.63.129.7:/home</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>进入服务器端进行查看</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /home/scptest</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/scptest.JPG"/>


<ol start="3">
<li>将服务器端文件传给客户端</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#以下操作在服务器端进行</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;This is the message from server&quot;</span>&gt;fromserver</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>进入客户端进行文件下载和查看</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp 116.63.129.7:home/fromserver /root</span><br><span class="line">cat /root/fromserver</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/scpservertohost.JPG"/>

<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/catfromserver.JPG"/>


<h1 id="不间断会话服务"><a href="#不间断会话服务" class="headerlink" title="不间断会话服务"></a>不间断会话服务</h1><p><strong><a href="https://www.linuxprobe.com/chapter-09.html#92">首先配置yum仓库</a></strong></p>
<h2 id="管理远程会话"><a href="#管理远程会话" class="headerlink" title="管理远程会话"></a>管理远程会话</h2><p>screen命令能做的事情非常多：可以用-S参数创建会话窗口；用-d参数将指定会话进行离线处理；用-r参数恢复指定会话；用-x参数一次性恢复所有的会话；用-ls参数显示当前已有的会话；以及用-wipe参数把目前无法使用的会话删除</p>
<ol>
<li>screen服务介绍</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建一个会话框test</span></span><br><span class="line">screen -S <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看系统当前的会话</span></span><br><span class="line">screen -ls</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#退出当前会话</span></span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>screen实战一</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建TEST会话框,会发现屏幕闪跳了以下</span></span><br><span class="line">screen -S TEST</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls</span><br><span class="line"><span class="built_in">cd</span> /bin</span><br><span class="line"><span class="built_in">cd</span> /roo/biosoft</span><br><span class="line">ls</span><br></pre></td></tr></table></figure>
<p>当前界面如下<br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/screenTEST1.JPG"/></p>
<p>此时将终端kill掉，模拟远程连接过程中网络出错</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">screen -ls</span><br><span class="line">screen -r TEST <span class="comment">#恢复离线的对话框</span></span><br></pre></td></tr></table></figure>
<p>此时就会恢复到上一次发生事故时的界面</p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/screenTEST2.JPG"/>

<ol start="3">
<li>screen实战二</li>
</ol>
<p>有时候在编辑文件时，文件内容还未及时保存，远程连接出现问题。这个时候screen服务就会🌟发光发热🔥</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">screen vim test.txt</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/vim.JPG"/>

<p>此时将终端kill掉，模拟远程连接过程中网络出错</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">screen -ls</span><br><span class="line">screen -r 10777</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/screen-r10777.JPG"/>

<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/vim.JPG"/>

<h2 id="会话共享功能"><a href="#会话共享功能" class="headerlink" title="会话共享功能"></a>会话共享功能</h2><ol>
<li><p>终端A远程连接服务器+创建会话</p>
<p>ssh服务将终端A远程连接到服务器（这里假装连接了，其实就是连接到本地的虚拟机，为了方便展示）</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#连接</span></span><br><span class="line">ssh 192.168.12.136</span><br><span class="line"><span class="comment">#创建会话框</span></span><br><span class="line">screen -S <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>终端B远程连接服务器+同步</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh 192.168.12.136</span><br><span class="line">screen -x</span><br></pre></td></tr></table></figure>
<p>此后，终端A和终端B就同步画面啦</p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/synchronization.JPG"/>


<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/xiaochina/p/5802008.html">ssh配置文件ssh_config和sshd_config区别</a></p>
<p><a href="https://www.linuxprobe.com/chapter-09.html#92">远程控制服务_文字版</a></p>
<p><a href="https://www.bilibili.com/video/av71365003?p=12">远程控制服务_视频版</a></p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>SUPPA2实战</title>
    <url>/2021/02/23/SUPPA2%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="SUPPA2实战（DLBCL）"><a href="#SUPPA2实战（DLBCL）" class="headerlink" title="SUPPA2实战（DLBCL）"></a>SUPPA2实战（DLBCL）</h1><p>因为最近ascp无法使用了，只好使用preftch进行数据下载SRA数据，再自己转成fastq。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nohup prefetch --option-file SRR_Acc_List1.txt &amp;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp -P 6001 .&#x2F;test.csv gongyuqi@124.77.170.70:&#x2F;home&#x2F;gongyuqi</span><br><span class="line"></span><br><span class="line">#port: 6654</span><br><span class="line">gmb39@81.70.205.254:&#x2F;home&#x2F;data&#x2F;gmb39&#x2F;project&#x2F;AS&#x2F;SUPPA2&#x2F;SRA </span><br><span class="line"></span><br><span class="line">#port: 6001</span><br><span class="line">gongyuqi@124.77.170.70:&#x2F;home&#x2F;gongyuqi&#x2F;project&#x2F;AS&#x2F;SUPPA2&#x2F;SRA</span><br></pre></td></tr></table></figure>

<p>conda安装参考：<a href="https://www.jianshu.com/p/edaa744ea47d">https://www.jianshu.com/p/edaa744ea47d</a></p>
<h2 id="数据下载、转换"><a href="#数据下载、转换" class="headerlink" title="数据下载、转换"></a>数据下载、转换</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#SRA格式转成fastq格式</span></span><br><span class="line">ls *.sra | <span class="keyword">while</span> <span class="built_in">read</span> id</span><br><span class="line"><span class="keyword">do</span> nohup fastq-dump --split-3 <span class="variable">$id</span> &amp;</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#gzip压缩一下，节省空间</span></span><br><span class="line">ls *.fastq | <span class="keyword">while</span> <span class="built_in">read</span> id</span><br><span class="line"><span class="keyword">do</span> nohup pigz -p 8 <span class="variable">$id</span> &amp;</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="质控"><a href="#质控" class="headerlink" title="质控"></a>质控</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nohup fastqc -t 16 *gz -o ./fastqc &amp;</span><br><span class="line">nohup multiqc ./fastqc/*.zip -o ./multiqc &amp;</span><br><span class="line"></span><br><span class="line">out_dir=/home/gongyuqi/project/AS/SUPPA2/clean</span><br><span class="line">trim_galore --paired --quality 20 -a AGATCGGAAGAGC -a2 AGATCGGAAGAGC --length 20 -o <span class="variable">$out_dir</span> R1.fq.gz R2.fq.gz</span><br><span class="line"></span><br><span class="line">out_dir=/home/gongyuqi/project/AS/SUPPA2/clean</span><br><span class="line">cat sample.txt|<span class="keyword">while</span> <span class="built_in">read</span> id</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">arr=(<span class="variable">$&#123;id&#125;</span>)</span><br><span class="line">fq1=<span class="variable">$&#123;arr[0]&#125;</span></span><br><span class="line">fq2=<span class="variable">$&#123;arr[1]&#125;</span></span><br><span class="line">nohup trim_galore --paired --quality 25 -e 0.1 --length 36 -a AGATCGGAAGAGC -a2 AGATCGGAAGAGC  -o <span class="variable">$out_dir</span> <span class="variable">$fq1</span> <span class="variable">$fq2</span> &amp;</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>


<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p><strong>(1)、运行salmon软件定量</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat clean_sample.txt|<span class="keyword">while</span> <span class="built_in">read</span> id</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">arr=(<span class="variable">$&#123;id&#125;</span>)</span><br><span class="line">fq1=<span class="variable">$&#123;arr[0]&#125;</span></span><br><span class="line">fq2=<span class="variable">$&#123;arr[1]&#125;</span></span><br><span class="line">dir=<span class="variable">$&#123;fq1%%_*&#125;</span></span><br><span class="line">nohup salmon quant -i /home/gongyuqi/ref/hg38/ensembl/SUPPA_ref/Ensembl_hg19_salmon_index -l ISF --gcBias -1 <span class="variable">$fq1</span> -2 <span class="variable">$fq2</span> -p 8 -o /home/gongyuqi/project/AS/SUPPA2/salmon_quant/<span class="variable">$dir</span> &amp;</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p><strong>(2)、提取所有样本的TPM值并合并为一个文件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">suppa_dir=/home/gongyuqi/miniconda3/envs/SUPPA2_3.9/bin/</span><br><span class="line">nohup python <span class="variable">$suppa_dir</span>/multipleFieldSelection.py -i /home/gongyuqi/project/AS/SUPPA2/salmon_quant/*/quant.sf -k 1 -f 4 -o /home/gongyuqi/project/AS/SUPPA2/output/iso_tpm.txt &amp;</span><br></pre></td></tr></table></figure>

<p><strong>(3)、使iso_tpm.txt文件中的转录本id同下载的gtf文件id一致</strong>  </p>
<p>运行此R脚本，会生成iso_tpm_formatted.txt文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Rscript format_Ensembl_ids.R iso_tpm.txt</span><br></pre></td></tr></table></figure>


<h2 id="三、PSI计算"><a href="#三、PSI计算" class="headerlink" title="三、PSI计算"></a>三、PSI计算</h2><p><strong>1、根据参考基因组注释文件生成可变剪切事件文件</strong></p>
<p><code>-i</code> GTF文件<br><code>-o</code> 输出文件前缀<br><code>-e</code> 输出文件中包含的可变剪切类型<br><code>-f</code> 输出的格式  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#生成ioe文件</span></span><br><span class="line">suppa_dir=/home/gongyuqi/miniconda3/envs/SUPPA2_3.9/bin/</span><br><span class="line">gtf_dir=/home/gongyuqi/ref/hg38/ensembl/SUPPA_ref</span><br><span class="line">python <span class="variable">$suppa_dir</span>/suppa.py generateEvents -i <span class="variable">$gtf_dir</span>/Homo_sapiens.GRCh37.75.formatted.gtf -o ensembl_hg19.events -e SE SS MX RI FL -f ioe</span><br><span class="line"><span class="comment">#合并所有的ioe文件</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$gtf_dir</span></span><br><span class="line">awk <span class="string">&#x27;</span></span><br><span class="line"><span class="string">    FNR==1 &amp;&amp; NR!=1 &#123; while (/^&lt;header&gt;/) getline; &#125;</span></span><br><span class="line"><span class="string">    1 &#123;print&#125;</span></span><br><span class="line"><span class="string">&#x27;</span> *.ioe &gt; ensembl_hg19.events.ioe</span><br></pre></td></tr></table></figure>
<p>结果如下<br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/ensembl_hg19.events.ioe.JPG"/></p>
<p><strong>2、计算样本的PSI值</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/gongyuqi/project/AS/SUPPA2</span><br><span class="line">ioe_merge_file=~/ref/hg38/ensembl/SUPPA_ref/hg19_event/ensembl_hg19.events.ioe</span><br><span class="line">nohup python <span class="variable">$suppa_dir</span>/suppa.py psiPerEvent -i <span class="variable">$ioe_merge_file</span> -e iso_tpm_formatted.txt -o TRA2_events &amp;</span><br></pre></td></tr></table></figure>

<h2 id="根据ensembl-ID获取基因名"><a href="#根据ensembl-ID获取基因名" class="headerlink" title="根据ensembl ID获取基因名"></a>根据ensembl ID获取基因名</h2><p>参考资料：<a href="https://www.sohu.com/a/245475759_777125">https://www.sohu.com/a/245475759_777125</a></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(biomaRt)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Biomart目前提供了四种数据库，可以使用listMarts()函数查看</span></span><br><span class="line">listMarts()</span><br><span class="line"><span class="comment">#               biomart                version</span></span><br><span class="line"><span class="comment">#1 ENSEMBL_MART_ENSEMBL      Ensembl Genes 103</span></span><br><span class="line"><span class="comment">#2   ENSEMBL_MART_MOUSE      Mouse strains 103</span></span><br><span class="line"><span class="comment">#3     ENSEMBL_MART_SNP  Ensembl Variation 103</span></span><br><span class="line"><span class="comment">#4 ENSEMBL_MART_FUNCGEN Ensembl Regulation 103</span></span><br><span class="line"><span class="comment">#当处理人类基因时，用useMart()函数选择“ENSEMBL_MART_ENSEMBL”</span></span><br><span class="line">human_mart&lt;-useMart(<span class="string">&quot;ENSEMBL_MART_ENSEMBL&quot;</span>)</span><br><span class="line"><span class="comment">#ensembl数据库中包含了很多个数据集，可以使用这个代码查看</span></span><br><span class="line">datasets&lt;-listDatasets(human_mart)</span><br><span class="line">view(datasets)</span><br><span class="line"><span class="comment">#从上一步的结果中，选择人类基因的ensembl数据集：hsapiens_gene_ensembl</span></span><br><span class="line">my_datasets&lt;-useDataset(<span class="string">&quot;hsapiens_gene_ensembl&quot;</span>,mart=human_nart)</span><br><span class="line"><span class="comment">#输入需要转换的ensembl ID</span></span><br><span class="line">ensembl_id&lt;-<span class="string">&quot;ENSG00000149554&quot;</span></span><br><span class="line"><span class="comment">#getBM进行ID转换</span></span><br><span class="line">ensembl_symbol&lt;-getBM(<span class="built_in">attributes</span> = <span class="built_in">c</span>(<span class="string">&quot;ensembl_gene_id&quot;</span>,<span class="string">&quot;chromosome_name&quot;</span>,<span class="string">&quot;hgnc_symbol&quot;</span>,<span class="string">&quot;hgnc_id&quot;</span>),</span><br><span class="line">      filters = <span class="string">&quot;ensembl_gene_id&quot;</span>,</span><br><span class="line">      values = ensembl_id,</span><br><span class="line">      mart = my_datasets)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>ENSG00000000457</p>
]]></content>
      <tags>
        <tag>tag1</tag>
      </tags>
  </entry>
  <entry>
    <title>WES</title>
    <url>/2021/05/14/WES/</url>
    <content><![CDATA[<p>whole exome-sequencing analysis pipeline</p>
<a id="more"></a>
<h1 id="全外显子数据分析"><a href="#全外显子数据分析" class="headerlink" title="全外显子数据分析"></a>全外显子数据分析</h1><h2 id="一-环境搭建"><a href="#一-环境搭建" class="headerlink" title="(一) 环境搭建"></a>(一) 环境搭建</h2><p><strong>1、GATK依赖Java 8/JDK 1.8 (Oracle or OpenJDK)</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看一下环境中是否有java，如果有，版本是否符合要求</span></span><br><span class="line">java --version</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/java_version.JPG"/>

<p><strong>2、下载安装GATK4</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/broadinstitute/gatk/releases/download/4.2.0.0/gatk-4.2.0.0.zip</span><br><span class="line">unzip gatk-4.2.0.0.zip</span><br><span class="line"><span class="comment">#将当前路径加到环境变量中</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=/home/gongyuqi/biosoft/GATK/gatk-4.2.0.0:$PATH&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>
<p><strong>3、下载其他需要的软件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#首先创建WES的conda环境</span></span><br><span class="line">conda create -n WES</span><br><span class="line"><span class="comment">#其次下载其他需要的软件</span></span><br><span class="line">conda install -y python=3.6.2</span><br><span class="line">conda install -y bwa sra-tools samtools bcftools snpEFF multiqc </span><br><span class="line">qualimap  </span><br><span class="line"><span class="comment">#激活环境，准备开始实战演练</span></span><br><span class="line">conda activate WES</span><br><span class="line"><span class="comment">#创建存放各阶段数据的文件夹</span></span><br><span class="line"><span class="built_in">cd</span> /home/gongyuqi/project/WES</span><br><span class="line">mkdir raw qc clean mutaion</span><br><span class="line"><span class="built_in">cd</span> qc &amp;&amp; mkdir raw_qc clean_qc</span><br></pre></td></tr></table></figure>
<h2 id="二-WES测试数据下载"><a href="#二-WES测试数据下载" class="headerlink" title="(二) WES测试数据下载"></a>(二) WES测试数据下载</h2><p><strong>1、数据来源<a href="https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE153707">GSE153707</a>，我们这里从<a href="https://www.ebi.ac.uk/ena/browser/view/PRJNA643782">EBI直接下载fastq文件</a></strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将下列数据下载的脚本保存到download.sh文件中</span></span><br><span class="line">dir=/home/gongyuqi/.aspera/connect/etc/asperaweb_id_dsa.openssh</span><br><span class="line">x=_1</span><br><span class="line">y=_2</span><br><span class="line"><span class="keyword">for</span> id <span class="keyword">in</span> &#123;11,12&#125;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">ascp -QT -l 300m -P33001 -i <span class="variable">$dir</span> era-fasp@fasp.sra.ebi.ac.uk:/vol1/fastq/SRR121/0<span class="variable">$id</span>/SRR121359<span class="variable">$id</span>/SRR121359$id<span class="variable">$x</span>.fastq.gz .</span><br><span class="line">ascp -QT -l 300m -P33001 -i <span class="variable">$dir</span> era-fasp@fasp.sra.ebi.ac.uk:/vol1/fastq/SRR121/0<span class="variable">$id</span>/SRR121359<span class="variable">$id</span>/SRR121359$id<span class="variable">$y</span>.fastq.gz . </span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment">#赋予执行权限</span></span><br><span class="line">chmod +x download.sh</span><br><span class="line"><span class="comment">#放后台进行数据下载</span></span><br><span class="line">nohup ./download.sh &amp;</span><br></pre></td></tr></table></figure>
<p><strong>2、了解文章WES数据处理的相关步骤和参数</strong></p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/paper_methods.JPG" width="70%">


<h2 id="三-GATK准备bam文件用于找变异"><a href="#三-GATK准备bam文件用于找变异" class="headerlink" title="(三) GATK准备bam文件用于找变异"></a>(三) GATK准备bam文件用于找变异</h2><h3 id="1、-比对GATK官网提供的参考基因组"><a href="#1、-比对GATK官网提供的参考基因组" class="headerlink" title="1、 比对GATK官网提供的参考基因组"></a>1、 比对GATK官网提供的参考基因组</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#====step 1 首先质空，查看数据是否需要进行过滤</span></span><br><span class="line"><span class="comment">#我们这里的质控结果显示reads的整体质量还不错（GC含量看着不太过分基本不影响后续的分析），可以直接用于比对</span></span><br><span class="line">ls ../raw/*.gz|xargs fastqc -t 4 -o ./</span><br><span class="line">multiqc *.zip</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/fastqc-status-check-heatmap.png"/>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#====step 2 比对</span></span><br><span class="line">ls *1.fastq.gz &gt;fq1.txt</span><br><span class="line">ls *2.fastq.gz &gt;fq2.txt</span><br><span class="line">paste fq1.txt fq2.txt &gt; sample.txt</span><br><span class="line">index=/home/gongyuqi/ref/GATK/hg38/v0/Homo_sapiens_assembly38.fasta.64</span><br><span class="line">cat sample.txt | <span class="keyword">while</span> <span class="built_in">read</span> id</span><br><span class="line"><span class="keyword">do</span> nohup</span><br><span class="line">arr=(<span class="variable">$&#123;id&#125;</span>)</span><br><span class="line">fq1=<span class="variable">$&#123;arr[0]&#125;</span></span><br><span class="line">fq2=<span class="variable">$&#123;arr[1]&#125;</span></span><br><span class="line">sample=<span class="variable">$&#123;fq1%%_*&#125;</span></span><br><span class="line">bwa mem -t 8 -R <span class="string">&quot;@RG\tID:<span class="variable">$sample</span>\tSM:<span class="variable">$sample</span>\tLB:WGS\tPL:Illumina&quot;</span> /<span class="variable">$index</span> <span class="variable">$fq1</span> <span class="variable">$fq2</span> |samtools sort -@ 8 -o ../align/<span class="variable">$sample</span>.sort.bam - &amp;&gt;&gt;../align/<span class="variable">$sample</span>.<span class="built_in">log</span> &amp;</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ====step 3 查看比对结果</span></span><br><span class="line">ls *.bam|<span class="keyword">while</span> <span class="built_in">read</span> id;<span class="keyword">do</span> samtools flagstat <span class="variable">$id</span>;<span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/bwa_flagstat.JPG" width="50%">

<h3 id="2、标记PCR重复"><a href="#2、标记PCR重复" class="headerlink" title="2、标记PCR重复"></a>2、标记PCR重复</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ====step 1 MarkDuplicates</span></span><br><span class="line">ls *.bam|<span class="keyword">while</span> <span class="built_in">read</span> sample</span><br><span class="line"><span class="keyword">do</span> nohup gatk --java-options <span class="string">&quot;-Xmx20G -Djava.io.tmpdir=./&quot;</span> \</span><br><span class="line">   MarkDuplicates \</span><br><span class="line">   --INPUT <span class="variable">$sample</span> \</span><br><span class="line">   --OUTPUT <span class="variable">$&#123;sample%%.*&#125;</span>_marked.bam \</span><br><span class="line">   -M <span class="variable">$&#123;sample%%.*&#125;</span>.metrics &amp;</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ====step 2 FixMateInformation</span></span><br><span class="line">ls *_marked.bam|<span class="keyword">while</span> <span class="built_in">read</span> sample</span><br><span class="line"><span class="keyword">do</span> nohup gatk --java-options <span class="string">&quot;-Xmx20G -Djava.io.tmpdir=./&quot;</span> \</span><br><span class="line">   FixMateInformation \</span><br><span class="line">   -I <span class="variable">$&#123;sample&#125;</span> \</span><br><span class="line">   -O <span class="variable">$&#123;sample%%_*&#125;</span>_marked_fixed.bam \</span><br><span class="line">   -SO coordinate &amp;</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment">#建立*_fixed.bam文件索引</span></span><br><span class="line">ls *_fixed.bam|<span class="keyword">while</span> <span class="built_in">read</span> sample</span><br><span class="line"><span class="keyword">do</span> nohup samtools index <span class="variable">$sample</span> &amp;</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<h3 id="3、碱基矫正-BaseRecalibrator"><a href="#3、碱基矫正-BaseRecalibrator" class="headerlink" title="3、碱基矫正 BaseRecalibrator"></a>3、碱基矫正 BaseRecalibrator</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ref=/home/gongyuqi/ref/GATK/hg38/v0/Homo_sapiens_assembly38.fasta</span><br><span class="line">snp=/home/gongyuqi/ref/GATK/hg38/v0/Homo_sapiens_assembly38.dbsnp138.vcf</span><br><span class="line">indel=/home/gongyuqi/ref/GATK/hg38/v0/Mills_and_1000G_gold_standard.indels.hg38.vcf.gz</span><br><span class="line"></span><br><span class="line">ls *_marked_fixed.bam|<span class="keyword">while</span> <span class="built_in">read</span> sample</span><br><span class="line"><span class="keyword">do</span> nohup gatk \</span><br><span class="line">         --java-options <span class="string">&quot;-Xmx20G -Djava.io.tmpdir=./&quot;</span> \</span><br><span class="line">         BaseRecalibrator \</span><br><span class="line">         -R <span class="variable">$ref</span> \</span><br><span class="line">         -I <span class="variable">$sample</span> \</span><br><span class="line">         --known-sites <span class="variable">$snp</span> \</span><br><span class="line">         --known-sites <span class="variable">$indel</span> \</span><br><span class="line">         -O <span class="variable">$&#123;sample%%_*&#125;</span>_recal.table \</span><br><span class="line">         1&gt;<span class="variable">$&#123;sample%%_*&#125;</span>_log.recal 2&gt;&amp;1 &amp;</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#BWA比对时设置@RG的重要性在这一步体现出来了，算法通过@RG中的ID来识别各个独立的测序过程</span></span><br><span class="line">ls *_marked_fixed.bam|<span class="keyword">while</span> <span class="built_in">read</span> sample</span><br><span class="line"><span class="keyword">do</span> nohup gatk \</span><br><span class="line">         --java-options <span class="string">&quot;-Xmx20G -Djava.io.tmpdir=./&quot;</span>   ApplyBQSR \</span><br><span class="line">         -R <span class="variable">$ref</span>  \</span><br><span class="line">         -I <span class="variable">$sample</span>  \</span><br><span class="line">         -bqsr <span class="variable">$&#123;sample%%_*&#125;</span>_recal.table \</span><br><span class="line">         -O <span class="variable">$&#123;sample%%_*&#125;</span>_bqsr.bam \</span><br><span class="line">         1&gt;<span class="variable">$&#123;sample%%_*&#125;</span>_log.ApplyBQSR  2&gt;&amp;1 &amp;</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment"># 查看比对结果</span></span><br><span class="line">ls *bqsr.bam|<span class="keyword">while</span> <span class="built_in">read</span> id</span><br><span class="line"><span class="keyword">do</span> nohup samtools flagstat <span class="variable">$id</span> &amp;</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">gatk --java-options <span class="string">&quot;-Xmx20G&quot;</span> AnalyzeCovariates \</span><br><span class="line">     -before recal_data.table1 \</span><br><span class="line">     -after recal_data.table2 \</span><br><span class="line">     -plots AnalyzeCovariates.pdf</span><br></pre></td></tr></table></figure>
<h3 id="4、HaplotypeCaller"><a href="#4、HaplotypeCaller" class="headerlink" title="4、HaplotypeCaller"></a>4、HaplotypeCaller</h3><blockquote>
<p>这一步是使用GATK的HaplotypeCaller找变异，但现在GATK官网推荐GATK4+Mutect2找变异，在这里我们还是简单运行一下HaplotypeCaller。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls *bqsr.bam|<span class="keyword">while</span> <span class="built_in">read</span> sample</span><br><span class="line"><span class="keyword">do</span> nohup gatk \</span><br><span class="line">         --java-options <span class="string">&quot;-Xmx20G -Djava.io.tmpdir=./&quot;</span> HaplotypeCaller \</span><br><span class="line">         -R <span class="variable">$ref</span>  \</span><br><span class="line">         -I <span class="variable">$sample</span> \</span><br><span class="line">         --dbsnp <span class="variable">$snp</span> \</span><br><span class="line">         -O ../vcf/<span class="variable">$&#123;sample%%_*&#125;</span>_raw.vcf \</span><br><span class="line">         1&gt;../vcf/<span class="variable">$&#123;sample%%_*&#125;</span>_log.HC 2&gt;&amp;1 &amp;</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<h2 id="三-Mutect2找变异"><a href="#三-Mutect2找变异" class="headerlink" title="(三) Mutect2找变异"></a>(三) Mutect2找变异</h2><p><strong><a href="https://gatk.broadinstitute.org/hc/en-us/articles/360035889791?id=11136">Mutect2 v4.1.0.0的教程</a>目前已经不被GATK官方强烈推荐。官方更新推荐了<a href="https://gatk.broadinstitute.org/hc/en-us/articles/360035531132">Mutect2 v4.1.1.0 and later版本的使用教程</a>，更新过的教程比较推荐用于正常对照样本&gt;40的WES测序数据。如果没有这么多的样本量，Mutect2 v4.1.0.0的教程也同样可以使用，只是有部分参数在新的Mutect2版本中被弃用或是将其功能整合到另外的参数去了。具体问题可以查看官网说明。</strong></p>
<h3 id="1、过滤种系突变"><a href="#1、过滤种系突变" class="headerlink" title="1、过滤种系突变"></a>1、过滤种系突变</h3><blockquote>
<p>首先需要一个germline variant sites VCF文件，去官网下载<a href="https://console.cloud.google.com/storage/browser/gatk-best-practices/somatic-hg38">af-only-gnomad.hg38.vcf.gz</a>文件。记得一并下载对应的.tbi文件</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ref=/home/gongyuqi/ref/GATK/hg38/v0/Homo_sapiens_assembly38.fasta</span><br><span class="line">germine_vcf=/home/gongyuqi/ref/GATK/hg38/af-only-gnomad/af-only-gnomad.hg38.vcf.gz</span><br><span class="line"></span><br><span class="line">nohup gatk --java-options <span class="string">&quot;-Xmx20g&quot;</span> Mutect2 \</span><br><span class="line">-R <span class="variable">$ref</span> \</span><br><span class="line">-I SRR12135912_bqsr.bam \</span><br><span class="line">-tumor SRR12135912 \</span><br><span class="line">-I SRR12135911_bqsr.bam \</span><br><span class="line">-normal SRR12135911 \</span><br><span class="line">--germline-resource <span class="variable">$germine_vcf</span> \</span><br><span class="line">--af-of-alleles-not-in-resource 0.0000025 \</span><br><span class="line">--disable-read-filter MateOnSameContigOrNoMappedMateReadFilter \</span><br><span class="line">--bam-output HQ461-untreated-Mutect2.bam \</span><br><span class="line">-O ../Mutect2/HQ461-untreated.Mutect2.vcf &amp;</span><br></pre></td></tr></table></figure>
<p>生成文件如下：<br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/Mutect2.JPG"/></p>
<h3 id="2、考虑样品纯度及假阳性"><a href="#2、考虑样品纯度及假阳性" class="headerlink" title="2、考虑样品纯度及假阳性"></a>2、考虑样品纯度及假阳性</h3><blockquote>
<p>通常，病人的肿瘤样本是混合有正常组织的，这个时候我们可以选择<code>GetPileupSummaries</code>工具来计算肿瘤样本的污染程度。对于Mutect2流程而言，GATK只考虑了肿瘤样本中正常样本的污染情况，不考虑正常样本中肿瘤样本的污染情况。这里我们的处理组:HQ461,对照组untreated。，虽然我们的样本是肿瘤细胞的单克隆株，我们这里还是跑一下这个流程。</p>
</blockquote>
<h4 id="step-1、生成af-only-gnomad-hg38-SNP-biallelic-vcf-gz"><a href="#step-1、生成af-only-gnomad-hg38-SNP-biallelic-vcf-gz" class="headerlink" title="step 1、生成af-only-gnomad.hg38.SNP_biallelic.vcf.gz"></a>step 1、生成af-only-gnomad.hg38.SNP_biallelic.vcf.gz</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ref=/home/gongyuqi/ref/GATK/hg38/v0/Homo_sapiens_assembly38.fasta</span><br><span class="line">germine_vcf=/home/gongyuqi/ref/GATK/hg38/af-only-gnomad/af-only-gnomad.hg38.vcf.gz</span><br><span class="line">nohup gatk SelectVariants \</span><br><span class="line">-R <span class="variable">$ref</span> \</span><br><span class="line">-V <span class="variable">$germine_vcf</span> \</span><br><span class="line">--select-type-to-include SNP \</span><br><span class="line">--restrict-alleles-to BIALLELIC \</span><br><span class="line">-O /home/gongyuqi/ref/GATK/hg38/af-only-gnomad/af-only-gnomad.hg38.SNP_biallelic.vcf.gz &amp;</span><br></pre></td></tr></table></figure>
<h4 id="step-2、GetPileupSummaries"><a href="#step-2、GetPileupSummaries" class="headerlink" title="step 2、GetPileupSummaries"></a>step 2、GetPileupSummaries</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">germine_biallelic_vcf=/home/gongyuqi/ref/GATK/hg38/af-only-gnomad/af-only-gnomad.hg38.SNP_biallelic.vcf.gz</span><br><span class="line">genomic_intervals=/home/gongyuqi/ref/GATK/hg38/v0/wgs_calling_regions.hg38.interval_list</span><br><span class="line"></span><br><span class="line">nohup gatk GetPileupSummaries \</span><br><span class="line">-I SRR12135911_bqsr.bam \</span><br><span class="line">-L <span class="variable">$genomic_intervals</span> \</span><br><span class="line">-V <span class="variable">$germine_biallelic_vcf</span> \</span><br><span class="line">-O ../Mutect2/SRR12135911.pileups.table &amp;</span><br><span class="line"></span><br><span class="line">nohup gatk GetPileupSummaries \</span><br><span class="line">-I SRR12135912_bqsr.bam \</span><br><span class="line">-L <span class="variable">$genomic_intervals</span> \</span><br><span class="line">-V <span class="variable">$germine_biallelic_vcf</span> \</span><br><span class="line">-O ../Mutect2/SRR12135912.pileups.table &amp;</span><br></pre></td></tr></table></figure>
<h4 id="step-3、-CalculateContamination"><a href="#step-3、-CalculateContamination" class="headerlink" title="step 3、 CalculateContamination"></a>step 3、 CalculateContamination</h4><blockquote>
<p>计算污染比例，用以过滤掉somatic variant中一些可能由污染导致的假阳性突变</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nohup gatk CalculateContamination \</span><br><span class="line">-I SRR12135912.pileups.table \</span><br><span class="line">-matched SRR12135911.pileups.table \</span><br><span class="line">-O HQ461-untreated.calculatecontamination.table &amp;</span><br></pre></td></tr></table></figure>
<h4 id="step-3、-FilterMutectCalls"><a href="#step-3、-FilterMutectCalls" class="headerlink" title="step 3、 FilterMutectCalls"></a>step 3、 FilterMutectCalls</h4><blockquote>
<p>结合CalculateContamination的评估，进行最后的过滤</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ref=/home/gongyuqi/ref/GATK/hg38/v0/Homo_sapiens_assembly38.fasta</span><br><span class="line">nohup gatk FilterMutectCalls \</span><br><span class="line">-R <span class="variable">$ref</span> \</span><br><span class="line">-V HQ461-untreated.Mutect2.vcf \</span><br><span class="line">--contamination-table HQ461-untreated.calculatecontamination.table \</span><br><span class="line">-O HQ461-untreated.filtered.Mutect2.vcf &amp;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>至此，我们找变异的步骤就差不多走完了。你会发现我们并没有使用到<code>CollectSequencingArtifactMetrics</code>和<code>FilterByOrientationBias</code>参数，那是因为我们当前版本的Mutect2已经将FilterByOrientationBias的功能整合进<code>FilterMutectCalls</code>中了，详情见<a href="https://gatk.broadinstitute.org/hc/en-us/community/posts/360077855051-gatk-FilterByOrientationBias">GATK论坛中的一篇帖子</a>。</p>
</blockquote>
<blockquote>
<p>另外，在做WES分析时，对照组是很重要的。拿肿瘤样本举例，tumor-only的模式会得到很多很多很多的假阳性，详情见<a href="https://gatk.broadinstitute.org/hc/en-us/community/posts/360057810051-Mutect2-somatic-variant-calling-with-without-matched-normal-sample">GATK论坛中的另一篇帖子</a>。对照组的存在会大大降低假阳性率。</p>
</blockquote>
<h2 id="四-SnpEff-amp-SnpSift注释"><a href="#四-SnpEff-amp-SnpSift注释" class="headerlink" title="(四) SnpEff &amp; SnpSift注释"></a>(四) SnpEff &amp; SnpSift注释</h2><blockquote>
<p>以下流程参考<a href="https://pcingola.github.io/SnpEff/se_introduction/">SnpEff &amp; SnpSift官网文档</a></p>
</blockquote>
<h3 id="1、SnpEff软件及所需注释数据库的下载"><a href="#1、SnpEff软件及所需注释数据库的下载" class="headerlink" title="1、SnpEff软件及所需注释数据库的下载"></a>1、SnpEff软件及所需注释数据库的下载</h3><h4 id="step-1、下载安装SnpEff软件"><a href="#step-1、下载安装SnpEff软件" class="headerlink" title="step 1、下载安装SnpEff软件"></a>step 1、下载安装SnpEff软件</h4><p>下载<a href="https://pcingola.github.io/SnpEff/download/">SnpEff</a>，现在SnpEff和SnpSift是绑定在一起的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/biosoft/</span><br><span class="line"><span class="comment">#下载</span></span><br><span class="line">wget https://snpeff.blob.core.windows.net/versions/snpEff_latest_core.zip &amp;</span><br><span class="line"><span class="comment">#安装</span></span><br><span class="line">unzip snpEff_latest_core.zip</span><br></pre></td></tr></table></figure>

<h4 id="step-2、下载SnpEff软件需要的数据库文件"><a href="#step-2、下载SnpEff软件需要的数据库文件" class="headerlink" title="step 2、下载SnpEff软件需要的数据库文件"></a>step 2、下载SnpEff软件需要的数据库文件</h4><p>下载 SnpEff databases: 官网给的命令是java -jar snpEff.jar download GRCh38.76。但是运行这个命令会报错：找不到GRCh38.76</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#运行下面的命令查看SnpEff目前支持的database</span></span><br><span class="line">java -jar snpEff.jar databases | less</span><br><span class="line"><span class="comment">#运行下面的命令查看SnpEff支持的GRCh38 database,目前是GRCh38.99</span></span><br><span class="line">java -jar snpEff.jar databases | grep -i GRCh38</span><br><span class="line"><span class="comment">#看来SnpEff网站更新不及时呀，在网站维护和更新这一点上，要重点表扬GATK团队！！！</span></span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/GRCh38.99.JPG"/>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#于是下载GRCh38.99</span></span><br><span class="line">nohup java -jar snpEff.jar download GRCh38.99 &amp;</span><br><span class="line"><span class="comment">#但是这个网络问题是无解的。我最后还是自己手动下载snpEff_v5_0_GRCh38.99.zip文件</span></span><br><span class="line"><span class="comment">#解压完，最后GRCh38.99文件夹绝对路径/home/gongyuqi/biosoft/snpEff/data/GRCh38.99</span></span><br></pre></td></tr></table></figure>
<p>GRCh38.99内容如下<br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/GRCh38.99.content.JPG"/></p>
<h3 id="2、SnpEff、SnpSift使用"><a href="#2、SnpEff、SnpSift使用" class="headerlink" title="2、SnpEff、SnpSift使用"></a>2、SnpEff、SnpSift使用</h3><h4 id="step-1、SnpEff注释"><a href="#step-1、SnpEff注释" class="headerlink" title="step 1、SnpEff注释"></a>step 1、SnpEff注释</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#the &quot;verbose&quot; mode (command line option -v), this makes SnpEff to show a lot of information which can be useful for debugging.</span></span><br><span class="line">java -Xmx16g -jar snpEff.jar -v GRCh38.99 /home/gongyuqi/project/WES/Mutect2/HQ461-untreated.filtered.Mutect2.vcf &gt; HQ461-untreated.filtered.ann.vcf</span><br></pre></td></tr></table></figure>

<h4 id="step-2、SnpSift过滤"><a href="#step-2、SnpSift过滤" class="headerlink" title="step 2、SnpSift过滤"></a>step 2、SnpSift过滤</h4><p>该部分同时参考官网说明文档及某优秀博客<a href="http://www.sci666.net/40794.html">用SnpSift过滤VCF文件</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#保留Filter字段为&#x27;PASS&#x27;或缺失值的记录</span></span><br><span class="line">cat HQ461-untreated.filtered.ann.vcf | java -jar SnpSift.jar filter <span class="string">&quot;( na FILTER ) | (FILTER = &#x27;PASS&#x27;)&quot;</span> &gt; HQ461-untreated.filtered.ann.snpsift.vcf</span><br><span class="line"><span class="comment">#保留INFO中ANN字段的IMPACT为&#x27;HIGH&#x27;或&#x27;MODERATE&#x27;的记录</span></span><br><span class="line">cat HQ461-untreated.filtered.ann.snpsift.vcf | java -jar SnpSift.jar filter <span class="string">&quot;(ANN[0].IMPACT has &#x27;HIGH&#x27;) | (ANN[0].IMPACT has &#x27;MODERATE&#x27;)&quot;</span> &gt; HQ461-untreated.filtered.ann.snpsift.second.vcf</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#简单看一下三个vcf文件的大小</span></span><br><span class="line">ls -lh *.vcf</span><br><span class="line">ls *.vcf|<span class="keyword">while</span> <span class="built_in">read</span> id; <span class="keyword">do</span> cat <span class="variable">$id</span>|wc -l;<span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/vcf.JPG"/>


<h4 id="step-3、sed命令复现SnpSift的功能"><a href="#step-3、sed命令复现SnpSift的功能" class="headerlink" title="step 3、sed命令复现SnpSift的功能"></a>step 3、<code>sed</code>命令复现SnpSift的功能</h4><blockquote>
<p>这里不难发现，SnpSift其实就是对文本文件的处理。要是shell脚本够扎实，也完全可以不依赖SnpSift。重要的是，在学习NGS组学分析过程中，但凡有锻炼自己shell脚本的地方，就一定要抓住机会动手写一写💪 <strong>这里我们可以用一个简单的<code>sed</code>命令解决</strong></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#第一个`sed`命令打印出所有标记为PASS的位点</span></span><br><span class="line"><span class="comment">#第二个`sed`命令承接上一个管道输出的内容，保留标记为HIGH或者MODERATE的位点</span></span><br><span class="line">cat HQ461-untreated.filtered.ann.vcf | grep -v <span class="string">&quot;#&quot;</span>| \</span><br><span class="line">sed -n <span class="string">&#x27;/PASS/p&#x27;</span> - | \</span><br><span class="line">sed -n <span class="string">&#x27;/\(HIGH\|MODERATE\)/p&#x27;</span> - \</span><br><span class="line">&gt;test_PASS_HIGH_MODERATE.third.vcf</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#检验一下我们`sed`脚本的正确性</span></span><br><span class="line"><span class="comment">#看看位点数目是否一致</span></span><br><span class="line">cat HQ461-untreated.filtered.ann.snpsift.second.vcf|grep -v <span class="string">&quot;#&quot;</span>|wc -l</span><br><span class="line">cat test_PASS_HIGH_MODERATE.second.vcf|wc -l</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/wc_l.JPG"/>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#再具体看看内容是否一致</span></span><br><span class="line">cat HQ461-untreated.filtered.ann.snpsift.second.vcf|grep -v <span class="string">&quot;#&quot;</span>|less -SN</span><br><span class="line">cat test_PASS_HIGH_MODERATE.second.vcf|less -SN</span><br></pre></td></tr></table></figure>
<p>HQ461-untreated.filtered.ann.snpsift.second.vcf<br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/SnpSift_second.JPG"/><br>test_PASS_HIGH_MODERATE.second.vcf<br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/sed.JPG"/></p>
<h2 id="五-原文数据复现"><a href="#五-原文数据复现" class="headerlink" title="(五) 原文数据复现"></a>(五) 原文数据复现</h2><blockquote>
<p>真正接受检验的时候到了，看看我们的pipeline能不能复现文章的数据。这也是进一步检验我们pipeline的正确性的重要环节（当然也不能迷信文章的结果，但是7+文章的数据分析质量应该还是可以作为一个较好的参考）。<br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/G_to_A.JPG"/></p>
</blockquote>
<p><strong>再看看我们过滤后的vcf文件中是否有检测到CDK12的G到A的突变</strong><br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/CDK12_G_to_A.JPG"/></p>
<p><strong>学习WES心得体会</strong></p>
<p>1、学习某个软件的用法时，主要参考官方文档！！！可以选择性参考相关博客主博客，但切记拿来主义！！！深刻理解用到的每个参数。</p>
<p>2、WES的相关分析还有很多，我们这里只涉及到SNV。同样的，突变的注释也涉及到多种软件，我们这里只涉及到了SnpEff。学海无涯啊~~~从培养起自主学习的思维和习惯开始。</p>
<p>3、拿到最终的注释文件（.vcf），我们还可以用到maftools、ComplexHeatmap等R包将突变情况进行可视化。</p>
<p>4、不急不慢，不慌不忙，坚持下去❤</p>
]]></content>
      <tags>
        <tag>tag1</tag>
      </tags>
  </entry>
  <entry>
    <title>UEFI</title>
    <url>/2020/04/04/UEFI/</url>
    <content><![CDATA[<p>windows启动模式包括两种：UEFI+GPT、Legacy+MBR。<br>在此介绍3中在windows上查看系统启动模式的方法。</p>
<a id="more"></a>  

<h1 id="（一）、diskpart判断UEFI方法"><a href="#（一）、diskpart判断UEFI方法" class="headerlink" title="（一）、diskpart判断UEFI方法"></a>（一）、diskpart判断UEFI方法</h1><p>win+r打开运行输入diskpart命令。<br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/diskpart1.png"/></p>
<p>GPT一行下面带*表示使用的GPT分区表+UEFI启动模式。</p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/diskpart2.png"/>


<h1 id="（二）系统信息判断"><a href="#（二）系统信息判断" class="headerlink" title="（二）系统信息判断"></a>（二）系统信息判断</h1><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/systeminfo1.png"/>

<p>也可以win+r打开运行，输入msinfo32命令来执行打开系统信息。</p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/msinfo321.png"/>

<p>在系统摘要中可以看到bios的模式</p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/msinfo322.png"/>

<h1 id="（三）、磁盘管理判断UEFI"><a href="#（三）、磁盘管理判断UEFI" class="headerlink" title="（三）、磁盘管理判断UEFI"></a>（三）、磁盘管理判断UEFI</h1><p>win+r打开，输入compmgmt.msc，打开管理。</p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/compmgmt.msc1.png"/>

<p>在磁盘管理中将鼠标放到引导硬盘的分区上，是UEFI引导会有相应的提示，否则为传统模式。</p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/compmgmt.msc2.png"/>


<p><strong>参考资料</strong><br><a href="https://jingyan.baidu.com/article/49ad8bce1bf31a1935d8fa09.html">https://jingyan.baidu.com/article/49ad8bce1bf31a1935d8fa09.html</a></p>
]]></content>
      <tags>
        <tag>System</tag>
      </tags>
  </entry>
  <entry>
    <title>gawk 进阶</title>
    <url>/2020/03/16/gawk-%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<p>使用变量、处理数组、处理模式</p>
<a id="more"></a>

<h1 id="gawk进阶"><a href="#gawk进阶" class="headerlink" title="gawk进阶"></a>gawk进阶</h1><h2 id="一、使用变量"><a href="#一、使用变量" class="headerlink" title="一、使用变量"></a>一、使用变量</h2><h3 id="（一）、内建变量"><a href="#（一）、内建变量" class="headerlink" title="（一）、内建变量"></a>（一）、内建变量</h3><p><strong>字段和记录分隔符变量</strong></p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/g1.1.JPG"/>

<p>print命令会自动将OFS变量的值放置在输出中的每个字段间。通过设置OFS变量，可以在输 出中使用任意字符串来分隔字段。</p>
<p>FIELDWIDTHS变量允许你不依靠字段分隔符来读取记录。在一些应用程序中，数据并没有使 用字段分隔符，而是被放置在了记录中的特定列。这种情况下，必须设定FIELDWIDTHS变量来 匹配数据在记录中的位置。</p>
<p>如果你用默认的FS和RS变量值来读取这组数据，gawk就会把每行作为一条单独的记录来读 取，并将记录中的空格当作字段分隔符。要解决这个问题，只需把FS变量设置成换行符。这就表明数据流中的每行都是一个单独的字 段，每行上的所有数据都属于同一个字段。把RS变量设置成空字符串，然后在数据记录间留一个空白行。gawk会 把每个空白行当作一个记录分隔符。 </p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/g1.2.JPG"/>


<p><strong>数据变量</strong></p>
<p>跟shell变量不同，在脚本中引用gawk变量时，变量名前不加美元符。 </p>
<p>ARGC和ARGV变量允许从shell中 获得命令行参数的总数以及它们的值。但这可能有点麻烦，因为gawk并不会将程序脚本当成命令行参数的一部分。ARGV数组从索引0开始，代表的是命令。</p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/g1.21.JPG"/>

<p>ENVIRON变量使用关联数组来提取shell环境变量。关联数组用文本 作为数组的索引值，而不是数值。</p>
<p>ENVIRON[“HOME”]变量从shell中提取了HOME环境变量的值。类似地，ENVIRON[“PATH”]提 取了PATH环境变量的值</p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/g1.22.JPG"/>


<p>NF变量可以让你在不知道具体位置的情况下指定记录中的后一个数据字段。NF变量含有数据文件中后一个数据字段的数字值。可以在它前面加个美元符将其用作字段 变量。 </p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/g1.23.JPG"/>


<p>FNR变量含有当前数据文件中已处理过的记录数，NR变量则含有已处理过的记录总数。</p>
<p>FNR变量的值在gawk处理第二个数据文件时被重置了，而NR变量则在处理第二个数据文件时 继续计数。结果就是：如果只使用一个数据文件作为输入，FNR和NR的值是相同的；如果使用多 个数据文件作为输入，FNR的值会在处理每个数据文件时被重置，而NR的值则会继续计数直到处 理完所有的数据文件。 </p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/g1.24.JPG"/>

<h3 id="（二）、自定义变量"><a href="#（二）、自定义变量" class="headerlink" title="（二）、自定义变量"></a>（二）、自定义变量</h3><p><strong>在脚本中给变量赋值</strong></p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/g2.1.JPG"/>

<p><strong>在命令行上给变量赋值</strong></p>
<p>前两个例子可以让在不改变脚本代码的情况下改变脚本的行为。第一个例子显示了文件的第二个数据字段，第二个例子显示了第三个数据字段，只要在命令行上设置n变量的值就行。</p>
<p>使用命令行参数来定义变量值会有一个问题。在你设置了变量后，这个值在代码的BEGIN部分不可用。 </p>
<p>可以用-v命令行参数来解决这个问题。它允许你在BEGIN代码之前设定变量。在命令行上，-v命令行参数必须放在脚本代码之前。变量紧挨-v参数，也要放在脚本之前。</p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/g2.2.JPG"/>


<h2 id="二、处理数组"><a href="#二、处理数组" class="headerlink" title="二、处理数组"></a>二、处理数组</h2><p>为了在单个变量中存储多个值，许多编程语言都提供数组。gawk编程语言使用关联数组提供 数组功能。关联数组跟数字数组不同之处在于它的索引值可以是任意文本字符串。你不需要用连续的数字来标识数组中的数据元素。相反，关联数组用各种字符串来引用值。每个索引字符串都必须能 够唯一地标识出赋给它的数据元素。跟Python中的字典类似。</p>
<p><strong>定义数组变量</strong></p>
<p>var[index] = element</p>
<p>其中var是变量名，index是关联数组的索引值，element是数据元素值。下面是一些gawk中数组变量的例子。</p>
<p><code>&#39;</code> 和<code>&quot;</code>在本例中效果不一样</p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/g2.21.JPG"/>


<p><strong>遍历数组变量</strong></p>
<p>关联数组变量的问题在于你可能无法知晓索引值是什么。跟使用连续数字作为索引值的数字数组不同，关联数组的索引可以是任何东西。</p>
<p>如果要在gawk中遍历一个关联数组，可以用for语句的一种特殊形式。</p>
<p>注意：(key in f)才能正确执行，key in f会报错。<br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/g2.22.JPG"/></p>
<p><strong>删除数组变量</strong></p>
<p>delete array[index]</p>
<p>删除命令会从数组中删除关联索引值和相关的数据元素值。</p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/g2.3.JPG"/>

<h2 id="三、使用模式"><a href="#三、使用模式" class="headerlink" title="三、使用模式"></a>三、使用模式</h2><h3 id="（一）、正则表达式"><a href="#（一）、正则表达式" class="headerlink" title="（一）、正则表达式"></a>（一）、正则表达式</h3><p>gawk程序会用正则表达式对记录中所有的数据字段进行匹配，包括字段分隔符。 </p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/g3.1.JPG"/>

<h3 id="（二）、匹配操作符"><a href="#（二）、匹配操作符" class="headerlink" title="（二）、匹配操作符"></a>（二）、匹配操作符</h3><p>匹配操作符（matching operator）允许将正则表达式限定在记录中的特定数据字段。匹配操作符是波浪线（~）。可以指定匹配操作符、数据字段变量以及要匹配的正则表达式。</p>
<p>$2变量代表记录中的第一个数据字段。这个表达式会过滤出第一个字段以文本2开头的所有记录。data同理。</p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/g3.2.1JPG.JPG"/>

<p>也可以用!符号来排除正则表达式的匹配。</p>
<p>$1 !~ /expression/</p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/g3.2.2JPG.JPG"/>


<h3 id="（三）、数学表达式"><a href="#（三）、数学表达式" class="headerlink" title="（三）、数学表达式"></a>（三）、数学表达式</h3><p>第一个测试显示所有属于root用户组（组ID为0）的系统用户。</p>
<p>对文本数据使用表达式，必须小心。跟正则表达式不同，表达式必须完全匹配。数据必须跟模式严格匹配。<br>第二个测试中没有匹配任何记录，因为第一个数据字段的值不在任何记录中。第三个测试用值data11匹配了一条记录。 </p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/g3.3.JPG"/>


<h2 id="四、结构化命令"><a href="#四、结构化命令" class="headerlink" title="四、结构化命令"></a>四、结构化命令</h2><h3 id="（一）、if语句"><a href="#（一）、if语句" class="headerlink" title="（一）、if语句"></a>（一）、if语句</h3><p>gawk编程语言支持标准的if-then-else格式的if语句。你必须为if语句定义一个求值的条件，并将其用圆括号括起来。如果条件求值为TRUE，紧跟在if语句后的语句会执行。如果条 件求值为FALSE，这条语句就会被跳过。</p>
<p>格式： </p>
<p><strong>if (condition)</strong></p>
<p><strong>statement1</strong> </p>
<p>也可以将它放在一行上，像这样：</p>
<p><strong>if (condition) statement1</strong> </p>
<p>可以在多行使用else子句,也可以在单行上使用else子句，但必须在if语句部分之后使用分号。</p>
<p><strong>if (condition) statement1; else statement2</strong> </p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/g4.1.1.JPG"/>

<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/g4.1.2.JPG"/>

<h3 id="（二）、while语句"><a href="#（二）、while语句" class="headerlink" title="（二）、while语句"></a>（二）、while语句</h3><p>while语句为gawk程序提供了一个基本的循环功能。下面是while语句的格式。 </p>
<p><strong>while (condition)</strong></p>
<p><strong>{</strong><br>    <strong>statements</strong><br><strong>}</strong></p>
<p>while循环允许遍历一组数据，并检查迭代的结束条件。</p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/g4.2.1.JPG"/>

<p>第一个例子和第二个例子中的number=0多余了，忽略它。</p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/g4.2.2.JPG"/>

<h3 id="（三）、do-while语句"><a href="#（三）、do-while语句" class="headerlink" title="（三）、do-while语句"></a>（三）、do-while语句</h3><p>do-while语句类似于while语句，但会在检查条件语句之前执行命令。下面是do-while语句的格式。</p>
<p><strong>do</strong><br><strong>{</strong><br>    <strong>statements</strong><br><strong>} while (condition)</strong> </p>
<p>这种格式保证了语句会在条件被求值之前至少执行一次。当需要在求值条件前执行语句时， 这个特性非常方便。 </p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/g4.3.1.JPG"/>

<p>这个脚本会读取每条记录的数据字段并将它们加在一起，直到累加结果达到4。如果第一个数据字段大于4（就像在第二条和第三条记录中看到的那样），则脚本会保证在条件被求值前至少读取第一个数据字段的内容。</p>
<h3 id="（四）、for语句"><a href="#（四）、for语句" class="headerlink" title="（四）、for语句"></a>（四）、for语句</h3><p>for语句是许多编程语言执行循环的常见方法。gawk编程语言支持C风格的for循环。将多个功能合并到一个语句有助于简化循环。 </p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/g4.4.JPG"/>


<h2 id="五、格式化打印"><a href="#五、格式化打印" class="headerlink" title="五、格式化打印"></a>五、格式化打印</h2><p><strong>格式化打印命令：printf</strong></p>
<p>如果你需要显示一个字符串变量，可以用格式化指定符%s。如果你需要显示一个整数 值，可以用%d或%i（%d是十进制数的C风格显示方式）。</p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/g5.1.JPG"/>

<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/g5.1.2.JPG"/>

<p>你需要在printf命令的末尾手动添加换行符来生成新行。没添加的话，printf命令会继续在同一行打印后续输出。</p>
<p><font color=blue>每个printf的输出都会出现在同一行上</font>。为了终止该行，END部分打印了一个换行符。 </p>
<p>下面这个例子也可以再次体会RS的作用。FS指定输入的分隔符，RS指定输入记录分隔符。即对记录的数据从新定义的分隔符，所以$1为1，$2为2,$3为3,一次类推。</p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/g5.1.5.JPG"/>

<p>printf命令在处理浮点值时也非常方便。通过为变量指定一个格式，你可以让输出看起来更统一。可以使用%.1f格式指定符来强制printf命令将浮点值近似到小数点后一位。  </p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/g5.1.3.JPG"/>

<p><strong>可以用printf命令来帮助格式化输出，使得输出信息看起来更美观。</strong></p>
<p>◉ width：指定了输出字段小宽度的数字值。如果输出短于这个值，printf会将文本右 对齐，并用空格进行填充。如果输出比指定的宽度还要长，则按照实际的长度输出。</p>
<p>◉ prec：这是一个数字值，指定了浮点数中小数点后面位数，或者文本字符串中显示的 大字符数。</p>
<p>◉ -（减号）：指明在向格式化空间中放入数据时采用左对齐而不是右对齐。 </p>
<ul>
<li>首先，让我们将print 命令转换成printf命令，它会产生跟print命令相同的输出。printf命令用%s格式化指定符来作为这两个字符串值的占位符。printf需要手动换行。</li>
</ul>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/g5.1.4.JPG"/>

<ul>
<li>通过添加一个值为16的修饰符，我们强制第一个字符串的输出宽度为16个字符。默认情况下， printf命令使用右对齐来将数据放到格式化空间中。要改成左对齐，只需给修饰符加一个减号 即可</li>
</ul>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/g5.1.6.JPG"/>

<h2 id="六-内建函数"><a href="#六-内建函数" class="headerlink" title="六 内建函数"></a>六 内建函数</h2><h3 id="（一）、数学函数"><a href="#（一）、数学函数" class="headerlink" title="（一）、数学函数"></a>（一）、数学函数</h3><p>gawk中内建的数学函数。</p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/g6.1.1.JPG"/>


<p>int() 函数会生成一个值的整数部分，但它并不会四舍五入取近似值。它的做法像R语言中的floor函数。它会生成该值和0之间接近该值的整数。 int()函数在值为5.6时返回5，在值为-5.6时则返回-5。</p>
<p>rand()函数非常适合创建随机数，但这个随机数只在0和1之间（不包括0或1）。要得到更大的数，就需要放大返 回值。 </p>
<p>产生较大整数随机数的常见方法是用rand()函数和int()函数创建一个算法。</p>
<p>x = int(10 * rand()) </p>
<p>gawk语言对于它能够处理的数值有一个限定区间。如果 超出了这个区间，就会得到一条错误消息。 </p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/g6.1.2.JPG"/>

<h3 id="（二）、字符串函数"><a href="#（二）、字符串函数" class="headerlink" title="（二）、字符串函数"></a>（二）、字符串函数</h3><p>怎么感觉有点麻烦，先不看这个了。😏</p>
<h3 id="（三）、时间函数"><a href="#（三）、时间函数" class="headerlink" title="（三）、时间函数"></a>（三）、时间函数</h3><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/g6.3.1.JPG"/>

<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/g6.3.2.JPG"/>

<h2 id="七、自定义函数"><a href="#七、自定义函数" class="headerlink" title="七、自定义函数"></a>七、自定义函数</h2><h3 id="（一）、定义函数"><a href="#（一）、定义函数" class="headerlink" title="（一）、定义函数"></a>（一）、定义函数</h3><p>要定义自己的函数，必须用function关键字。函数名必须能够唯一标识函数。</p>
<p><strong>function name([variables])</strong><br><strong>{</strong><br>    <strong>statements</strong><br><strong>}</strong> </p>
<h3 id="（二）、使用自定义函数"><a href="#（二）、使用自定义函数" class="headerlink" title="（二）、使用自定义函数"></a>（二）、使用自定义函数</h3><p>在定义函数时，它必须出现在所有代码块之前（包括BEGIN代码块）。乍一看可能有点怪异，但它有助于将函数代码与gawk程序的其他部分分开。</p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/g7.2.JPG"/>

<h3 id="（三）、创建函数库"><a href="#（三）、创建函数库" class="headerlink" title="（三）、创建函数库"></a>（三）、创建函数库</h3><p>gawk提供了一种途径来将多个函数放到一个库文件中，这样就能在所有的gawk程序中使用了。</p>
<ul>
<li><p>首先，你需要创建一个存储所有gawk函数的文件。</p>
</li>
<li><p>需要使用-f命令行参数来使用它们。很遗憾，不能将-f命令 行参数和内联gawk脚本放到一起使用，不过可以在同一个命令行中使用多个-f参数。</p>
</li>
<li><p>因此，要使用库，只要创建一个含有你的gawk程序的文件，然后在命令行上同时指定库文件和程序文件就行了。</p>
</li>
</ul>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/g7.3.JPG"/>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>scRNA-seq_数据复现</title>
    <url>/2021/05/13/scRNA-seq-%E6%95%B0%E6%8D%AE%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="单细胞转录组数据降维聚类分群图表复现初尝试"><a href="#单细胞转录组数据降维聚类分群图表复现初尝试" class="headerlink" title="单细胞转录组数据降维聚类分群图表复现初尝试"></a>单细胞转录组数据降维聚类分群图表复现初尝试</h1><p><strong>1. 这次我们要复现的单细胞数据来自International Journal of Cancer 2020年发表的一篇单细胞相关的纯生信文章。该文章数据链接：<a href="https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE150321">GSE150321</a></strong></p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/paper.JPG" width="50%">

<p><strong>2. 简单浏览文章，抓取作者针对单细胞数据分析给出的一些参数信息，如下</strong></p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/paper_analysis_information.JPG" width="50%">


<h1 id="Step-0、加载需要的R包"><a href="#Step-0、加载需要的R包" class="headerlink" title="Step 0、加载需要的R包"></a>Step 0、加载需要的R包</h1><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(Seurat)</span><br><span class="line">library(dplyr)</span><br><span class="line">library(patchwork)</span><br><span class="line">library(mindr)</span><br><span class="line">library(Matrix)</span><br></pre></td></tr></table></figure>
<h1 id="Step-1、数据准备"><a href="#Step-1、数据准备" class="headerlink" title="Step 1、数据准备"></a>Step 1、数据准备</h1><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">setwd(<span class="string">&quot;//home//data//gongyuqi//R&quot;</span>)</span><br><span class="line"><span class="comment">#文章测序了两个病人的样本，正文figure展示的是其中一个病人的单细胞测序结果。我们下面的分析使用正文中展示的样本</span></span><br><span class="line"><span class="comment">#读入数据并将表达矩阵转成稀疏矩阵，减少数据对空间资源的消耗以及运算资源的消耗</span></span><br><span class="line">GSM4546857&lt;-read.csv(<span class="string">&quot;GSM4546857_LSCC01_DBEC_UMI.csv&quot;</span>,comment.char = <span class="string">&quot;#&quot;</span>)</span><br><span class="line"><span class="built_in">dim</span>(GSM4546857)</span><br><span class="line">GSM4546857[<span class="number">1</span>:<span class="number">4</span>,<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">rownames(GSM4546857)&lt;-GSM4546857$Cell_Index</span><br><span class="line">GSM4546857&lt;-GSM4546857[,-<span class="number">1</span>]</span><br><span class="line">GSM4546857&lt;-t(GSM4546857)</span><br><span class="line">object.size(GSM4546857)<span class="comment">#2331231144 bytes</span></span><br><span class="line">GSM4546857_sparse&lt;-as(as.matrix(GSM4546857),<span class="string">&quot;dgCMatrix&quot;</span>)</span><br><span class="line">GSM4546857_sparse[<span class="number">1</span>:<span class="number">4</span>,<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">object.size(GSM4546857_sparse)<span class="comment">#166367952 bytes</span></span><br><span class="line">save(GSM4546857_sparse,file = <span class="string">&quot;GSM4546857_sparse.Rdata&quot;</span>)</span><br><span class="line"><span class="built_in">dim</span>(GSM4546857_sparse)</span><br></pre></td></tr></table></figure>
<p><strong>在此，可以直观的感受一下两种矩阵的大小</strong><br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/sparse_matrix.JPG"/></p>
<h1 id="Step-2、创建Seurat对象"><a href="#Step-2、创建Seurat对象" class="headerlink" title="Step 2、创建Seurat对象"></a>Step 2、创建Seurat对象</h1><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#下面这段代码中，最重要的就是创建Seurat对象以及去除线粒体基因，其他都是对Seurat对象的可视化，其目的在于提高初学者对该对象的了解</span></span><br><span class="line"><span class="comment">## =============== 创建Seurat对象</span></span><br><span class="line">tissu1 &lt;- CreateSeuratObject(counts = GSM4546857_sparse, project = <span class="string">&quot;LSCC&quot;</span>, min.cells = <span class="number">3</span>, min.features = <span class="number">200</span>)</span><br><span class="line">tissu1</span><br><span class="line"></span><br><span class="line"><span class="comment">## =============== 去除线粒体基因</span></span><br><span class="line"><span class="comment"># The [[ operator can add columns to object metadata. This is a great place to stash QC stats</span></span><br><span class="line"><span class="comment">#此次数据检测到大量线粒体基因</span></span><br><span class="line">grep(pattern = <span class="string">&quot;^MT\\.&quot;</span>,rownames(tissu1),value = <span class="built_in">T</span>)</span><br><span class="line">tissu1[[<span class="string">&quot;percent.mt&quot;</span>]] &lt;- PercentageFeatureSet(tissu1, pattern = <span class="string">&quot;^MT\\.&quot;</span>)</span><br><span class="line">head(tissu1@meta.data,<span class="number">5</span>)</span><br><span class="line">summary(tissu1@meta.data$nCount_RNA)</span><br></pre></td></tr></table></figure>
<p><strong>看一看过滤前数据情况</strong></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Visualize QC metrics as a violin plot</span></span><br><span class="line">VlnPlot(tissu1, features = <span class="built_in">c</span>(<span class="string">&quot;nFeature_RNA&quot;</span>, <span class="string">&quot;nCount_RNA&quot;</span>, <span class="string">&quot;percent.mt&quot;</span>), ncol = <span class="number">3</span>)</span><br><span class="line"><span class="comment"># density</span></span><br><span class="line">data&lt;-tissu1@meta.data</span><br><span class="line">library(ggplot2)</span><br><span class="line">p&lt;-ggplot(data = data,aes(x=nFeature_RNA))+geom_density()</span><br><span class="line">p</span><br><span class="line"></span><br><span class="line"><span class="comment"># FeatureScatter is typically used to visualize feature-feature relationships, but can be used</span></span><br><span class="line"><span class="comment"># for anything calculated by the object, i.e. columns in object metadata, PC scores etc.</span></span><br><span class="line">plot1 &lt;- FeatureScatter(tissu1, feature1 = <span class="string">&quot;nCount_RNA&quot;</span>, feature2 = <span class="string">&quot;percent.mt&quot;</span>)</span><br><span class="line">plot2 &lt;- FeatureScatter(tissu1, feature1 = <span class="string">&quot;nCount_RNA&quot;</span>, feature2 = <span class="string">&quot;nFeature_RNA&quot;</span>)</span><br><span class="line">plot1 + plot2</span><br></pre></td></tr></table></figure>
<p>这里我们主要展示数据<strong>过滤前</strong>nFeature_RNA, nCount_RNA, percent.mt的情况</p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/pre_filter.png" width="50%">


<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Seurat官网给出的质控标准中，percent.mt &lt; 5，但不同组织不同细胞中线粒体含量存在差异,要根据自己的具体情况进行调整，</span></span><br><span class="line"><span class="comment">#但是！！！太夸张啦！太夸张啦！我们这里线粒体基因阈值设置在80%，最终得到的细胞数为9796个，如果设置成95%，得到的细胞数也小于原文中的10699。太夸张啦！为了复现文章，我们先定成80。</span></span><br><span class="line">tissu1 &lt;- subset(tissu1, subset = nFeature_RNA &gt; <span class="number">200</span> &amp; nFeature_RNA &lt; <span class="number">2500</span> &amp; percent.mt &lt; <span class="number">80</span>)</span><br><span class="line">tissu1</span><br><span class="line">VlnPlot(tissu1, features = <span class="built_in">c</span>(<span class="string">&quot;nFeature_RNA&quot;</span>, <span class="string">&quot;nCount_RNA&quot;</span>, <span class="string">&quot;percent.mt&quot;</span>), ncol = <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>这里我们主要展示数据<strong>过滤后</strong>nFeature_RNA, nCount_RNA, percent.mt的情况<br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/aft_filter.png" width="50%"></p>
<h1 id="Step-3、标准化"><a href="#Step-3、标准化" class="headerlink" title="Step 3、标准化"></a>Step 3、标准化</h1><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">## =============== Normalization</span></span><br><span class="line">tissu1 &lt;- NormalizeData(tissu1, normalization.method = <span class="string">&quot;LogNormalize&quot;</span>, scale.factor = <span class="number">10000</span>)</span><br><span class="line"><span class="comment">#标准化后的值保存在tissu1[[&quot;RNA&quot;]]@data</span></span><br><span class="line">normalized.data&lt;-tissu1[[<span class="string">&quot;RNA&quot;</span>]]@data</span><br><span class="line">normalized.data[<span class="number">1</span>:<span class="number">10</span>,<span class="number">1</span>:<span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<h1 id="Step-4、鉴定高变基因"><a href="#Step-4、鉴定高变基因" class="headerlink" title="Step 4、鉴定高变基因"></a>Step 4、鉴定高变基因</h1><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">## =============== Identification of highly variable features</span></span><br><span class="line"><span class="comment">#Seurat官方默认找前2000高变基因，用于下游的PCA降维分析</span></span><br><span class="line"><span class="comment">#文章中作者是找的前2500，我们这里也就找前2500个高变基因</span></span><br><span class="line"><span class="comment">#高变基因：在一些细胞中高表达，在另一些细胞中低表达</span></span><br><span class="line"><span class="comment">#变异指标：mean-variance relationship</span></span><br><span class="line">tissu1 &lt;- FindVariableFeatures(tissu1, selection.method = <span class="string">&quot;vst&quot;</span>, nfeatures = <span class="number">2500</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Identify the 10 most highly variable genes</span></span><br><span class="line">top10 &lt;- head(VariableFeatures(tissu1), <span class="number">10</span>)</span><br><span class="line">top10</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot variable features with and without labels</span></span><br><span class="line">plot1 &lt;- VariableFeaturePlot(tissu1)</span><br><span class="line">plot2 &lt;- LabelPoints(plot = plot1, points = top10, repel = <span class="literal">TRUE</span>)</span><br><span class="line">plot1 + plot2</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/top_10_highly_variable_genes.png"/>



<h1 id="Step-5、降维"><a href="#Step-5、降维" class="headerlink" title="Step 5、降维"></a>Step 5、降维</h1><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">## =============== 1. Scaling the data</span></span><br><span class="line"><span class="comment">#Seurat默认是做前2000个基因的归一化</span></span><br><span class="line"><span class="comment">#如何有热图展示需求的小伙伴，可以做全部基因的归一化，方便后续分析，我们这里就全部基因进行归一化</span></span><br><span class="line">all.genes &lt;- rownames(tissu1)</span><br><span class="line">tissu1 &lt;- ScaleData(tissu1, features = all.genes)</span><br><span class="line"></span><br><span class="line"><span class="comment">## =============== 2. PCA降维</span></span><br><span class="line">tissu1 &lt;- RunPCA(tissu1, features = VariableFeatures(object = tissu1))</span><br><span class="line"><span class="comment"># Examine and visualize PCA results a few different ways</span></span><br><span class="line">print(tissu1[[<span class="string">&quot;pca&quot;</span>]], dims = <span class="number">1</span>:<span class="number">5</span>, nfeatures = <span class="number">5</span>)</span><br><span class="line"><span class="comment">#visualization</span></span><br><span class="line">VizDimLoadings(tissu1, dims = <span class="number">1</span>:<span class="number">2</span>, reduction = <span class="string">&quot;pca&quot;</span>)</span><br><span class="line">DimPlot(tissu1, reduction = <span class="string">&quot;pca&quot;</span>)</span><br><span class="line">DimHeatmap(tissu1, dims = <span class="number">1</span>, cells = <span class="number">500</span>, balanced = <span class="literal">TRUE</span>)</span><br><span class="line">DimHeatmap(tissu1, dims = <span class="number">1</span>:<span class="number">20</span>, cells = <span class="number">500</span>, balanced = <span class="literal">TRUE</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## =============== 3. PC个数的确定</span></span><br><span class="line"><span class="comment">#这个非常非常具有挑战性，针对这个问题有很多教程,我们这里不着重讨论，因为我们主要是图表复现</span></span><br><span class="line"><span class="comment"># <span class="doctag">NOTE:</span> This process can take a long time for big datasets, comment out for expediency. More</span></span><br><span class="line"><span class="comment"># approximate techniques such as those implemented in ElbowPlot() can be used to reduce</span></span><br><span class="line"><span class="comment"># computation time</span></span><br><span class="line">tissu1 &lt;- JackStraw(tissu1, num.replicate = <span class="number">100</span>)</span><br><span class="line">tissu1 &lt;- ScoreJackStraw(tissu1, dims = <span class="number">1</span>:<span class="number">20</span>)</span><br><span class="line">JackStrawPlot(tissu1, dims = <span class="number">1</span>:<span class="number">20</span>)</span><br><span class="line">ElbowPlot(tissu1)</span><br></pre></td></tr></table></figure>
<h1 id="Step-6、细胞聚类"><a href="#Step-6、细胞聚类" class="headerlink" title="Step 6、细胞聚类"></a>Step 6、细胞聚类</h1><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">## =============== 细胞聚类</span></span><br><span class="line">tissu1 &lt;- FindNeighbors(tissu1, dims = <span class="number">1</span>:<span class="number">10</span>)</span><br><span class="line"><span class="comment">#为了和原文聚类结果尽量一致，设置resolution = 0.02，这个数值是试出来的，resolution值越大，聚类数越多</span></span><br><span class="line">tissu1 &lt;- FindClusters(tissu1, resolution = <span class="number">0.02</span>)</span><br><span class="line"><span class="comment"># Look at cluster IDs of the first 5 cells</span></span><br><span class="line">head(Idents(tissu1), <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看每个类别多少个细胞</span></span><br><span class="line">head(tissu1@meta.data)</span><br><span class="line">table(tissu1@meta.data$seurat_clusters)</span><br><span class="line"></span><br><span class="line"><span class="comment"># If you haven&#x27;t installed UMAP, you can do so via reticulate::py_install(packages =</span></span><br><span class="line"><span class="comment"># &#x27;umap-learn&#x27;)</span></span><br><span class="line">tissu1 &lt;- RunUMAP(tissu1, dims = <span class="number">1</span>:<span class="number">10</span>)</span><br><span class="line"><span class="comment"># note that you can set `label = TRUE` or use the LabelClusters function to help label</span></span><br><span class="line"><span class="comment"># individual clusters</span></span><br><span class="line">DimPlot(tissu1, reduction = <span class="string">&quot;umap&quot;</span>,label = <span class="built_in">T</span>,label.size = <span class="number">5</span>)</span><br><span class="line"><span class="comment">#也可以tsne的方式展示细胞分区，但是umap给出的空间分布信息是有意义的，所以更倾向与使用umap</span></span><br><span class="line"><span class="comment">#tissu1 &lt;- RunTSNE(tissu1, dims = 1:10)</span></span><br><span class="line"><span class="comment">#DimPlot(tissu1, reduction = &quot;tsne&quot;,label = T,label.size = 5)</span></span><br></pre></td></tr></table></figure>
<p><strong>聚类结果，一共5个群</strong></p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/UMAP_cluster5_new.png"/>


<h1 id="Step-7、差异表达"><a href="#Step-7、差异表达" class="headerlink" title="Step 7、差异表达"></a>Step 7、差异表达</h1><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">## =============== 差异表达及细胞类型鉴定</span></span><br><span class="line"><span class="comment"># find markers for every cluster compared to all remaining cells, report only the positive ones</span></span><br><span class="line">tissu1.markers &lt;- FindAllMarkers(tissu1, only.pos = <span class="literal">TRUE</span>, min.pct = <span class="number">0.25</span>, logfc.threshold = <span class="number">0.25</span>)</span><br><span class="line">write.csv(tissu1.markers,file = <span class="string">&quot;tissu1.markers.csv&quot;</span>)</span><br><span class="line"><span class="comment">#展示每一个cluster中top2显著的marker</span></span><br><span class="line">tissu1.markers %&gt;% group_by(cluster) %&gt;% top_n(n = <span class="number">2</span>, wt = avg_log2FC)</span><br></pre></td></tr></table></figure>
<p><strong>可视化特异性marker基因</strong></p>
<p><strong>1、 首先看一下文章中给出的marker基因</strong></p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/marker_genes_for_total.JPG" width="90%">

<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">markergene&lt;-<span class="built_in">c</span>(<span class="string">&quot;KRT5&quot;</span>,<span class="string">&quot;PTPRC&quot;</span>,<span class="string">&quot;CLU&quot;</span>,<span class="string">&quot;AQP1&quot;</span>,<span class="string">&quot;COL3A1&quot;</span>,<span class="string">&quot;COL1A2&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>2、 根据上表将marker基因映射到亚群上，以此确定不同亚群的具体细胞类型</strong></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#umap可视化</span></span><br><span class="line"><span class="comment">#根据文章supplementary table 1中提供的亚群的marker gene信息，在此绘制表达图谱</span></span><br><span class="line">FeaturePlot(tissu1, features = <span class="built_in">c</span>(<span class="string">&quot;KRT5&quot;</span>, <span class="string">&quot;PTPRC&quot;</span>, <span class="string">&quot;CLU&quot;</span>, <span class="string">&quot;AQP1&quot;</span>, <span class="string">&quot;COL3A1&quot;</span>, <span class="string">&quot;COL1A2&quot;</span>))</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/plot_marker_on_UMAP_new.png"/>

<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#小提琴图可视化</span></span><br><span class="line">library(ggplot2)</span><br><span class="line">plot_list&lt;-<span class="built_in">list</span>()</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>:<span class="number">5</span>) &#123;</span><br><span class="line">  p=VlnPlot(tissu1,features = markergene[i])+NoLegend()</span><br><span class="line">  print(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/KRT5.png" width="30%">
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/PTPRC.png" width="30%">
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/CLU.png" width="30%">
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/AQP1.png" width="30%">
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/COL3A1.png" width="30%">
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/COL1A2.png" width="30%">

<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#dotplot图可视化</span></span><br><span class="line">DotPlot(tissu1, features = markergene)+RotatedAxis()+</span><br><span class="line">  scale_x_discrete(<span class="string">&quot;&quot;</span>)+scale_y_discrete(<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/dotplot_marker.png"/>

<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#细胞亚群占比统计</span></span><br><span class="line">cluster&lt;-<span class="built_in">c</span>(<span class="string">&quot;Cancer cell&quot;</span>,<span class="string">&quot;Immune cell&quot;</span>,<span class="string">&quot;Epithelial cells&quot;</span>,<span class="string">&quot;Endothelial cells&quot;</span>,<span class="string">&quot;Fibroblasts&quot;</span>)</span><br><span class="line"></span><br><span class="line">subset_cell&lt;-<span class="built_in">c</span>()</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>:<span class="number">5</span>) &#123;</span><br><span class="line">  subset_cell=<span class="built_in">c</span>(subset_cell,<span class="built_in">dim</span>(tissu1[,Idents(tissu1)%in%<span class="built_in">c</span>(cluster[i])])[<span class="number">2</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subset_account&lt;-<span class="built_in">c</span>()</span><br><span class="line">total_cells&lt;-<span class="built_in">dim</span>(tissu1)[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>:<span class="number">5</span>) &#123;</span><br><span class="line">  subset_account=<span class="built_in">c</span>(subset_account,subset_cell[i]/total_cells)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subset_account&lt;-subset_account*<span class="number">100</span></span><br><span class="line">per.cell &lt;- paste(cluster,<span class="string">&quot;: &quot;</span>,<span class="built_in">ceiling</span>(subset_account),<span class="string">&quot;%&quot;</span>,sep = <span class="string">&quot;&quot;</span>)</span><br><span class="line">pie(subset_account,labels=per.cell) </span><br></pre></td></tr></table></figure>
<p><strong>文章中的各亚群占比</strong></p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/subset_account_paper.JPG"/>

<p><strong>我们的计算结果如下，结果显示我们的计算结果和原文结果类似</strong></p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/pie.JPG" width="60%">







<h1 id="Step-8、细胞亚群命名"><a href="#Step-8、细胞亚群命名" class="headerlink" title="Step 8、细胞亚群命名"></a>Step 8、细胞亚群命名</h1><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">## =============== 细胞类型鉴定</span></span><br><span class="line">new.cluster.ids &lt;- <span class="built_in">c</span>(<span class="string">&quot;Cancer cell&quot;</span>, <span class="comment">#&quot;KRT5&quot;</span></span><br><span class="line">                     <span class="string">&quot;Immune cell&quot;</span>, <span class="comment">#&quot;PTPRC&quot;</span></span><br><span class="line">                     <span class="string">&quot;Epithelial cells&quot;</span>, <span class="comment">#&quot;CLU&quot;</span></span><br><span class="line">                     <span class="string">&quot;Endothelial cells&quot;</span>, <span class="comment">#&quot;AQP1&quot;</span></span><br><span class="line">                     <span class="string">&quot;Fibroblasts&quot;</span>) <span class="comment">#&quot;COL3A1&quot;, &quot;COL1A2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">names</span>(new.cluster.ids) &lt;- <span class="built_in">c</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>)</span><br><span class="line">tissu1 &lt;- RenameIdents(tissu1, new.cluster.ids)</span><br><span class="line">DimPlot(tissu1, reduction = <span class="string">&quot;umap&quot;</span>, label = <span class="literal">TRUE</span>, pt.size = <span class="number">0.5</span>) + NoLegend()</span><br></pre></td></tr></table></figure>
<p><strong>我们的聚类结果</strong></p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/UMAP_cluster5_lable_new.png"/>

<p><strong>原文的聚类结果</strong></p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/paper_total_cluster.JPG"/>


<h1 id="Step-9、细胞亚群提取及再分群"><a href="#Step-9、细胞亚群提取及再分群" class="headerlink" title="Step 9、细胞亚群提取及再分群"></a>Step 9、细胞亚群提取及再分群</h1><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">## =============== </span></span><br><span class="line"><span class="comment">#肿瘤细胞的提取，下面两种方式都可以实现特定亚群的提取</span></span><br><span class="line">Cancer_cell&lt;-tissu1[,tissu1@meta.data$seurat_clusters%in%<span class="built_in">c</span>(<span class="number">0</span>)]</span><br><span class="line"><span class="comment">#Cancer_cell&lt;-tissu1[,Idents(tissu1)%in%c(&quot;Cancer cell&quot;)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#标准化之前</span></span><br><span class="line">Cancer_cell &lt;- NormalizeData(Cancer_cell, normalization.method = <span class="string">&quot;LogNormalize&quot;</span>, scale.factor = <span class="number">10000</span>) </span><br><span class="line">Cancer_cell &lt;- FindVariableFeatures(Cancer_cell, selection.method = <span class="string">&#x27;vst&#x27;</span>, nfeatures = <span class="number">2000</span>)</span><br><span class="line"><span class="comment"># Identify the 10 most highly variable genes</span></span><br><span class="line">top10 &lt;- head(VariableFeatures(Cancer_cell), <span class="number">10</span>)</span><br><span class="line">top10</span><br><span class="line"></span><br><span class="line">Cancer_cell &lt;- ScaleData(Cancer_cell, vars.to.regress = <span class="string">&quot;percent.mt&quot;</span>)</span><br><span class="line">Cancer_cell &lt;- RunPCA(Cancer_cell, features = VariableFeatures(object = Cancer_cell)) </span><br><span class="line">DimHeatmap(Cancer_cell, dims = <span class="number">1</span>:<span class="number">20</span>, cells = <span class="number">500</span>, balanced = <span class="literal">TRUE</span>)</span><br><span class="line">Cancer_cell &lt;- FindNeighbors(Cancer_cell, dims = <span class="number">1</span>:<span class="number">10</span>)</span><br><span class="line">Cancer_cell &lt;- FindClusters(Cancer_cell, resolution = <span class="number">0.3</span>)</span><br><span class="line">Cancer_cell &lt;- RunUMAP(Cancer_cell, dims = <span class="number">1</span>:<span class="number">10</span>)</span><br><span class="line">DimPlot(Cancer_cell, reduction = <span class="string">&#x27;umap&#x27;</span>,label = <span class="built_in">T</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#cluster Keratinocyte Cancer</span></span><br><span class="line">FeaturePlot(Cancer_cell, features = <span class="built_in">c</span>(<span class="string">&quot;SPRR3&quot;</span>,<span class="string">&quot;SPRR1A&quot;</span>,<span class="string">&quot;NCCRP1&quot;</span>,<span class="string">&quot;TMPRSS11E&quot;</span>,<span class="string">&quot;APOBEC3A&quot;</span>))</span><br></pre></td></tr></table></figure>
<p><strong>绞尽脑汁，一顿操作，最后还是没有办法很好的复现原文的数据，但是其中一个亚群有较好的聚类出来。</strong></p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/Keratinocyte_cancer_cluster.png"/>


<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>1、单细胞数据复现可以提升自己对此类数据的理解和掌握。<br>2、不同人处理单细胞数据时设置的参数会有所不同，作者并没有在文章中给出太多相关信息，导致最终的结果有所不同。<br>3、单细胞亚群个数的确定以及类群注释需要非常强的生物学背景。<br>4、 要学的东西太多了，一点点的来，不求快，但求稳，加油💪</p>
</blockquote>
]]></content>
      <tags>
        <tag>tag1</tag>
      </tags>
  </entry>
  <entry>
    <title>scRNA-seq数据分析学习（一）</title>
    <url>/2020/02/13/scRNA-seq%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>用常规转录组的知识对scRNA-seq数据进行初步探索</p>
<a id="more"></a>

<h1 id="scRNA-seq数据分析学习（一）"><a href="#scRNA-seq数据分析学习（一）" class="headerlink" title="scRNA-seq数据分析学习（一）"></a>scRNA-seq数据分析学习（一）</h1><table><tr><td bgcolor=GreenYellow>用常规转录组的知识对scRNA-seq数据进行初步探索</td></tr></table>
  
**bulk RNA-seq和scRNA-seq的区别**  
http://www.bio-info-trainee.com/2548.html  
- 样本量，基因数量导致统计学环境的变化  
  通常情况下样本量都是成千上万的，检测的基因数量相对常规转录组较少
- 计算量迫使算法需要优化  
  成千上万甚至几十万的样本量对计算要求非常高  
- 待解决的生物问题有所不同  
  1. 不仅仅是不同状态的不同，一个样本就是一个因素
  2. 细胞、组织间的异质性问题
  3. 探究变化的过程追踪和重现
- 相对常规转录组而言，scRNA-seq分析流程软件工具的成熟度有待提高，目前还没有对整个分析流程的金标准   

<p><strong>单细胞差异基因表达统计学方法</strong>  </p>
<ul>
<li>归一化</li>
<li>聚类分群</li>
<li>重要基因挑选<ol>
<li>差异基因</li>
<li>marker基因</li>
<li>变异基因</li>
</ol>
</li>
</ul>
<h2 id="安装并加载scRNAseq这个R包"><a href="#安装并加载scRNAseq这个R包" class="headerlink" title="安装并加载scRNAseq这个R包"></a>安装并加载scRNAseq这个R包</h2><p>R包<strong>scRNAseq</strong>内含数据集，下载安装加载相应的辅助R包来探索<strong>scRNAseq</strong>的内置数据集，对单细胞转录组分析进行初步探索（在此之前已经下载好了所需的R包）<br><strong>下载R包</strong></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#如果没有所需R包，可以用以下方法进行下载(用两个R包为例)</span></span><br><span class="line">options()$repos <span class="comment">#查看使用install.packages安装的默认镜像</span></span><br><span class="line">options(<span class="string">&quot;repos&quot;</span>=<span class="built_in">c</span>(CRAN=<span class="string">&quot;https://mirrors.tuna.tsinghua.edu.cn/CRAN/&quot;</span>))<span class="comment">#指定install.packages安装镜像为清华镜像</span></span><br><span class="line">options()$repos</span><br><span class="line">options()$BioC_mirror<span class="comment">#查看使用bioconductor的默认镜像</span></span><br><span class="line">options(BioC_mirror=<span class="string">&quot;https://mirrors.ustc.edu.cn/bioc/&quot;</span>)<span class="comment">#指定Bioconductor安装默认镜像为中科大镜像</span></span><br><span class="line">options()$BioC_mirror</span><br><span class="line">(!requireNamespace(<span class="string">&quot;Rtsne&quot;</span>))<span class="comment">#查看是否存在Rtsne这个包</span></span><br><span class="line">install.packages(<span class="string">&quot;Rtsne&quot;</span>)<span class="comment">#如果Rtsne包不存在，就下载这个R包</span></span><br><span class="line"><span class="comment">#CRAN是R默认使用的R包仓库，install.packages()只能用于安装发布在CRAN上的包</span></span><br><span class="line"><span class="comment">#Bioconductor是基因组数据分析相关的软件仓库包</span></span><br><span class="line">(!requireNamespace(<span class="string">&quot;BiocManager&quot;</span>))</span><br><span class="line">install.packages(<span class="string">&quot;BiocManager&quot;</span>)<span class="comment">#install.packages()是安装Bioconductor软件包的命令</span></span><br><span class="line">(!requireNamespace(<span class="string">&quot;scRNAseq&quot;</span>))</span><br><span class="line">BiocManager::install(<span class="string">&quot;scRNAseq&quot;</span>)</span><br></pre></td></tr></table></figure>


<p><strong>加载R包</strong></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#suppressMessages(library(Rtsne)) suppressMessages()函数是加载R包的时候不显示说明信息</span></span><br><span class="line">library(Rtsne)</span><br><span class="line">library(FactoMineR)</span><br><span class="line">library(factoextra)</span><br><span class="line">library(scater)</span><br><span class="line">library(scRNAseq)</span><br><span class="line">library(M3Drop)</span><br><span class="line">library(ROCR)</span><br><span class="line">library(tidyr)</span><br><span class="line">library(cowplot)</span><br><span class="line">library(ggplot2)</span><br></pre></td></tr></table></figure>
<h2 id="scRNA-seq包中的数据集"><a href="#scRNA-seq包中的数据集" class="headerlink" title="scRNA-seq包中的数据集"></a>scRNA-seq包中的数据集</h2><p>这个内置的是Pollen et al.2014年数据集，人类单细胞数据，分为4类：NPC、GW16、GW21、GW21+3。此R包只提供了4种细胞类型，完整的数据是23730 features，301 samples。<br>这里面的表达矩阵是有RSEM(Li and Dewey 2011)软件根据hg38 RefSeq transcription得到的，总共130个文库。每个细胞测了2次。测序深度不一样。  </p>
<p><strong>载入R包scRNA-seq</strong></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(scRNAseq)</span><br><span class="line">data(fluidigm)</span><br><span class="line">ct&lt;-<span class="built_in">floor</span>(assays(fluidigm)$rsem_counts)<span class="comment">#assays函数拿到表达矩阵，rsem_counts有小数，所以floor</span></span><br><span class="line">ct[<span class="number">1</span>:<span class="number">4</span>,<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line"><span class="built_in">dim</span>(ct) <span class="comment">#[1] 26255   130</span></span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/datapartial.JPG"/>


<p><strong>接下来的代码初步探索scRNA-seq内置数据集的各个属性</strong></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">sample_ann&lt;-as.data.frame(colData(fluidigm))<span class="comment">#得到130个样本的28个临床信息</span></span><br><span class="line"><span class="comment">#利用lapply针对sample_ann中的前19个属性（数值型的）进行批量处理，一次性展示</span></span><br><span class="line">box&lt;-lapply(colnames(sample_ann[,<span class="number">1</span>:<span class="number">19</span>]), <span class="keyword">function</span>(i)&#123;</span><br><span class="line">  dat&lt;-sample_ann[,i,drop=<span class="built_in">F</span>]</span><br><span class="line">  dat$sample=rownames(dat)</span><br><span class="line">  ggplot(dat,aes(<span class="string">&#x27;all cells&#x27;</span>,get(i))) +geom_boxplot() +xlab(<span class="literal">NULL</span>) +ylab(i) +theme_classic()</span><br><span class="line">&#125;)</span><br><span class="line">plot_grid(plotlist = box,ncol = <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/ggplot19.JPG"/>


<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">##基因表达情况的初步探索</span></span><br><span class="line">counts&lt;-ct</span><br><span class="line">table((apply(counts, <span class="number">1</span>, <span class="keyword">function</span>(x) <span class="built_in">sum</span>(x&gt;<span class="number">0</span>))))<span class="comment">#查看基因的详细表达情况</span></span><br><span class="line">table((apply(counts, <span class="number">1</span>, <span class="keyword">function</span>(x) <span class="built_in">sum</span>(x&gt;<span class="number">0</span>)&gt;<span class="number">0</span>)))<span class="comment">#查看至少有一个样本表达某个基因的总体情况</span></span><br><span class="line">boxplot(apply(counts, <span class="number">1</span>, <span class="keyword">function</span>(x) <span class="built_in">sum</span>(x&gt;<span class="number">0</span>)))</span><br><span class="line">hist(apply(counts,<span class="number">2</span>,<span class="keyword">function</span>(x) <span class="built_in">sum</span>(x&gt;<span class="number">0</span>)))<span class="comment">#可视化每个样本的基因表达情况</span></span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/countsapply1.JPG"/>

<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/countsapplybox1.JPG" width="40%" height="40%">


<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/geneexpression.JPG" width="60%" height="60%">

<p><strong>过滤（基因+细胞）</strong></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#过滤不满足某个条件的基因</span></span><br><span class="line"><span class="comment">#choosed_genes&lt;-apply(counts, 1, function(x) sum(x&gt;0))&gt;0#等价于choosed_genes&lt;-apply(counts, 1, function(x) sum(x&gt;0)&gt;0)</span></span><br><span class="line"><span class="comment">#table(choosed_genes)</span></span><br><span class="line"><span class="comment">#结果显示</span></span><br><span class="line"><span class="comment">#choosed_genes</span></span><br><span class="line"><span class="comment">#FALSE  TRUE </span></span><br><span class="line"><span class="comment">#9159 17096</span></span><br><span class="line"><span class="comment">#counts&lt;-counts[choosed_genes,]#过滤掉了在所有样本中都不表达的基因  </span></span><br><span class="line"><span class="comment">#同理也可以过滤掉不满足某个条件的细胞，apply函数中的1改为2，在设定特定的条件即可  </span></span><br><span class="line"><span class="comment">#在此，我们根据上述样本的boxplot图中展示的各个属性来进行简单过滤</span></span><br><span class="line"><span class="comment">#过滤没有统一的标准，根据自己对数据的要求，细节会很多，据不同情况而定</span></span><br><span class="line"><span class="comment">#这里进行简单的批量处理，不考虑太多</span></span><br><span class="line">filter&lt;-colnames(sample_ann[,<span class="built_in">c</span>(<span class="number">1</span>:<span class="number">9</span>,<span class="number">11</span>:<span class="number">16</span>,<span class="number">18</span>,<span class="number">19</span>)])</span><br><span class="line">tf&lt;-lapply(filter,<span class="keyword">function</span>(i)&#123;</span><br><span class="line">  <span class="comment">#i=filter[1]</span></span><br><span class="line">  dat&lt;-sample_ann[,i]</span><br><span class="line">  dat&lt;-<span class="built_in">abs</span>(log10(dat))</span><br><span class="line">  fivenum(dat)</span><br><span class="line">  (up&lt;-mean(dat)+<span class="number">2</span>*sd(dat))</span><br><span class="line">  (down&lt;-mean(dat)-<span class="number">2</span>*sd(dat))</span><br><span class="line">  valid&lt;-ifelse(dat&gt;down &amp; dat&lt;up,<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line">&#125;)</span><br><span class="line">tf&lt;-do.call(cbind,tf)</span><br><span class="line">choosed_cell&lt;-apply(tf, <span class="number">1</span>, <span class="keyword">function</span>(x) <span class="built_in">all</span>(x==<span class="number">1</span>))</span><br><span class="line">table(sample_ann$Biological_Condition)</span><br><span class="line">sample_ann=sample_ann[choosed_cell,]<span class="comment">#rownames(sample_ann)中的样本和rownames(tf)数字一一对应</span></span><br><span class="line">table(sample_ann$Biological_Condition)</span><br><span class="line">ct&lt;-ct[,choosed_cell]<span class="comment">#colnames(ct)和rownames(tf)的数字一一对应</span></span><br><span class="line"><span class="built_in">dim</span>(ct)<span class="comment">#26255个基因，99个样本</span></span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/filter.JPG"/>


<h2 id="探索基因的表达情况"><a href="#探索基因的表达情况" class="headerlink" title="探索基因的表达情况"></a>探索基因的表达情况</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ct[<span class="number">1</span>:<span class="number">4</span>,<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">counts&lt;-ct</span><br><span class="line">table(apply(counts, <span class="number">1</span>, <span class="keyword">function</span>(x) <span class="built_in">sum</span>(x&gt;<span class="number">0</span>)))</span><br><span class="line">fivenum(apply(counts, <span class="number">1</span>, <span class="keyword">function</span>(x) <span class="built_in">sum</span>(x&gt;<span class="number">0</span>)))</span><br><span class="line">boxplot(apply(counts, <span class="number">1</span>, <span class="keyword">function</span>(x) <span class="built_in">sum</span>(x&gt;<span class="number">0</span>)))</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/matrixexpression.JPG"/>

<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/boxplotgeneexpression.JPG" width="40%" height="40%">

<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#针对基因</span></span><br><span class="line">fivenum(apply(counts, <span class="number">2</span>, <span class="keyword">function</span>(x) <span class="built_in">sum</span>(x&gt;<span class="number">0</span>)))</span><br><span class="line">hist(apply(counts, <span class="number">2</span>, <span class="keyword">function</span>(x) <span class="built_in">sum</span>(x&gt;<span class="number">0</span>)))</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/fivenumgene.JPG"/>

<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/filtergeneexpression.JPG" width="60%" height="60%">


<p>R语言中fivenum函数介绍：<a href="https://blog.csdn.net/mr_muli/article/details/79616124">https://blog.csdn.net/mr_muli/article/details/79616124</a><br>R语言中do.call函数介绍：<a href="https://blog.csdn.net/zdx1996/article/details/87899029">https://blog.csdn.net/zdx1996/article/details/87899029</a><br>R语言all函数介绍：<a href="https://blog.csdn.net/scong123/article/details/70184038">https://blog.csdn.net/scong123/article/details/70184038</a></p>
<h2 id="利用常规转录组分析知识查看细胞间所有基因表达量的相关性"><a href="#利用常规转录组分析知识查看细胞间所有基因表达量的相关性" class="headerlink" title="利用常规转录组分析知识查看细胞间所有基因表达量的相关性"></a>利用常规转录组分析知识查看细胞间所有基因表达量的相关性</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">##下面的计算都是基于log后的表达矩阵</span></span><br><span class="line">dat&lt;-log2(edgeR::cpm(counts)+<span class="number">1</span>)</span><br><span class="line">dat[<span class="number">1</span>:<span class="number">4</span>,<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">dat_back&lt;-dat<span class="comment">#备份表达矩阵</span></span><br><span class="line">exprSet&lt;-dat_back</span><br><span class="line">colnames(exprSet)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/dat1_4.JPG"/>

<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/colnamesexprSet.JPG"/>

<p><strong>相关性可视化</strong></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">pheatmap::pheatmap(cor(exprSet))<span class="comment">#查看矩阵中个样本间的相关性</span></span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/pheatmap.JPG"/>


<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#加上了分组信息注释,组内样本相似性应该高于组间样本相似性</span></span><br><span class="line">group_list&lt;-sample_ann$Biological_Condition</span><br><span class="line">tmp&lt;-data.frame(group=group_list)</span><br><span class="line">rownames(tmp)&lt;-rownames(sample_ann)</span><br><span class="line">pheatmap::pheatmap(cor(exprSet),annotation_col = tmp)<span class="comment">#加上了分组信息注释</span></span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/annotationpheatmap.JPG"/>


<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#去除掉小于5个样本表达的基因</span></span><br><span class="line"><span class="built_in">dim</span>(exprSet)</span><br><span class="line">exprSet=exprSet[apply(exprSet, <span class="number">1</span>, <span class="keyword">function</span>(x) <span class="built_in">sum</span>(x&gt;<span class="number">1</span>)&gt;<span class="number">5</span>),]</span><br><span class="line"><span class="built_in">dim</span>(exprSet)</span><br><span class="line">pheatmap::pheatmap(cor(exprSet),annotation_col = tmp)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/filter5sampleplusgene.JPG"/>

<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/filter5sampleplusgenepheatmap.JPG"/>


<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#选取前500个差异最大的基因</span></span><br><span class="line">exprSet&lt;-exprSet[<span class="built_in">names</span>(sort(apply(exprSet, <span class="number">1</span>, mad),decreasing = <span class="built_in">T</span>)[<span class="number">1</span>:<span class="number">500</span>]),]</span><br><span class="line"><span class="built_in">dim</span>(exprSet)</span><br><span class="line">exprSet[<span class="number">1</span>:<span class="number">4</span>,<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">M&lt;-cor(log2(exprSet+<span class="number">1</span>))</span><br><span class="line">tmp&lt;-data.frame(group=group_list)</span><br><span class="line">rownames(tmp)&lt;-colnames(M)</span><br><span class="line">pheatmap::pheatmap(M,annotation_col = tmp)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/500pheatmap.JPG"/>


<ul>
<li><strong>有热图分析可知，从细胞的相关性角度来看，NPC跟另外的GW细胞群可以区分得很好，但是GW本身得3个小群并没有那么好得区分度</strong>  </li>
<li><strong>简单的选取top的sd的基因来计算相关性，并没有明显的改善</strong>  </li>
</ul>
<h2 id="首先对表达矩阵进行简单的层次聚类"><a href="#首先对表达矩阵进行简单的层次聚类" class="headerlink" title="首先对表达矩阵进行简单的层次聚类"></a>首先对表达矩阵进行简单的层次聚类</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">hc&lt;-hclust(dist(t(dat))) <span class="comment">#次dat是上述经过过滤的，剩下99个细胞样本的数据</span></span><br><span class="line">plot(hc,labels = <span class="literal">FALSE</span>)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/hc.JPG"/>

<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">clus&lt;-cutree(hc,<span class="number">4</span>)<span class="comment">#对hclust()函数的聚类结果进行剪枝，即选择输出指定类别的系谱聚类结果</span></span><br><span class="line">group_list&lt;-as.factor(clus)<span class="comment">#转换为因子</span></span><br><span class="line">table(group_list)<span class="comment">#统计频数</span></span><br><span class="line">table(group_list,sample_ann$Biological_Condition)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/hclustandbiocondition.JPG"/>

<p><strong>可以看到如果是普通的层次聚类的话，GW16、GW21、GW21+3是很难区分开的</strong>  </p>
<h2 id="看看常规PCA的结果"><a href="#看看常规PCA的结果" class="headerlink" title="看看常规PCA的结果"></a>看看常规PCA的结果</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">dat&lt;-dat_back</span><br><span class="line">dat&lt;-t(dat)</span><br><span class="line">dat&lt;-as.data.frame(dat)</span><br><span class="line">anno&lt;-sample_ann$Biological_Condition</span><br><span class="line">dat&lt;-cbind(dat,anno)</span><br><span class="line">dat[<span class="number">1</span>:<span class="number">4</span>,<span class="number">26254</span>:<span class="number">26256</span>]</span><br><span class="line">table(dat$anno)</span><br><span class="line">dat.pca&lt;-PCA(dat[,-ncol(dat)],graph = <span class="literal">FALSE</span>)<span class="comment">#PCA分析之前先去掉变量即新增加的分组信息anno</span></span><br><span class="line">head(dat.pca$var$coord)<span class="comment">#每个组成份的基因重要性占比</span></span><br><span class="line">head(dat.pca$ind$coord)<span class="comment">#每个细胞的前5个主成分取值</span></span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/prePCA.JPG"/>


<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">fviz_pca_ind(</span><br><span class="line">  dat.pca,</span><br><span class="line">  geom.ind = <span class="string">&quot;point&quot;</span>,</span><br><span class="line">  col.ind = dat$anno,</span><br><span class="line">  <span class="comment">#color by groups</span></span><br><span class="line">  addEllipses = <span class="literal">TRUE</span>,</span><br><span class="line">  legend.title=<span class="string">&quot;groups&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/PCA.JPG"/>
**同样的，NPC和其他类型细胞区分得很好，但GW本身得3个小群体并没有很好得区分度**

<h2 id="tSNE降维结果"><a href="#tSNE降维结果" class="headerlink" title="tSNE降维结果"></a>tSNE降维结果</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">##tSNE降维</span></span><br><span class="line"><span class="comment">#dat_matrix&lt;-dat_back 原始数据会比较耗时，结果就不展示了</span></span><br><span class="line">dat_matrix&lt;-dat.pca$ind$coord</span><br><span class="line">library(Rtsne)</span><br><span class="line">set.seed(<span class="number">42</span>)</span><br><span class="line">tsne_out&lt;-Rtsne(dat_matrix,perplexity = <span class="number">10</span>,check_duplicates = <span class="literal">FALSE</span>)</span><br><span class="line">plate&lt;-sample_ann$Biological_Condition</span><br><span class="line">plot(tsne_out$Y,col=rainbow(<span class="number">4</span>)[<span class="built_in">as.numeric</span>(as.factor(plate))])</span><br></pre></td></tr></table></figure>

<p>参考资料<br><strong>生信菜鸟团</strong>：<a href="http://www.bio-info-trainee.com/">http://www.bio-info-trainee.com/</a><br><strong>生信技能树</strong>：<a href="http://www.biotrainee.com/">http://www.biotrainee.com/</a><br><strong>R包的下载方法</strong>：<a href="https://www.jianshu.com/p/8e0dece51757">https://www.jianshu.com/p/8e0dece51757</a></p>
]]></content>
      <tags>
        <tag>NGS</tag>
      </tags>
  </entry>
  <entry>
    <title>scRNA-seq数据分析学习（三）</title>
    <url>/2020/02/15/scRNA-seq%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<p>学习R包seurat对scRNA-seq数据进行分析</p>
<a id="more"></a>

<h1 id="scRNA-seq数据分析（三）"><a href="#scRNA-seq数据分析（三）" class="headerlink" title="scRNA-seq数据分析（三）"></a>scRNA-seq数据分析（三）</h1><p>😊seurat不是一个R包，seurat是一个优秀的R包<br>😊seurat不是提供服务的，seurat是提供一条龙服务的   </p>
<ul>
<li>seurat版本有2.×.×和3.×.×。同一般的R包升级不太一样的是：2.×和3.×之间区别还是蛮多的，各种函数也都有变化，虽然升级带来了更多的优点，但是函数名称的变化就会给学习者带来不小的麻烦呀！</li>
<li>这里先学习2.×。为什么呢？因为我还不会3.×呀😵😏😜</li>
</ul>
<p><strong>载入R包</strong></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">rm(<span class="built_in">list</span> = ls())<span class="comment">#clear the environment</span></span><br><span class="line">options(warn=-<span class="number">1</span>)<span class="comment">#turn off warning message globally</span></span><br><span class="line">library(Seurat)</span><br></pre></td></tr></table></figure>
<p><strong>同样使用scRNAseq内置数据集</strong>  </p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(scRNAseq)</span><br><span class="line">data(fluidigm)<span class="comment">#加载测试数据</span></span><br><span class="line">assay(fluidigm)&lt;-assays(fluidigm)$rsem_counts</span><br><span class="line">ct&lt;-<span class="built_in">floor</span>(assays(fluidigm)$rsem_counts)</span><br><span class="line">ct[<span class="number">1</span>:<span class="number">4</span>,<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">counts&lt;-ct</span><br></pre></td></tr></table></figure>
<h2 id="创建Seurat要求的对象"><a href="#创建Seurat要求的对象" class="headerlink" title="创建Seurat要求的对象"></a>创建Seurat要求的对象</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="built_in">names</span>(metadata(fluidigm))</span><br><span class="line">meta&lt;-as.data.frame(colData(fluidigm))</span><br><span class="line">identical(rownames(meta),colnames(counts))<span class="comment">#检测meta和counts这两个对象，后面有需要</span></span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/identicalmetacounts.JPG"/>


<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">seu&lt;-CreateSeuratObject(raw.data = counts,</span><br><span class="line">                            meta.data = meta,</span><br><span class="line">                            min.cells = <span class="number">3</span>,</span><br><span class="line">                            min.genes = <span class="number">200</span>,</span><br><span class="line">                            project = <span class="string">&quot;seu&quot;</span>)</span><br><span class="line">seu</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/seu1.JPG"/>


<p><strong>增加相关属性信息</strong></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#增加线粒体基因信息，如果线粒体所占基因比例过高，意味着可能是死细胞</span></span><br><span class="line">mito.gene&lt;-grep(pattern = <span class="string">&quot;^MT-&quot;</span>,x=rownames(x=seu@data),value = <span class="literal">TRUE</span>)<span class="comment">#但是我们知道这个数据集里面并没有线粒体基因</span></span><br><span class="line">percent.mito&lt;-Matrix::colSums(seu@raw.data[mito.gene,])/Matrix::colSums(seu@raw.data)</span><br><span class="line">seu&lt;-AddMetaData(object = seu,metadata = percent.mito,col.name = <span class="string">&quot;percent.mito&quot;</span>)<span class="comment">#加入了线粒体基因的信息</span></span><br><span class="line"><span class="comment">#这里也可以加入ERCC等其他属性</span></span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/mitoinfo.JPG"/>


<h2 id="可视化（初步）"><a href="#可视化（初步）" class="headerlink" title="可视化（初步）"></a>可视化（初步）</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#可视化，meta信息里面存在分组变量，可以指定分组，scRNAseq数据集里的分组信息是&quot;Biological_Condition&quot;</span></span><br><span class="line">VlnPlot(object = seu,features.plot = <span class="built_in">c</span>(<span class="string">&quot;nGene&quot;</span>,<span class="string">&quot;nUMI&quot;</span>,<span class="string">&quot;percent.mito&quot;</span>),group.by = <span class="string">&#x27;Biological_Condition&#x27;</span>,nCol = <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/VlnPlot.JPG"/>


<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看一下某两个属性间的相关性</span></span><br><span class="line">GenePlot(object=seu,gene1=<span class="string">&quot;nUMI&quot;</span>,gene2=<span class="string">&quot;nGene&quot;</span>)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/GenePlotnUMInGene.JPG"/>


<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看基因间的相关性</span></span><br><span class="line">tail(sort(Matrix::rowSums(seu@raw.data)))</span><br><span class="line">GenePlot(object = seu,gene1 = <span class="string">&quot;SOX11&quot;</span>,gene2 = <span class="string">&quot;EEF1A1&quot;</span>)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/tailsortgene.JPG"/>

<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/GenePlotnUMInGene.JPG"/>


<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#细胞间的相关性，更好的方式是用cor()+heatmap展示</span></span><br><span class="line">CellPlot(seu,seu@cell.names[<span class="number">3</span>],seu@cell.names[<span class="number">5</span>],do.identify=<span class="literal">FALSE</span>)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/CellPlot.JPG"/>


<h2 id="表达矩阵归一化"><a href="#表达矩阵归一化" class="headerlink" title="表达矩阵归一化"></a>表达矩阵归一化</h2><p>只有进行归一化后，样本之间的比较才更能说明问题 </p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">identical(seu@raw.data,seu@data)</span><br><span class="line">seu&lt;-NormalizeData(object = seu,normalization.method = <span class="string">&quot;LogNormalize&quot;</span>,</span><br><span class="line">                   scale.factor = <span class="number">10000</span>,display.progress = <span class="built_in">F</span>)</span><br><span class="line"><span class="comment">#将每个细胞中总UMI设定为10000，计算方法为loge（每个细胞中基因的nUMI/该细胞内总UMI*10000+1）</span></span><br><span class="line"><span class="comment">#经过归一化后，seu对象里面的data被改变了</span></span><br><span class="line">identical(seu@raw.data,seu@data)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/normalizetruefalse.JPG"/>


<h2 id="寻找波动比较明显的基因，后续使用这些差异基因进行分析，主要为了降低计算量"><a href="#寻找波动比较明显的基因，后续使用这些差异基因进行分析，主要为了降低计算量" class="headerlink" title="寻找波动比较明显的基因，后续使用这些差异基因进行分析，主要为了降低计算量"></a>寻找波动比较明显的基因，后续使用这些差异基因进行分析，主要为了降低计算量</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">seu&lt;-FindVariableGenes(object = seu,mean.function = ExpMean,dispersion.function = LogVMR,</span><br><span class="line">                       x.low.cutoff = <span class="number">0.0125</span>,</span><br><span class="line">                       y.high.cutoff = <span class="number">3</span>,</span><br><span class="line">                       y.cutoff = <span class="number">0.5</span>)</span><br><span class="line"><span class="comment">#选择不同的阈值，得到的基因取决于实际情况</span></span><br><span class="line"><span class="built_in">length</span>(seu@var.genes)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/fvg.JPG"/>

<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/lengthfvg.JPG"/>


<h2 id="对归一化后的矩阵进行分群"><a href="#对归一化后的矩阵进行分群" class="headerlink" title="对归一化后的矩阵进行分群"></a>对归一化后的矩阵进行分群</h2><ul>
<li>对矩阵进行回归建模，以及scale</li>
<li>center=T：每个细胞中基因表达量-该基因在所有细胞中的表达量</li>
<li>scale=T：每个细胞中基因中心化后的表达值/该基因所在所有细胞中表达值的标准差</li>
<li>注意：执行ScaleData之前需要先执行NormalizeData</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">seu&lt;-ScaleData(object = seu,vars.to.regress = <span class="built_in">c</span>(<span class="string">&quot;nUMI&quot;</span>),display.progress = <span class="built_in">F</span>)<span class="comment">#在这里只去除了文库大小的影响</span></span><br></pre></td></tr></table></figure>
<h2 id="PCA降维"><a href="#PCA降维" class="headerlink" title="PCA降维"></a>PCA降维</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#采用上述的差异基因进行降维</span></span><br><span class="line">seu&lt;-RunPCA(object = seu,</span><br><span class="line">            pc.genes = seu@var.genes,</span><br><span class="line">            do.print = <span class="number">1</span>:<span class="number">5</span>,</span><br><span class="line">            genes.print = <span class="number">5</span>)</span><br><span class="line">seu@dr</span><br><span class="line"><span class="comment">#这样就能拿到PC的基因的重要性占比情况</span></span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/pcareduction.JPG"/>


<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">tmp&lt;-seu@dr$pca@gene.loadings</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/pcainfo.JPG"/>


<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#看一下前两个主成分的情况</span></span><br><span class="line">VizPCA(seu,pcs.use = <span class="number">1</span>:<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/pca1pca2.JPG"/>


<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">PCAPlot(seu,dim.1=<span class="number">1</span>,dim.2=<span class="number">2</span>,group.by=<span class="string">&#x27;Biological_Condition&#x27;</span>)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/pca1pca2BC.JPG"/>


<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#热图查看PC1的情况</span></span><br><span class="line">PCHeatmap(object = seu,pc.use = <span class="number">1</span>,cells.use = ncol(seu@data),do.balanced = <span class="literal">TRUE</span>,label.columns = <span class="literal">FALSE</span>)</span><br><span class="line"><span class="comment">#一次性展示前10个主成分在各样本间的体现情况</span></span><br><span class="line"><span class="comment">#PCHeatmap(object = seu,pc.use = 1:10,cells.use = ncol(seu@data),do.balanced = TRUE,label.columns = FALSE)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/PCA1heatmap.JPG"/>


<p>基于PCA情况看看细胞如何分群<br>重点：需要搞清楚<strong>resolution</strong>参数</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">seu&lt;-FindClusters(object = seu,</span><br><span class="line">                  reduction.type = <span class="string">&quot;pca&quot;</span>,</span><br><span class="line">                  dims.use = <span class="number">1</span>:<span class="number">10</span>,force.recalc = <span class="built_in">T</span>,</span><br><span class="line">                  resolution = <span class="number">0.9</span>,print.output = <span class="number">0</span>,</span><br><span class="line">                  save.SNN = <span class="literal">TRUE</span>)</span><br><span class="line">PrintFindClustersParams(seu)</span><br><span class="line">table(seu@meta.data$res.0.9)</span><br></pre></td></tr></table></figure>
<p><strong>resolution</strong>的值调得不一样，最后table出来得细胞亚群数也会不一样</p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/pcaresulution.JPG"/>


<h2 id="细胞分群后的tSNE图"><a href="#细胞分群后的tSNE图" class="headerlink" title="细胞分群后的tSNE图"></a>细胞分群后的tSNE图</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">seu&lt;-RunTSNE(object = seu,</span><br><span class="line">             dims.use = <span class="number">1</span>:<span class="number">10</span>,</span><br><span class="line">             do.fast=<span class="literal">TRUE</span>,</span><br><span class="line">             perplexity=<span class="number">10</span>)</span><br><span class="line">TSNEPlot(object = seu)<span class="comment">#由图看出，tSNE分出了3群，为什么呢？因为上面PCA降维出3各亚群呀！</span></span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/tsneafterpca.JPG"/>

<p><strong>同样是PCA降维算法得到得3各细胞亚群，tSNE明显展示出更好的试图效果</strong>  </p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">table(meta$Biological_Condition)</span><br><span class="line">table(meta$Biological_Condition,seu@meta.data$res.0.9)</span><br><span class="line"><span class="comment">#这里就有一个问题了：这里明明在探讨tSNR降维，为什么这里又用到了上面pca降维中所生成的参数res.0.9呢？</span></span><br><span class="line"><span class="comment">#有一个办法，就是先不进行pca降维，tSNE降维看看是否依然得到当前的数据</span></span><br><span class="line"><span class="comment">#问题来了，我验证了上一条猜想，结果呢：Error in GetDimReduction(object = object, reduction.type = reduction.use,  : </span></span><br><span class="line">                                        <span class="comment">#pca  dimensional reduction has not been computed</span></span><br><span class="line"><span class="comment">#所以呢，在这里的tSNE降维居然要用到PCA降维，嗯......表示不是很理解呀！两者不是独立的吗！？！？</span></span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/grouppcaBC.JPG"/>


<h2 id="对每个亚群寻找marker基因"><a href="#对每个亚群寻找marker基因" class="headerlink" title="对每个亚群寻找marker基因"></a>对每个亚群寻找marker基因</h2><p>下面的代码需要适时修改，因为每次分组都不一样，本次是3组，因为pca降维成3组<br><strong>以第一群细胞为例<code>ident.1 = 1</code></strong>  </p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">markers_df&lt;-FindMarkers(object = seu,ident.1 = <span class="number">1</span>,min.pct = <span class="number">0.25</span>)</span><br><span class="line">print(x=head(markers_df))</span><br><span class="line">markers_genes=rownames(head(x=markers_df,n=<span class="number">5</span>))</span><br><span class="line">vlnPlot(object=seu,features.plot=markers_genes,use.raw=<span class="literal">TRUE</span>,y.log=<span class="literal">TRUE</span>)</span><br><span class="line">FeaturePlot(object = seu,</span><br><span class="line">            features.plot = markers_genes,</span><br><span class="line">            cols.use = <span class="built_in">c</span>(<span class="string">&quot;grey&quot;</span>,<span class="string">&quot;blue&quot;</span>),</span><br><span class="line">            reduction.use = <span class="string">&quot;tsne&quot;</span>)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/headmarker_df.JPG"/>

<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/VlnPlotcluster1marker.JPG"/>


<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/FeaturePlotcluster1marker.JPG"/>


<h2 id="展示各个分类的marker基因的表达情况"><a href="#展示各个分类的marker基因的表达情况" class="headerlink" title="展示各个分类的marker基因的表达情况"></a>展示各个分类的marker基因的表达情况</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">seu.markers&lt;-FindAllMarkers(object = seu,only.pos = <span class="literal">TRUE</span>,min.pct = <span class="number">0.25</span>,thresh.use=<span class="number">0.25</span>)</span><br><span class="line">DT::datatable(seu.markers)<span class="comment">#这个操作有点优秀呀，可以在Rstudio里面试一试</span></span><br></pre></td></tr></table></figure>
<h2 id="热图展示各个亚群的marker基因"><a href="#热图展示各个亚群的marker基因" class="headerlink" title="热图展示各个亚群的marker基因"></a>热图展示各个亚群的marker基因</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(dplyr)</span><br><span class="line">seu.markers%&gt;%group_by(cluster)%&gt;%top_n(<span class="number">2</span>,avg_logFC)</span><br><span class="line"><span class="comment">#每个亚群挑10个marker基因进行展示</span></span><br><span class="line">top10&lt;-seu.markers%&gt;%group_by(cluster)%&gt;%top_n(<span class="number">10</span>,avg_logFC)</span><br><span class="line">DoHeatmap(object = seu,genes.use = top10$gene,slim.col.label = <span class="literal">TRUE</span>,remove.key = <span class="literal">TRUE</span>)</span><br><span class="line"><span class="comment">#FeaturePlot批量产图</span></span><br><span class="line"><span class="comment">#FeaturePlot(object = seu,features.plot = top10$gene,cols.use = c(&quot;grey&quot;,&quot;blue&quot;),reduction.use = &quot;tsne&quot;)</span></span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/clustersheatmap.JPG"/>


]]></content>
      <tags>
        <tag>NGS</tag>
      </tags>
  </entry>
  <entry>
    <title>scRNA-seq数据分析学习（四）</title>
    <url>/2020/02/15/scRNA-seq%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    <content><![CDATA[<p>学习R包monocle对scRNA-seq数据进行分析</p>
<a id="more"></a>

<h1 id="scRNA-seq数据分析（四）"><a href="#scRNA-seq数据分析（四）" class="headerlink" title="scRNA-seq数据分析（四）"></a>scRNA-seq数据分析（四）</h1><h2 id="创建数据集"><a href="#创建数据集" class="headerlink" title="创建数据集"></a>创建数据集</h2><p>后续分析的前提就是将数据构建成monocle需要的对象<br>因此这里先介绍一下monocle需要的用来构建CellDataSet对象的三个数据集   </p>
<ul>
<li>表达量矩阵<code>exprs</code>：数据矩阵，行名是基因，列明是细胞编号</li>
<li>细胞的表型信息<code>phenoData</code>：第一列是细胞编号，其他列是细胞的相关信息</li>
<li>基因注释<code>featureData</code>：第一列是基因编号，其他列是基因对应的信息<br>这三个数据集要满足如下要求  </li>
</ul>
<p><strong>表达量矩阵</strong></p>
<ul>
<li>保证它的列数等于<code>phenoData</code>的行数</li>
<li>保证它的行数等于<code>featureData</code>的行数</li>
<li><code>phenoData</code>的行名需要和表达矩阵的列明匹配</li>
<li><code>featureData</code>和表达矩阵的行名要匹配</li>
<li><code>featureData</code>至少要有一列”gene_short_name”，就是基因的symbol  </li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">rm(<span class="built_in">list</span> = ls())<span class="comment">#clear the environment</span></span><br><span class="line">options(warn=-<span class="number">1</span>)<span class="comment">#turn off warning message globally</span></span><br><span class="line">suppressMessages(library(monocle))</span><br></pre></td></tr></table></figure>
<p><strong>这里同样使用scRNAseq R包中的数据集，构建monocle对象</strong></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#首先需要一个表达矩阵，还需要临床信息</span></span><br><span class="line">library(scRNAseq)</span><br><span class="line">data(fluidigm)<span class="comment">#load examaple data</span></span><br><span class="line">assay(fluidigm)&lt;-assays(fluidigm)$rsem_counts<span class="comment">#set assay to RSEM estimated counts</span></span><br><span class="line">ct&lt;-<span class="built_in">floor</span>(assays(fluidigm)$rsem_counts)</span><br><span class="line">ct[<span class="number">1</span>:<span class="number">4</span>,<span class="number">1</span>:<span class="number">4</span>]<span class="comment">#表达矩阵</span></span><br><span class="line">sample_ann&lt;-as.data.frame(colData(fluidigm))<span class="comment">#临床信息</span></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#准备monocle对象需要的phenotype和feature data以及表达矩阵，从scRNA-seq这个R包里面提取这三个数据</span></span><br><span class="line">gene_ann&lt;-data.frame(</span><br><span class="line">  gene_short_name=row.names(ct),</span><br><span class="line">  row.names = row.names(ct)</span><br><span class="line">)</span><br><span class="line">pd&lt;-new(<span class="string">&quot;AnnotatedDataFrame&quot;</span>,data=sample_ann)</span><br><span class="line">fd&lt;-new(<span class="string">&quot;AnnotatedDataFrame&quot;</span>,data=gene_ann)</span><br></pre></td></tr></table></figure>
<p>#构建monocle后续分析的所有对象，主要是根据包的说明书，仔细探索其需要的构建对象的必备元素<br>#因为表达矩阵是counts值，所以注意expressionFamily参数,其他类型的值用其他参数</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">sc_cds&lt;-newCellDataSet(</span><br><span class="line">  ct,</span><br><span class="line">  phenoData = pd,</span><br><span class="line">  featureData = fd,</span><br><span class="line">  expressionFamily = negbinomial.size(),</span><br><span class="line">  lowerDetectionLimit = <span class="number">1</span></span><br><span class="line">)</span><br><span class="line">sc_cds</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/sc_sds.JPG"/>

<p><font color=red><strong>在此示范如何加载加载RPKM数据，在此并不运行该部分代码</strong></font><br>从本地读入RPKM值文件，构造CellDataSet对象  </p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#读入所需要的数据：表达矩阵，样本信息，基因信息</span></span><br><span class="line">expression_matrix&lt;-read.table(<span class="string">&quot;fpkm_matrix.txt&quot;</span>)</span><br><span class="line">sample_sheet&lt;-read.delin(<span class="string">&quot;cell_sample_sheet.txt&quot;</span>)</span><br><span class="line">gene_annotation&lt;-read.delin(<span class="string">&quot;gene_annotation.txt&quot;</span>)</span><br><span class="line"><span class="comment">#创建CellDataSet对象</span></span><br><span class="line">pd&lt;-new(<span class="string">&quot;AnnotatedDataFrame&quot;</span>,data=sample_sheet)</span><br><span class="line">fd&lt;-new(<span class="string">&quot;AnnotatedDataFrame&quot;</span>,data=gene_annotation)</span><br><span class="line">sc_cds&lt;-newCellDataSet(as.matrix(expression_matrix),</span><br><span class="line">                       phenoData=pd,featureData=fd)</span><br></pre></td></tr></table></figure>
<p>monocle和scater、seurat他们基于的对象不一样，所以monocle还提供了转换函数  </p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">lymphomadata&lt;-sc_cds</span><br><span class="line"><span class="comment">#转换成seurat对象</span></span><br><span class="line">lymphomadata_seurat&lt;-exportCDS(sc_cds,<span class="string">&#x27;Seurat&#x27;</span>)</span><br><span class="line"><span class="comment">#转换成SCESet对象</span></span><br><span class="line">lymphomadata_scater&lt;-exportCDS(sc_cds,<span class="string">&#x27;Scater&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>下面是monocle对新构建的CellDataSet对象的标准操作</strong></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">library(dplyr)</span><br><span class="line">colnames(phenoData(sc_cds)@data)</span><br><span class="line"><span class="comment">#estimateDispersions这步的时间和电脑配置密切相关,所以我们这套分析不选用monocle包自带的数据集，因为太大了，仍然采用scRNAseq内置数据集</span></span><br><span class="line">sc_cds&lt;-estimateSizeFactors(sc_cds)<span class="comment">#一定要运行</span></span><br><span class="line">sc_cds&lt;-estimateDispersions(sc_cds)<span class="comment">#一定要运行</span></span><br></pre></td></tr></table></figure>
<h1 id="质控"><a href="#质控" class="headerlink" title="质控"></a>质控</h1><p>对基因和细胞进行质量控制，指控指标根据课题进行具体探索，没有统一标准，这里只是简单演示 </p>
<p><strong>过滤基因</strong></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">cds&lt;-sc_cds</span><br><span class="line">cds</span><br><span class="line">cds&lt;-detectGenes(cds,min_expr = <span class="number">0.1</span>)<span class="comment">#设置基因最小表达量为0.1</span></span><br><span class="line">print(head(fData(cds)))</span><br><span class="line">expressed_gene&lt;-row.names(subset(fData(cds),num_cells_expressed&gt;=<span class="number">5</span>))</span><br><span class="line"><span class="built_in">length</span>(expressed_gene)</span><br><span class="line">cds&lt;-cds[expressed_gene,]</span><br><span class="line">cds</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/filtergene.JPG"/>


<p><strong>过滤细胞</strong></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#过滤细胞</span></span><br><span class="line">print(head(pData(cds)))<span class="comment">#如果没有运行上述步骤的estimateSizeFactors、estimateDispersions，这一步就会发现某个属性出现NA值</span></span><br><span class="line">tmp&lt;-pData(cds)</span><br><span class="line">fivenum(tmp[,<span class="number">1</span>])</span><br><span class="line">fivenum(tmp[,<span class="number">30</span>])</span><br><span class="line"><span class="comment">#这里展示就先不过滤细胞了，有需要就自行过滤</span></span><br><span class="line">valid_cell&lt;-row.names(pData(cds))<span class="comment">#其实这里没有过滤细胞，valid_cell全为TRUE</span></span><br><span class="line">cds&lt;-cds[,valid_cell]</span><br><span class="line">cds</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/filtercell.JPG"/>


<h2 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h2><p>单细胞转录组最重要的就是把细胞分群，相关的算法非常多，这里选用最常用的tSNE  </p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">plot_pc_variance_explained(cds,return_all = <span class="built_in">F</span>)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/plotPC.JPG"/>


<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#由上图决定用前6个组成份进行降维,降维采用tSNE的方法</span></span><br><span class="line">cds&lt;-reduceDimension(cds,max_components = <span class="number">2</span>,num_dim=<span class="number">6</span>,</span><br><span class="line">                     reduction_method = <span class="string">&#x27;tSNE&#x27;</span>,verbose = <span class="built_in">T</span>)</span><br><span class="line">cds&lt;-clusterCells(cds,num_clusters = <span class="number">4</span>)</span><br><span class="line">plot_cell_clusters(cds,<span class="number">1</span>,<span class="number">2</span>,color=<span class="string">&quot;Biological_Condition&quot;</span>)</span><br><span class="line">table(pData(cds)$Biological_Condition)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/plottsne.JPG"/>


<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/tableBiologicalananotation.JPG"/>

<p><strong>可以看出，用monocle的方法进行单细胞转录组数据分析，GW的三群细胞依然无法很好的区分开，NPC倒是聚类得非常完美</strong>  </p>
<h2 id="寻找差异基因"><a href="#寻找差异基因" class="headerlink" title="寻找差异基因"></a>寻找差异基因</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#这一步需要计算量，如果数据量大，这一步很耗时</span></span><br><span class="line">Sys.time()</span><br><span class="line">diff_test_res&lt;-differentialGeneTest(cds,fullModelFormulaStr = <span class="string">&quot;~Biological_Condition&quot;</span>)</span><br><span class="line">Sys.time()</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/difftestres.JPG"/>

<p><strong>选出差异基因</strong></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">sig_gene&lt;-subset(diff_test_res,qval&lt;<span class="number">0.1</span>)<span class="comment">#筛选条件qval&lt;0.1</span></span><br><span class="line">head(sig_gene[,<span class="built_in">c</span>(<span class="string">&quot;gene_short_name&quot;</span>,<span class="string">&quot;pval&quot;</span>,<span class="string">&quot;qval&quot;</span>)])</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/headdiffgene.JPG"/>

<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">choosed_gene&lt;-<span class="built_in">as.character</span>(head(sig_gene$gene_short_name))</span><br><span class="line">plot_genes_jitter(cds[choosed_gene,],grouping = <span class="string">&quot;Biological_Condition&quot;</span>,ncol = <span class="number">2</span>)</span><br><span class="line">plot_genes_jitter(cds[choosed_gene,],grouping = <span class="string">&quot;Biological_Condition&quot;</span>,</span><br><span class="line">                  color_by = <span class="string">&quot;Biological_Condition&quot;</span>,nrow = <span class="number">3</span>,ncol = <span class="literal">NULL</span></span><br><span class="line">                  )</span><br><span class="line"><span class="comment">#自己画图也可以</span></span><br><span class="line"> <span class="comment">#boxplot(log10(exprs(cds)[&#x27;A1BG&#x27;,]+1)~pData(cds)$Biological_Condition)</span></span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/plotdiffgenehead.JPG" width="49%" height="50%">
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/plotdiffgeneheadcol.JPG" width="50%" height="50%">  


<h2 id="推断发育轨迹-这是monocle包最大的亮点"><a href="#推断发育轨迹-这是monocle包最大的亮点" class="headerlink" title="推断发育轨迹 这是monocle包最大的亮点"></a>推断发育轨迹 <font color=red>这是monocle包最大的亮点</font></h2><p><strong>第一步：挑选合适的基因</strong><br>有多种方法，例如可以提供已经的基因集，这里选取统计学上有差异的基因   </p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ordering_gene&lt;-row.names(subset(diff_test_res,qval&lt; <span class="number">0.01</span>))</span><br><span class="line">cds&lt;-setOrderingFilter(cds,ordering_gene)</span><br><span class="line">plot_ordering_genes(cds)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/plotoderinggenes.JPG" width="60%" height="50%">

<p><strong>第二部：降维</strong><br>降维的目的是更好的展示数据。函数里提供很多方法，不同方法最后展示的图会有所不同，DDRTree是Monocle2使用的默认方法</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">cds&lt;-reduceDimension(cds,max_components = <span class="number">2</span>,method=<span class="string">&#x27;DDRTree&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>第三步：对细胞进行排序</strong></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">cds&lt;-orderCells(cds)</span><br><span class="line">plot_cell_trajectory(cds,color_by = <span class="string">&quot;Biological_Condition&quot;</span>)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/trace.JPG" width="60%" height="50%">


<p><strong>第四步：可视化marker gene随发育阶段变化的表达情况</strong></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#plot_genes_in_pseudotime可以展示marker基因，本例子随便选取了6个差异表达基因</span></span><br><span class="line">plot_genes_in_pseudotime(cds[choosed_gene,],color_by = <span class="string">&quot;Biological_Condition&quot;</span>)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/tracemaker.JPG"/>


<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>生信技能数（<a href="https://search.bilibili.com/all?keyword=%E7%94%9F%E4%BF%A1%E6%8A%80%E8%83%BD%E6%A0%91&from_source=nav_search&spm_id_from=333.851.b_696e7465726e6174696f6e616c486561646572.9">B站</a>、公众号）   </p>
]]></content>
      <tags>
        <tag>NGS</tag>
      </tags>
  </entry>
  <entry>
    <title>scRNA-seq数据分析学习（二）</title>
    <url>/2020/02/14/scRNA-seq%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>学习R包scater对scRNA-seq数据进行分析</p>
<a id="more"></a>

<h1 id="scRNA-seq数据分析（二）"><a href="#scRNA-seq数据分析（二）" class="headerlink" title="scRNA-seq数据分析（二）"></a>scRNA-seq数据分析（二）</h1><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">rm(<span class="built_in">list</span> = ls())<span class="comment">#clear the environment</span></span><br><span class="line">options(warn=-<span class="number">1</span>)<span class="comment">#turn off warning message globally</span></span><br></pre></td></tr></table></figure>
<h1 id="认识scater"><a href="#认识scater" class="headerlink" title="认识scater"></a>认识scater</h1><h2 id="创建scater要求的对象"><a href="#创建scater要求的对象" class="headerlink" title="创建scater要求的对象"></a>创建scater要求的对象</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(scRNAseq)</span><br><span class="line">data(fluidigm)</span><br><span class="line">assay(fluidigm)&lt;-assays(fluidigm)$rsem_counts</span><br><span class="line">ct&lt;-<span class="built_in">floor</span>(assays(fluidigm)$rsem_counts)</span><br><span class="line">ct[<span class="number">1</span>:<span class="number">4</span>,<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">table(rownames(ct)==<span class="number">0</span>)</span><br><span class="line">sample_ann&lt;-as.data.frame(colData(fluidigm))<span class="comment">#数据集的临床信息</span></span><br><span class="line"><span class="comment">#这里需要将表达矩阵做成我们的scater要求的对象</span></span><br><span class="line">sce&lt;-SingleCellExperiment(</span><br><span class="line">  assays=<span class="built_in">list</span>(counts=ct),</span><br><span class="line">  colData=sample_ann</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/scepre.JPG"/>


<h2 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h2><p><strong>基因层面的过滤</strong></p>
<p>使用<code>calculateQCMetrics</code>函数作用于sce这个单细胞数据对象后，就可以用<code>rowData(object)</code>查看各个基因各项统计指标：  </p>
<ul>
<li><code>mean_counts</code>：平均表达量</li>
<li><code>log10_mean_counts</code>：归一化 log10-scale</li>
<li><code>pct_dropout_by_counts</code>：该基因丢失率</li>
<li><code>n_cell_by_counts</code>：多少个细胞表达了该基因  </li>
</ul>
<p>上面的指标可以用来过滤，也可以自己计算这些统计学指标<br>主要是过滤掉<strong>低表达量的基因</strong>，还有<strong>线粒体基因</strong>和<strong>ERCC spike-ins</strong>的控制</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">exprs(sce)&lt;-log2(calculateCPM(sce)+<span class="number">1</span>)</span><br><span class="line">genes&lt;-rownames(rowData(sce))<span class="comment">#rowData(object)基因相关统计情况</span></span><br><span class="line">genes[grepl(<span class="string">&#x27;^MT-&#x27;</span>,genes)]</span><br><span class="line">genes[grepl(<span class="string">&#x27;^ERCC-&#x27;</span>,genes)]</span><br><span class="line"><span class="comment">#比较不幸，这个测试数据里面没有线粒体基因，也没有ERCC序列</span></span><br><span class="line">sce&lt;-calculateQCMetrics(sce,</span><br><span class="line">                        feature_controls = <span class="built_in">list</span>(ERCC=grep(<span class="string">&#x27;^ERCC&#x27;</span>,genes)))</span><br><span class="line"><span class="comment">#后面的分析都是基于sce这个变量，这个是一个SingleCellExperiment对象</span></span><br><span class="line"><span class="comment">#sce是一个list(S4),但这个list可以当成data.frame来使用，非常方便</span></span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/MTERCC.JPG"/>



<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看信息</span></span><br><span class="line">tmp&lt;-as.data.frame(rowData(sce))</span><br><span class="line">colnames(tmp)</span><br><span class="line">head(tmp)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/sceproperty.JPG"/>


<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#目前只过滤掉那些在所有细胞都没有表达的基因</span></span><br><span class="line"><span class="comment">#这个过滤条件可以自行调整，可以看到基因数量大幅减少</span></span><br><span class="line">keep_feature&lt;-rowSums(exprs(sce)&gt;<span class="number">0</span>)&gt;<span class="number">0</span></span><br><span class="line">table(keep_feature)</span><br><span class="line">sce&lt;-sce[keep_feature,]</span><br><span class="line">sce</span><br></pre></td></tr></table></figure>

<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/scemid.JPG"/>


<p><strong>细胞层面的过滤</strong><br>用<code>colData(object)</code>可以查看各个样本统计情况</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">tmp&lt;-as.data.frame(colData(sce)) </span><br><span class="line">colnames(tmp)</span><br><span class="line"><span class="comment">#尝试查看一些信息</span></span><br><span class="line">tf&lt;-sce$total_features_by_counts</span><br><span class="line">boxplot(tf)</span><br><span class="line">fivenum(tf)</span><br><span class="line"><span class="comment">#还是那句话，过滤没有统一的标准，视具体情况而定，下面举一个例子进行简单的过滤尝试</span></span><br><span class="line">tmp$pct_counts_in_top_100_features_endogenous&lt;<span class="number">50</span></span><br><span class="line">table(tmp$pct_counts_in_top_100_features_endogenous&lt;<span class="number">50</span>)</span><br><span class="line">sce&lt;-sce[,tmp$pct_counts_in_top_100_features_endogenous&lt;<span class="number">50</span>]</span><br><span class="line">sce</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/filtercountsboxplot.JPG" width="30%" height="30%">

<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/scefin.JPG"/>

<p><strong>这个sce真的是非常方便了，虽然是个list,但是却可以像dataframe一样对其进行处理，</strong><br><strong>至此，我们过滤掉了9000多个基因，4个样本</strong></p>
<h2 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#展示一些基因在不同细胞分类的表达，这里只做一下演示，一般不这么用，不过筛出来的marker基因可以用这种方式展现其在各组间的差异</span></span><br><span class="line">plotExpression(sce,rownames(sce)[<span class="number">1</span>:<span class="number">6</span>],</span><br><span class="line">               x=<span class="string">&quot;Biological_Condition&quot;</span>,</span><br><span class="line">               exprs_values = <span class="string">&quot;logcounts&quot;</span>)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/6genesin4groups.JPG" width="70%" height="70%">


<p><strong>PCA</strong></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#还可以可视化细胞距离分布</span></span><br><span class="line">sce&lt;-runPCA(sce)<span class="comment">#这里没有进行任何基因的挑选，就直接进行PCA了，与seurat包不一样</span></span><br><span class="line">reducedDimNames(sce)</span><br><span class="line"><span class="comment">#PCA分布图上添加临床信息，同样发现不同GW细胞之间不能很好的分群</span></span><br><span class="line"><span class="comment">#plotPCA(sce)该数据最原始的PCA图</span></span><br><span class="line">plotReducedDim(sce,use_dimred = <span class="string">&quot;PCA&quot;</span>,colour_by = <span class="string">&quot;Biological_Condition&quot;</span>)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/scePCA.JPG" width="70%" height="70%">

<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#PCA分布图上面添加表达量信息，一般标marker gene，次方法不常用，这里就以一个基因为例示范一下</span></span><br><span class="line">plotReducedDim(sce,use_dimred = <span class="string">&quot;PCA&quot;</span>,colour_by = rownames(sce)[<span class="number">1</span>],size_by = rownames(sce)[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/scePCAcertaingene.JPG" width="60%" height="60%">


<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">##仅仅是选取前20个PC，分群时细胞分布并没有太大区别</span></span><br><span class="line">sce&lt;-runPCA(sce,ncomponents = <span class="number">20</span>)</span><br><span class="line">plotPCA(sce,colour_by=<span class="string">&quot;Biological_Condition&quot;</span>)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/scePCAcomponent20.JPG" width="70%" height="70%">

<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">##可以挑选指定的PC来可视化，这里选5个PC</span></span><br><span class="line">plotPCA(sce,ncomponents=<span class="number">5</span>,colour_by=<span class="string">&quot;Biological_Condition&quot;</span>)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/PCA5component.JPG"/>

<p><strong>tSNE</strong></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#tSNE可视化</span></span><br><span class="line">set.seed(<span class="number">1234</span>)</span><br><span class="line">sce&lt;-runTSNE(sce,perplexity = <span class="number">30</span>)</span><br><span class="line">plotTSNE(sce,colour_by=<span class="string">&quot;Biological_Condition&quot;</span>)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/tsne.JPG" width="70%" height="70%">

<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#perplexity的设定值不一样，散点的分布也会有所不同，但趋势都是一致的</span></span><br><span class="line"><span class="comment">#perplexity设置为10</span></span><br><span class="line">sce&lt;-runTSNE(sce,perplexity = <span class="number">10</span>,use_dimred = <span class="string">&quot;PCA&quot;</span>,n_dimred = <span class="number">10</span>)</span><br><span class="line">plotTSNE(sce,colour_by=<span class="string">&quot;Biological_Condition&quot;</span>)</span><br><span class="line"><span class="comment">#perplexity设置为20</span></span><br><span class="line">sce&lt;-runTSNE(sce,perplexity = <span class="number">20</span>,use_dimred = <span class="string">&quot;PCA&quot;</span>,n_dimred = <span class="number">10</span>)</span><br><span class="line">plotTSNE(sce,colour_by=<span class="string">&quot;Biological_Condition&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/scePCAper10.JPG" width="50%" height="50%"><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/scePCAper20.JPG" width="50%" height="50%"></p>
<h1 id="认识SC3"><a href="#认识SC3" class="headerlink" title="认识SC3"></a>认识SC3</h1><h2 id="R包SC3处理scRNAseq内置的数据"><a href="#R包SC3处理scRNAseq内置的数据" class="headerlink" title="R包SC3处理scRNAseq内置的数据"></a>R包SC3处理scRNAseq内置的数据</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#R包SC3</span></span><br><span class="line">library(SC3)</span><br><span class="line">sce&lt;-sce_back</span><br><span class="line">sce&lt;-sc3_estimate_k(sce)</span><br><span class="line">metadata(sce)$sc3$k_estimation</span><br><span class="line">rowData(sce)$feature_symbol&lt;-rownames(rowData(sce))</span><br><span class="line"><span class="comment">#一步运行sc3的所有分析，相当耗时，数据量大的话就真的相当耗时</span></span><br><span class="line"><span class="comment">#这里kn表示的预估聚类数，数据集是已知的，我们这里就设定为4组，具体数据要具体考虑</span></span><br><span class="line">kn&lt;-<span class="number">4</span></span><br><span class="line">sc3_cluster&lt;-<span class="string">&quot;sc3_4_clusters&quot;</span></span><br><span class="line">sce&lt;-sc3(sce,ks=kn,biology = <span class="literal">TRUE</span>)</span><br></pre></td></tr></table></figure>
<h2 id="可视化展示"><a href="#可视化展示" class="headerlink" title="可视化展示"></a>可视化展示</h2><p>kn就是聚类数</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#热图：比较先验分类和SC3的聚类的一致性</span></span><br><span class="line">sc3_plot_consensus(sce,k=kn,show_pdata = <span class="built_in">c</span>(<span class="string">&quot;Biological_Condition&quot;</span>,sc3_cluster))</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/sc3pheatmapconsensus.JPG"/>


<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#热图：展示表达量信息</span></span><br><span class="line">sc3_plot_expression(sce,k=kn,show_pdata = <span class="built_in">c</span>(<span class="string">&quot;Biological_Condition&quot;</span>,sc3_cluster))</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/sc3pheatmapexpression.JPG"/>

<p><font color=red><strong>SC3包找marker基因</strong></font></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#热图，展示可能的标记基因</span></span><br><span class="line">sc3_plot_markers(sce,k=kn,show_pdata =<span class="built_in">c</span>(<span class="string">&quot;Biological_Condition&quot;</span>,sc3_cluster) )</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/sc3pheatmarker.JPG"/>



]]></content>
      <tags>
        <tag>NGS</tag>
      </tags>
  </entry>
  <entry>
    <title>scRNA-seq数据分析实战（三）</title>
    <url>/2020/02/22/scRNA-seq%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<p>single cell RNA-seq  &amp;&amp; 10×<br>利用Seurate 2.3.3完成单细胞转录组下游分析，重现文章《Acquired cancer resistance to combination immunotherapy from transcriptional loss of class I HLA》的部分图片。</p>
<a id="more"></a>

<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">rm(<span class="built_in">list</span> = ls()) <span class="comment"># clear the environment</span></span><br><span class="line"><span class="comment">#load all the necessary libraries</span></span><br><span class="line">options(warn=-<span class="number">1</span>) <span class="comment"># turn off warning message globally</span></span><br><span class="line">suppressMessages(library(Seurat))</span><br></pre></td></tr></table></figure>
<h2 id="读入文章关于第一个病人的PBMC表达矩阵"><a href="#读入文章关于第一个病人的PBMC表达矩阵" class="headerlink" title="读入文章关于第一个病人的PBMC表达矩阵"></a>读入文章关于第一个病人的PBMC表达矩阵</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">raw_dataPBMC &lt;- read.csv(<span class="string">&#x27;path/to/GSE117988_raw.expMatrix_PBMC.csv.gz&#x27;</span>, header = <span class="literal">TRUE</span>, row.names = <span class="number">1</span>)</span><br><span class="line">raw_dataPBMC[<span class="number">1</span>:<span class="number">4</span>,<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line"><span class="built_in">dim</span>(raw_dataPBMC)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/dataPBMC.JPG"/>


<h2 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">dataPBMC &lt;- log2(<span class="number">1</span> + sweep(raw_dataPBMC, <span class="number">2</span>, median(colSums(raw_dataPBMC))/colSums(raw_dataPBMC), <span class="string">&#x27;*&#x27;</span>)) <span class="comment"># Normalization，矩阵大也会比较耗时</span></span><br></pre></td></tr></table></figure>
<h2 id="按照治疗阶段分组（后续会用到）"><a href="#按照治疗阶段分组（后续会用到）" class="headerlink" title="按照治疗阶段分组（后续会用到）"></a>按照治疗阶段分组（后续会用到）</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">timePoints &lt;- sapply(colnames(dataPBMC), <span class="keyword">function</span>(x) ExtractField(x, <span class="number">2</span>, <span class="string">&#x27;[.]&#x27;</span>))</span><br><span class="line"></span><br><span class="line">timePoints &lt;-ifelse(timePoints == <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;PBMC_Pre&#x27;</span>, </span><br><span class="line">                    ifelse(timePoints == <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;PBMC_EarlyD27&#x27;</span>,</span><br><span class="line">                           ifelse(timePoints == <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;PBMC_RespD376&#x27;</span>, <span class="string">&#x27;PBMC_ARD614&#x27;</span>)))</span><br><span class="line">table(timePoints)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/tabletimepoint.JPG"/>

<h2 id="表达矩阵的基本信息可视化（可用于知道质控）"><a href="#表达矩阵的基本信息可视化（可用于知道质控）" class="headerlink" title="表达矩阵的基本信息可视化（可用于知道质控）"></a>表达矩阵的基本信息可视化（可用于知道质控）</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 表达矩阵的质量控制</span></span><br><span class="line">fivenum(apply(dataPBMC,<span class="number">1</span>,<span class="keyword">function</span>(x) <span class="built_in">sum</span>(x&gt;<span class="number">0</span>) ))</span><br><span class="line">boxplot(apply(dataPBMC,<span class="number">1</span>,<span class="keyword">function</span>(x) <span class="built_in">sum</span>(x&gt;<span class="number">0</span>) ))</span><br><span class="line">fivenum(apply(dataPBMC,<span class="number">2</span>,<span class="keyword">function</span>(x) <span class="built_in">sum</span>(x&gt;<span class="number">0</span>) ))</span><br><span class="line">hist(apply(dataPBMC,<span class="number">2</span>,<span class="keyword">function</span>(x) <span class="built_in">sum</span>(x&gt;<span class="number">0</span>) ))</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/fibenumdataPBMC.JPG"/>

<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/boxplotdataPBMC.JPG" width="70%" height="70%">

<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/histdataPBMC.JPG" width="70%" height="70%">

<h2 id="然后创建Seurat的对象"><a href="#然后创建Seurat的对象" class="headerlink" title="然后创建Seurat的对象"></a>然后创建Seurat的对象</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Create Seurat object</span></span><br><span class="line"><span class="comment"># already normalized (above)</span></span><br><span class="line">PBMC &lt;- CreateSeuratObject(raw.data = dataPBMC, </span><br><span class="line">                           min.cells = <span class="number">1</span>, min.genes = <span class="number">0</span>, project = <span class="string">&#x27;10x_PBMC&#x27;</span>) <span class="comment">#没有进行过滤</span></span><br><span class="line">PBMC </span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/PBMC.JPG"/>

<h2 id="根据需要添加metadata信息"><a href="#根据需要添加metadata信息" class="headerlink" title="根据需要添加metadata信息"></a>根据需要添加metadata信息</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Add meta.data (nUMI and timePoints)</span></span><br><span class="line">PBMC &lt;- AddMetaData(object = PBMC, </span><br><span class="line">                    metadata = apply(raw_dataPBMC, <span class="number">2</span>, <span class="built_in">sum</span>),</span><br><span class="line">                    col.name = <span class="string">&#x27;nUMI_raw&#x27;</span>)</span><br><span class="line">PBMC &lt;- AddMetaData(object = PBMC, metadata = timePoints, col.name = <span class="string">&#x27;TimePoints&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="将对象进行基本的可视化"><a href="#将对象进行基本的可视化" class="headerlink" title="将对象进行基本的可视化"></a>将对象进行基本的可视化</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">sce=PBMC</span><br><span class="line">VlnPlot(object = sce, </span><br><span class="line">        features.plot = <span class="built_in">c</span>(<span class="string">&quot;nGene&quot;</span>, <span class="string">&quot;nUMI&quot;</span>), </span><br><span class="line">        group.by = <span class="string">&#x27;TimePoints&#x27;</span>, nCol = <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/VlnPlotsce.JPG"/>


<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">GenePlot(object = sce, gene1 = <span class="string">&quot;nUMI&quot;</span>, gene2 = <span class="string">&quot;nGene&quot;</span>)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/GenePlotsce.JPG"/>

<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#可以看看高表达量基因是哪些</span></span><br><span class="line">tail(sort(Matrix::rowSums(sce@raw.data)))</span><br><span class="line"><span class="comment">## 散点图可视化任意两个基因的一些属性（通常是细胞的度量）</span></span><br><span class="line"><span class="comment"># 这里选取两个基因。</span></span><br><span class="line">tmp=<span class="built_in">names</span>(sort(Matrix::rowSums(sce@raw.data),decreasing = <span class="built_in">T</span>))</span><br><span class="line">GenePlot(object = sce, gene1 = tmp[<span class="number">1</span>], gene2 = tmp[<span class="number">2</span>])</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/GenePlotgene.JPG"/>

<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 散点图可视化任意两个细胞的一些属性（通常是基因的度量）</span></span><br><span class="line"><span class="comment"># 这里选取两个细胞</span></span><br><span class="line">CellPlot(sce,sce@cell.names[<span class="number">3</span>],sce@cell.names[<span class="number">4</span>],do.ident = <span class="literal">FALSE</span>)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/GenePlotsample.JPG"/>


<h2 id="聚类可视化（重点）"><a href="#聚类可视化（重点）" class="headerlink" title="聚类可视化（重点）"></a>聚类可视化（重点）</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Cluster PBMC</span></span><br><span class="line">PBMC &lt;- ScaleData(object = PBMC, vars.to.regress = <span class="built_in">c</span>(<span class="string">&#x27;nUMI_raw&#x27;</span>), model.use = <span class="string">&#x27;linear&#x27;</span>, use.umi = <span class="literal">FALSE</span>)</span><br><span class="line"><span class="comment">#因为矩阵比较大，scale这一步非常耗内存，计算机内存不够的话这一步会报错</span></span><br><span class="line">PBMC &lt;- FindVariableGenes(object = PBMC, mean.function = ExpMean, dispersion.function = LogVMR, x.low.cutoff = <span class="number">0.0125</span>, x.high.cutoff = <span class="number">3</span>, y.cutoff = <span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/fvg.JPG"/>


<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">PBMC &lt;- RunPCA(object = PBMC, pc.genes = PBMC@var.genes)</span><br><span class="line"><span class="comment">##</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 避免太多log日志被打印出来。</span></span><br><span class="line">PBMC &lt;- FindClusters(object = PBMC, </span><br><span class="line">                     reduction.type = <span class="string">&quot;pca&quot;</span>, </span><br><span class="line">                     dims.use = <span class="number">1</span>:<span class="number">10</span>, </span><br><span class="line">                     resolution = <span class="number">1</span>, </span><br><span class="line">                     print.output = <span class="number">0</span>,</span><br><span class="line">                     k.param = <span class="number">35</span>, save.SNN = <span class="literal">TRUE</span>)</span><br><span class="line"><span class="comment">#在此，resolution、k.param的值设定不同，分群效果也会不一样，参数的调整也是一个比较麻烦的事情</span></span><br><span class="line">table(PBMC@ident)<span class="comment"># 分出了13个clusters</span></span><br><span class="line">PBMC &lt;- RunTSNE(object = PBMC, dims.use = <span class="number">1</span>:<span class="number">10</span>)</span><br><span class="line">TSNEPlot(PBMC, colors.use = <span class="built_in">c</span>(<span class="string">&#x27;green4&#x27;</span>, <span class="string">&#x27;pink&#x27;</span>, <span class="string">&#x27;#FF7F00&#x27;</span>, <span class="string">&#x27;orchid&#x27;</span>, <span class="string">&#x27;#99c9fb&#x27;</span>, <span class="string">&#x27;dodgerblue2&#x27;</span>, <span class="string">&#x27;grey30&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;grey60&#x27;</span>, <span class="string">&#x27;grey&#x27;</span>, <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;#FB9A99&#x27;</span>, <span class="string">&#x27;black&#x27;</span>),do.label=<span class="built_in">T</span>)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/tSNE.JPG" width="70%" height="70%">


<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">table(PBMC@meta.data$TimePoints,PBMC@ident)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/timepointident.JPG"/>


<h2 id="添加亚群信息"><a href="#添加亚群信息" class="headerlink" title="添加亚群信息"></a>添加亚群信息</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">current.cluster.ids &lt;- <span class="built_in">c</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>)</span><br><span class="line"><span class="comment">#具体是哪一种cell type,根据每个亚群的maker基因，再结合生物学背景确定亚群的具体类型，这个也有网站预测。</span></span><br><span class="line">new.cluster.ids &lt;- <span class="built_in">c</span>(<span class="string">&quot;B cells&quot;</span>, <span class="string">&quot;CD14+ T cells&quot;</span>, <span class="string">&quot;Classical monicytes&quot;</span>,<span class="string">&quot;Naive memory T cells&quot;</span>, <span class="string">&quot;CD8 effector T cells&quot;</span>, <span class="string">&quot;NK cells&quot;</span>, <span class="string">&quot;NULL1&quot;</span>, <span class="string">&quot;Non-classical monocytes&quot;</span>,<span class="string">&quot;Dendritic cells&quot;</span>, <span class="string">&quot;NULL2&quot;</span>,<span class="string">&quot;CD8+ cytotoxic T cells&quot;</span>,<span class="string">&quot;Myeloid cells&quot;</span>,<span class="string">&quot;NULL3&quot;</span>)</span><br><span class="line">PBMC@ident &lt;- plyr::mapvalues(x = PBMC@ident, from = current.cluster.ids, to = new.cluster.ids)</span><br><span class="line">TSNEPlot(object = PBMC, colors.use = <span class="built_in">c</span>(<span class="string">&#x27;green4&#x27;</span>, <span class="string">&#x27;pink&#x27;</span>, <span class="string">&#x27;#FF7F00&#x27;</span>, <span class="string">&#x27;orchid&#x27;</span>, <span class="string">&#x27;#99c9fb&#x27;</span>, <span class="string">&#x27;dodgerblue2&#x27;</span>, <span class="string">&#x27;grey30&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;grey60&#x27;</span>, <span class="string">&#x27;grey&#x27;</span>, <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;#FB9A99&#x27;</span>, <span class="string">&#x27;black&#x27;</span>),do.label=<span class="built_in">T</span>)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/tsnelabelcellname.JPG"/>



<h2 id="QUESTION"><a href="#QUESTION" class="headerlink" title="QUESTION"></a><font color=red>QUESTION</font></h2><ul>
<li>代码都跟原文的代码一样，虽然主要想体现的东西是有所体现的，聚类出来的细胞亚群还是有小小的偏差。</li>
<li><code>FindClusters</code>的参数真的是我至今为止最最纠结的问题啦，参数不一样，亚群就会不一样，难不成为了得到自己想要的分群效果，不停的调整参数吗？</li>
<li>对象问题也是个巨大的问题，对象里面包裹了好多东西，有些不太会调用。</li>
<li>该数据按照TimePoint来体现，目前自创的方法无法做到与原文类似的图，这也是一个待解决的问题。</li>
</ul>
]]></content>
      <tags>
        <tag>NGS</tag>
      </tags>
  </entry>
  <entry>
    <title>scRNA-seq数据分析实战（二）</title>
    <url>/2020/02/08/scRNA-seq%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>体验Seraut包处理GSE111229的scRNA-seq数据</p>
<a id="more"></a>

<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">rm(<span class="built_in">list</span> = ls()) </span><br><span class="line">Sys.setenv(R_MAX_NUM_DLLS=<span class="number">999</span>)</span><br></pre></td></tr></table></figure>
<h1 id="载入数据"><a href="#载入数据" class="headerlink" title="载入数据"></a>载入数据</h1><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">load(file=<span class="string">&#x27;../input.Rdata&#x27;</span>)</span><br><span class="line">counts=a</span><br><span class="line"><span class="comment"># using raw counts is the easiest way to process data through Seurat.</span></span><br><span class="line">counts[<span class="number">1</span>:<span class="number">4</span>,<span class="number">1</span>:<span class="number">4</span>];<span class="built_in">dim</span>(counts)</span><br><span class="line">library(stringr) </span><br><span class="line">meta=df</span><br><span class="line">head(meta) </span><br><span class="line"><span class="comment"># 下面的基因是文章作者给出的</span></span><br><span class="line">gs=read.table(<span class="string">&#x27;top18-genes-in-4-subgroup.txt&#x27;</span>)[,<span class="number">1</span>]</span><br><span class="line">gs</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/loaddata.JPG"/>


<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#简单了解一下表达矩阵</span></span><br><span class="line">fivenum(apply(counts,<span class="number">1</span>,<span class="keyword">function</span>(x) <span class="built_in">sum</span>(x&gt;<span class="number">0</span>) ))</span><br><span class="line">boxplot(apply(counts,<span class="number">1</span>,<span class="keyword">function</span>(x) <span class="built_in">sum</span>(x&gt;<span class="number">0</span>) ))</span><br><span class="line">fivenum(apply(counts,<span class="number">2</span>,<span class="keyword">function</span>(x) <span class="built_in">sum</span>(x&gt;<span class="number">0</span>) ))</span><br><span class="line">hist(apply(counts,<span class="number">2</span>,<span class="keyword">function</span>(x) <span class="built_in">sum</span>(x&gt;<span class="number">0</span>) ))</span><br></pre></td></tr></table></figure>
<h2 id="构建Seraute对象"><a href="#构建Seraute对象" class="headerlink" title="构建Seraute对象"></a>构建Seraute对象</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(Seurat)</span><br><span class="line"><span class="comment"># 其中 min.cells 和 min.genes 两个参数是经验值</span></span><br><span class="line"><span class="comment">#Seurat真的很优秀呀，给定参数，自动进行质控</span></span><br><span class="line">seu &lt;- CreateSeuratObject(raw.data = counts, </span><br><span class="line">                          meta.data =meta,</span><br><span class="line">                          min.cells = <span class="number">5</span>, </span><br><span class="line">                          min.genes = <span class="number">2000</span>, </span><br><span class="line">                          project = <span class="string">&quot;seu&quot;</span>)</span><br><span class="line">seu</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/szseuratseu1.JPG"/>


<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#可以尝试以下手动质控</span></span><br><span class="line">table(apply(counts,<span class="number">2</span>,<span class="keyword">function</span>(x) <span class="built_in">sum</span>(x&gt;<span class="number">0</span>) )&gt;<span class="number">2000</span>)</span><br><span class="line">table(apply(counts,<span class="number">1</span>,<span class="keyword">function</span>(x) <span class="built_in">sum</span>(x&gt;<span class="number">0</span>) )&gt;<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/manuqc.JPG"/>

<p>可以看到，两种质控方法得到的数据非常接近</p>
<p><strong>查看对象的基本情况</strong></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">head(seu@meta.data) </span><br><span class="line"><span class="built_in">dim</span>(seu@data)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/szseuratseu@.JPG"/>

<p><strong>可视化基本信息</strong></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">VlnPlot(object = seu, </span><br><span class="line">        features.plot = <span class="built_in">c</span>(<span class="string">&quot;nGene&quot;</span>, <span class="string">&quot;nUMI&quot;</span> ), </span><br><span class="line">        group.by = <span class="string">&#x27;plate&#x27;</span>,</span><br><span class="line">        nCol = <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/szseuratVlnPlotnbyplat.JPG"/>

<p>可以看出：不管是各个样本检测到的基因数量还是文库大小，都没有批次效应。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">VlnPlot(object = seu, </span><br><span class="line">        features.plot = <span class="built_in">c</span>(<span class="string">&quot;nGene&quot;</span>, <span class="string">&quot;nUMI&quot;</span> ), </span><br><span class="line">        group.by = <span class="string">&#x27;g&#x27;</span>,</span><br><span class="line">        nCol = <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/szseuratVlnPlotbyg.JPG"/>

<p>可以看出：层次聚类得到的分组主要是因为样本间检测的基因数量的差异造成的。</p>
<p><strong>可以给seu对象增加一个属性，供QC使用</strong>  </p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#构建新增的属性</span></span><br><span class="line">ercc.genes &lt;- grep(pattern = <span class="string">&quot;^ERCC-&quot;</span>, x = rownames(x = seu@raw.data), value = <span class="literal">TRUE</span>)</span><br><span class="line">percent.ercc &lt;- Matrix::colSums(seu@raw.data[ercc.genes, ]) / Matrix::colSums(seu@raw.data)</span><br><span class="line"><span class="comment"># 添加新增的属性</span></span><br><span class="line">seu &lt;- AddMetaData(object = seu, metadata = percent.ercc,</span><br><span class="line">                   col.name = <span class="string">&quot;percent.ercc&quot;</span>)</span><br><span class="line">VlnPlot(object = seu, </span><br><span class="line">        features.plot = <span class="built_in">c</span>(<span class="string">&quot;nGene&quot;</span>, <span class="string">&quot;nUMI&quot;</span>, <span class="string">&quot;percent.ercc&quot;</span> ), </span><br><span class="line">        group.by = <span class="string">&#x27;g&#x27;</span>,</span><br><span class="line">        nCol = <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/szseuratVlnPlotbygeneumiercc.JPG"/>


<p>可以看出：细胞能检测到的基因数量与其含有的ERCC序列反相关。当组间的文库大小差异可忽略时，外源RNA多，计算后的内源RNA的比例自然是会下降的。</p>
<p><strong>进一步可视化基本信息</strong></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#VlnPlot(seu,group.by = &#x27;plate&#x27;,c(&quot;nGene&quot;,&quot;Gapdh&quot;,&quot;Bmp3&quot;))</span></span><br><span class="line"><span class="comment">#上面这段代码和下面的代码时同样的效果</span></span><br><span class="line">VlnPlot(object = seu, </span><br><span class="line">        features.plot = <span class="built_in">c</span>(<span class="string">&quot;nGene&quot;</span>, <span class="string">&quot;Gapdh&quot;</span>, <span class="string">&quot;Bmp3&quot;</span> ), </span><br><span class="line">        group.by = <span class="string">&#x27;plate&#x27;</span>,</span><br><span class="line">        nCol = <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/szseuratVlnPlotgenegapdhbmp3.JPG"/>
再次证明没有批次效应

<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">GenePlot(object = seu,  gene1 = <span class="string">&quot;nUMI&quot;</span>, gene2 = <span class="string">&quot;nGene&quot;</span>)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/szseuratGenePlotgeneumi.JPG"/>


<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">GenePlot(object = seu,  gene1 = <span class="string">&quot;Brca1&quot;</span>, gene2 = <span class="string">&quot;Brca2&quot;</span>)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/szseuratGenePlotbrca12.JPG"/>

<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">CellPlot(seu,seu@cell.names[<span class="number">3</span>], </span><br><span class="line">         seu@cell.names[<span class="number">4</span>],</span><br><span class="line">         do.ident = <span class="literal">FALSE</span>)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/szseuratCellPlotcell12.JPG"/>


<h2 id="表达矩阵标准化"><a href="#表达矩阵标准化" class="headerlink" title="表达矩阵标准化"></a>表达矩阵标准化</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">seu &lt;- NormalizeData(object = seu, </span><br><span class="line">                     normalization.method = <span class="string">&quot;LogNormalize&quot;</span>, </span><br><span class="line">                     scale.factor = <span class="number">10000</span>)</span><br><span class="line">seu@data[<span class="number">1</span>:<span class="number">4</span>,<span class="number">1</span>:<span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/szsueratnormalize.JPG"/>


<h2 id="挑选变化的基因"><a href="#挑选变化的基因" class="headerlink" title="挑选变化的基因"></a>挑选变化的基因</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这里需要理解  dispersion 值</span></span><br><span class="line">seu &lt;- FindVariableGenes(object = seu, </span><br><span class="line">                         mean.function = ExpMean, </span><br><span class="line">                         dispersion.function = LogVMR )</span><br><span class="line"><span class="comment">## 默认值是：x.low.cutoff = 0.1, x.high.cutoff = 8, y.cutoff = 1</span></span><br><span class="line"><span class="comment">## 根据经验阈值挑选的变化基因个数。</span></span><br><span class="line"><span class="built_in">length</span>( seu@var.genes)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/szsueratnormalize.JPG"/>


<h2 id="去除一些技术误差，比如-nUMI或者ERCC"><a href="#去除一些技术误差，比如-nUMI或者ERCC" class="headerlink" title="去除一些技术误差，比如 nUMI或者ERCC"></a>去除一些技术误差，比如 nUMI或者ERCC</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">head(seu@meta.data) </span><br><span class="line">seu &lt;- ScaleData(object = seu, </span><br><span class="line">                 vars.to.regress = <span class="built_in">c</span>(<span class="string">&quot;nUMI&quot;</span>,<span class="string">&#x27;nGene&#x27;</span>,<span class="string">&quot;percent.ercc&quot;</span> ))</span><br><span class="line"><span class="comment"># 后面就不需要考虑ERCC序列了。</span></span><br><span class="line">seu@scale.data[<span class="number">1</span>:<span class="number">4</span>,<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">pheatmap(as.matrix(seu@scale.data[gs,])) </span><br></pre></td></tr></table></figure>
<h2 id="普通PCA降维"><a href="#普通PCA降维" class="headerlink" title="普通PCA降维"></a>普通PCA降维</h2><p>用前面挑选的有变化的基因进行降维</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">seu &lt;- RunPCA(object = seu, pc.genes = seu@var.genes, </span><br><span class="line">              do.print = <span class="literal">TRUE</span>, pcs.print = <span class="number">1</span>:<span class="number">5</span>, </span><br><span class="line">              genes.print = <span class="number">5</span>)</span><br><span class="line">tmp &lt;- seu@dr$pca@gene.loadings</span><br><span class="line">head(tmp)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/szseuratpc1-20.JPG"/>


<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">VizPCA( seu, pcs.use = <span class="number">1</span>:<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">PCAPlot(seu, dim.1 = <span class="number">1</span>, dim.2 = <span class="number">2</span>,group.by = <span class="string">&#x27;plate&#x27;</span>)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/szseuratpcaplotbyplate.JPG"/>


<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">PCAPlot(seu, dim.1 = <span class="number">1</span>, dim.2 = <span class="number">2</span>,group.by = <span class="string">&#x27;g&#x27;</span>)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/szseuratpcaplotbyg.JPG"/>


<p><strong>根据不同组成份进行热图的展示</strong></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">seu &lt;- ProjectPCA(seu, do.print = <span class="literal">FALSE</span>)</span><br><span class="line"><span class="comment">#根据PC1进行可视化</span></span><br><span class="line">PCHeatmap(object = seu, pc.use = <span class="number">1</span>, cells.use = <span class="number">100</span>, </span><br><span class="line">          do.balanced = <span class="literal">TRUE</span>, label.columns = <span class="literal">FALSE</span>)</span><br><span class="line"><span class="comment">#使用pc.use = 1:10即批量展示前10各组成份的热图信息</span></span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/szseuratheatmappc1.JPG"/>

<p><strong>根据参数来调整最后的分组</strong></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#根据参数来调整最后的分组个数</span></span><br><span class="line"><span class="comment">#因为文章分为4群细胞，所以这里调整resolution的值为0.4，最后会得到4个组</span></span><br><span class="line"><span class="comment">#resolution很重要很重要很重要</span></span><br><span class="line">seu1 &lt;- FindClusters(object = seu, reduction.type = <span class="string">&quot;pca&quot;</span>, </span><br><span class="line">                    dims.use = <span class="number">1</span>:<span class="number">20</span>, force.recalc = <span class="built_in">T</span>,</span><br><span class="line">                    resolution = <span class="number">0.4</span>, print.output = <span class="number">0</span>, </span><br><span class="line">                    save.SNN = <span class="literal">TRUE</span>)</span><br><span class="line">PrintFindClustersParams(seu1)</span><br><span class="line">table(seu1@meta.data$res.0.4)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/szseuratfindcluster.JPG"/>


<h2 id="tSNE展示分组信息"><a href="#tSNE展示分组信息" class="headerlink" title="tSNE展示分组信息"></a>tSNE展示分组信息</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">## resolution 是最关键的参数</span></span><br><span class="line">seu=seu1</span><br><span class="line">seu &lt;- RunTSNE(object = seu, dims.use = <span class="number">1</span>:<span class="number">10</span>, do.fast = <span class="literal">TRUE</span>)</span><br><span class="line"><span class="comment"># note that you can set do.label=T to help label individual clusters</span></span><br><span class="line">TSNEPlot(object = seu, do.label=<span class="built_in">T</span>)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/szseurattSNEplotbypca.JPG" width="60%" height="60%">

<h2 id="对每个类别的细胞寻找marker基因"><a href="#对每个类别的细胞寻找marker基因" class="headerlink" title="对每个类别的细胞寻找marker基因"></a>对每个类别的细胞寻找marker基因</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">seu.markers &lt;- FindAllMarkers(object = seu, only.pos = <span class="literal">TRUE</span>, </span><br><span class="line">                              min.pct = <span class="number">0.25</span>, </span><br><span class="line">                              thresh.use = <span class="number">0.25</span>)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/seumaker0.JPG"  width="60%" height="60%">
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/seumaker1.JPG"  width="60%" height="60%">
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/seumaker2.JPG"  width="60%" height="60%">
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/seumaker3.JPG"  width="60%" height="60%">


<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(dplyr)</span><br><span class="line">top20 &lt;- seu.markers %&gt;% group_by(cluster) %&gt;% top_n(<span class="number">20</span>, avg_logFC)</span><br><span class="line"><span class="comment">#读入作者的4个亚群的top级的差异基因</span></span><br><span class="line">gs=read.table(<span class="string">&#x27;top18-genes-in-4-subgroup.txt&#x27;</span>)[,<span class="number">1</span>]</span><br><span class="line">gs</span><br><span class="line">intersect(top10$gene,gs)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/intersectgene.JPG"/>

<ul>
<li><strong>这时，你会发现用Seurat方法计算得到的差异基因和作者计算（自己写函数，并没有用到任何R包，有点搞不懂他为什么要这么做，还有一点小小的敬佩）得到的差异基因部分重合（37个共同基因）。</strong></li>
<li><strong>用不同的方法计算得到的差异基因都会有一定的差异，就转录组差异分析而言，limma、DESeq2、EdgeR三大差异分析包计算的差异基因也是部分重合的。</strong></li>
<li><strong>生信分析在一定程度上给研究者提供了方向，具体验证还是要落实到实验上。但是，干数据也很重要，没有方向怎么能行！所以呀，干数据和湿数据都要要，一个都不能少！</strong></li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">top20 &lt;- seu.markers %&gt;% group_by(cluster) %&gt;% top_n(<span class="number">20</span>, avg_logFC)</span><br><span class="line">intersect(top20$gene,gs)</span><br><span class="line">DoHeatmap(object = seu, genes.use = top20$gene, </span><br><span class="line">          slim.col.label = <span class="literal">TRUE</span>, remove.key = <span class="literal">TRUE</span>)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/DoHeatMap.JPG"/>

<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">FeaturePlot(object = seu, </span><br><span class="line">            features.plot =<span class="string">&quot;Rgs5&quot;</span>, </span><br><span class="line">            cols.use = <span class="built_in">c</span>(<span class="string">&quot;yellow&quot;</span>, <span class="string">&quot;red&quot;</span>), </span><br><span class="line">            reduction.use = <span class="string">&quot;tsne&quot;</span>,</span><br><span class="line">            no.legend=<span class="literal">FALSE</span></span><br><span class="line">            )</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/Rgs5.JPG" width="60%" height="60%">


<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">FeaturePlot(object = seu, </span><br><span class="line">            features.plot =<span class="string">&quot;Dcn&quot;</span>, </span><br><span class="line">            cols.use = <span class="built_in">c</span>(<span class="string">&quot;yellow&quot;</span>, <span class="string">&quot;red&quot;</span>), </span><br><span class="line">            reduction.use = <span class="string">&quot;tsne&quot;</span>,</span><br><span class="line">            no.legend=<span class="literal">FALSE</span></span><br><span class="line">            )</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/Dcn.JPG" width="60%" height="60%">


<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">FeaturePlot(object = seu, </span><br><span class="line">            features.plot =<span class="string">&quot;Pbk&quot;</span>, </span><br><span class="line">            cols.use = <span class="built_in">c</span>(<span class="string">&quot;yellow&quot;</span>, <span class="string">&quot;red&quot;</span>), </span><br><span class="line">            reduction.use = <span class="string">&quot;tsne&quot;</span>,</span><br><span class="line">            no.legend=<span class="literal">FALSE</span></span><br><span class="line">            )</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/Pbk.JPG" width="60%" height="60%">


<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">FeaturePlot(object = seu, </span><br><span class="line">            features.plot =<span class="string">&quot;Trf&quot;</span>, </span><br><span class="line">            cols.use = <span class="built_in">c</span>(<span class="string">&quot;yellow&quot;</span>, <span class="string">&quot;red&quot;</span>), </span><br><span class="line">            reduction.use = <span class="string">&quot;tsne&quot;</span>,</span><br><span class="line">            no.legend=<span class="literal">FALSE</span></span><br><span class="line">            )</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/Trf.JPG" width="60%" height="60%">



]]></content>
      <tags>
        <tag>NGS</tag>
      </tags>
  </entry>
  <entry>
    <title>sed 进阶</title>
    <url>/2020/03/09/sed-%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<p>多行命令、保持空间、排除命令、改变流、模式替代、在脚本中使用sed、创建sed实用程序</p>
<a id="more"></a>

<h1 id="sed进阶"><a href="#sed进阶" class="headerlink" title="sed进阶"></a>sed进阶</h1><h2 id="一、多行命令"><a href="#一、多行命令" class="headerlink" title="一、多行命令"></a>一、多行命令</h2><p><strong>sed编辑器包含了三个可用来处理多行文本的特殊命令。</strong></p>
<ul>
<li>N：将数据流中的下一行加进来创建一个多行组（multiline group）来处理 </li>
<li>D：删除多行组中的一行 </li>
<li>P：打印多行组中的一行<h3 id="（一）next命令"><a href="#（一）next命令" class="headerlink" title="（一）next命令"></a>（一）next命令</h3><h4 id="1、单行的next命令"><a href="#1、单行的next命令" class="headerlink" title="1、单行的next命令"></a>1、单行的next命令</h4></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#sed命令默认匹配所有符合条件的行</span></span><br><span class="line">sed <span class="string">&#x27;/^\s*$/d&#x27;</span> data1.txt</span><br><span class="line"><span class="comment">#模式匹配到含有header的那一行，n为跳到下一行，d为删掉n跳到的那行</span></span><br><span class="line">sed <span class="string">&#x27;/header/&#123;n;d&#125;&#x27;</span> data.txt</span><br><span class="line">sed <span class="string">&#x27;/data/&#123;n;d&#125;&#x27;</span> data.txt</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/1.1.JPG"/>


<h4 id="2、合并文本行"><a href="#2、合并文本行" class="headerlink" title="2、合并文本行"></a>2、合并文本行</h4><p>单行next命令会将数据流中的下一文本 行移动到sed编辑器的工作空间（称为模式空间）。<strong>多行版本的next命令（用大写N）会将下一文本行添加到模式空间中已有的文本后。</strong></p>
<p>这样的作用是<strong>将数据流中的两个文本行合并到同一个模式空间中</strong>。文本行仍然用换行符分隔，但sed编辑器现在会将两行文本当成一行来处理。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#sed编辑器脚本查找含有单词first的那行文本。找到该行后，它会用N命令将下一行合并到那 行，然后用替换命令s将换行符替换成空格</span></span><br><span class="line">sed <span class="string">&#x27;/first/&#123;N; s/\n/ /&#125;&#x27;</span> data2.txt</span><br><span class="line"><span class="comment">#一下两行代码效果一样。因为data3.txt中的System和Administrator间为换行符，所以使用N也没有用</span></span><br><span class="line">sed <span class="string">&#x27;s/System Administrator/Desktop User/&#x27;</span> data3.txt </span><br><span class="line">sed <span class="string">&#x27;N; s/System Administrator/Desktop User/&#x27;</span> data3.txt </span><br><span class="line"><span class="comment">#替换命令在System和Administrator之间用了通配符模式（.）来匹配空格和换行符,当它匹配了换行符时，它就从字符串中删掉了换行符，导致两行合并成一行</span></span><br><span class="line">sed <span class="string">&#x27;N; s/System.Administrator/Desktop User/&#x27;</span> data3.txt</span><br><span class="line"><span class="comment">#可以用一下方式避免两行匹配</span></span><br><span class="line">sed <span class="string">&#x27;N</span></span><br><span class="line"><span class="string">&gt; s/System\nAdministrator/Desktop\nUser/</span></span><br><span class="line"><span class="string">&gt; s/System Administrator/Desktop User/</span></span><br><span class="line"><span class="string">&gt; &#x27;</span> data3.txt</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/1.2.1.JPG"/>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#这个脚本总是在执行sed编辑器命令前将下一行文本读入到模式空间。当它到了最后一行文本时，就没有下一行可读了，所以N命令会叫sed编辑器停止。如果要匹配的文本正好在数据流的最后一行上，命令就不会发现要匹配的数据。 </span></span><br><span class="line">sed <span class="string">&#x27;N</span></span><br><span class="line"><span class="string">s/System\nAdministrator/Desktop\nUser/</span></span><br><span class="line"><span class="string">s/System Administrator/Desktop User/</span></span><br><span class="line"><span class="string">&#x27;</span> data4.txt</span><br><span class="line"><span class="comment">#由于System Administrator文本出现在了数据流中的后一行，N命令会错过它，因为没有其他行可读入到模式空间跟这行合并。将单行命令放到N命令前面，并将多行命令放到N命令后面就可以得到理想的结果。</span></span><br><span class="line">sed <span class="string">&#x27;</span></span><br><span class="line"><span class="string">&gt; s/System Administrator/Desktop User/</span></span><br><span class="line"><span class="string">&gt; N</span></span><br><span class="line"><span class="string">&gt; s/System\nAdministrator/Desktop User/</span></span><br><span class="line"><span class="string">&gt; &#x27;</span> data4.txt</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/1.2.2.JPG"/>

<h3 id="（二）多行删除命令"><a href="#（二）多行删除命令" class="headerlink" title="（二）多行删除命令"></a>（二）多行删除命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#很奇怪，我的centos7环境下 sed &#x27;/^$/d&#x27; data5.txt似乎失灵了。</span></span><br><span class="line"><span class="comment">#删除所有空白行</span></span><br><span class="line">sed <span class="string">&#x27;/^\s*$/d&#x27;</span> data5.txt</span><br><span class="line"><span class="comment">#sed编辑器脚本会查找空白行，然后用N命令来将下一文本行添加到模式空间。如果新的模式空间内容含有单词header，则D命令会删除模式空间中的第一行。</span></span><br><span class="line">sed <span class="string">&#x27;/^\s*$/&#123;N; /header/D&#125;&#x27;</span> data5.txt</span><br><span class="line">sed <span class="string">&#x27;/^\s*$/&#123;N; /last/D&#125;&#x27;</span> data5.txt</span><br><span class="line"><span class="comment">#删除命令会在不同的行中查找单词System和Administrator，然后在模式空间中将两行都删掉。 </span></span><br><span class="line">sed <span class="string">&#x27;N; /System\nAdministrator/d&#x27;</span> data4.txt</span><br><span class="line"><span class="comment">#sed编辑器提供了多行删除命令D，它只删除模式空间中的第一行。该命令会删除到换行符（含换行符）为止的所有字符。</span></span><br><span class="line">sed <span class="string">&#x27;N; /System\nAdministrator/D&#x27;</span> data4.txt</span><br></pre></td></tr></table></figure>
<p>如果不结合使用N命令和D命令， 就不可能在不删除其他空白行的情况下只删除第一个空白行。 </p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/1.2D.JPG"/>

<h3 id="（三）多行打印命令"><a href="#（三）多行打印命令" class="headerlink" title="（三）多行打印命令"></a>（三）多行打印命令</h3><p>当多行匹配出现时，P命令只会打印模式空间中的第一行。<br><code>-n</code>选项禁止标准输出，值输出P的内容。</p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/1.3.JPG"/>

<h2 id="二、保存空间"><a href="#二、保存空间" class="headerlink" title="二、保存空间"></a>二、保存空间</h2><ul>
<li>模式空间（pattern space）是一块活跃的缓冲区，在sed编辑器执行命令时它会保存待检查的文本。但它并不是sed编辑器保存文本的唯一空间。</li>
<li>sed编辑器有另一块称作保持空间（hold space）的缓冲区域。在处理模式空间中的某些行时，可以用保持空间来临时保存一些行。</li>
<li></li>
</ul>
<p><strong><code>p</code>命令是打印当前模式空间的内容</strong></p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/2.1.JPG"/>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -n <span class="string">&#x27;/first/&#123;h;p;n;p;g;p&#125;&#x27;</span> data2.txt</span><br></pre></td></tr></table></figure>
<ul>
<li>sed脚本在地址中用正则表达式来过滤出含有单词first的行</li>
<li>当含有单词first的行出现时，h命令将该行放到保持空间</li>
<li>p命令打印模式空间也就是第一个数据行的内容</li>
<li>n命令提取数据流中的下一行（This is the second data line），并将它放到模式空间</li>
<li>p命令打印模式空间的内容，现在是第二个数据行</li>
<li>g命令将保持空间的内容（This is the first data line）放回模式空间，替换当前文本</li>
<li>p命令打印模式空间的当前内容，现在变回第一个数据行了</li>
</ul>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/2.2.JPG"/>

<h2 id="三、排除命令"><a href="#三、排除命令" class="headerlink" title="三、排除命令"></a>三、排除命令</h2><p>感叹号命令（!）用来排除（negate）命令，也就是让原本会起作用的命令不起作用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#打印模式匹配的行</span></span><br><span class="line">sed -n <span class="string">&#x27;/header/p&#x27;</span> data2.txt</span><br><span class="line"><span class="comment">#打印除了模式匹配的行</span></span><br><span class="line">sed -n <span class="string">&#x27;/header/!p&#x27;</span> data2.txt</span><br><span class="line"><span class="comment">#N命令会在最后一行结束，因为后面没有更多的行与最后一行合并了</span></span><br><span class="line">sed <span class="string">&#x27;N</span></span><br><span class="line"><span class="string">s/System\nAdministrator/Desktop\nUser/</span></span><br><span class="line"><span class="string">s/System Administrator/Desktop User/</span></span><br><span class="line"><span class="string">&#x27;</span> data4.txt</span><br><span class="line"><span class="comment">#N命令可以作用于除了最后一行的所有行</span></span><br><span class="line">sed <span class="string">&#x27;$!N</span></span><br><span class="line"><span class="string">s/System\nAdministrator/Desktop\nUser/</span></span><br><span class="line"><span class="string">s/System Administrator/Desktop User/</span></span><br><span class="line"><span class="string">&#x27;</span> data4.txt</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/3.1.JPG"/>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat data2.txt</span><br><span class="line"><span class="comment">#倒序输出文本内容</span></span><br><span class="line">tac data2.txt</span><br><span class="line"><span class="comment">#也可以用sed命令实现倒序输出，既打印最后一次的模式空间的内容</span></span><br><span class="line">sed -n <span class="string">&#x27;&#123;1!G;h;$p&#125;&#x27;</span> data2.txt</span><br><span class="line"><span class="comment">#可以查看每次模式空间的内容</span></span><br><span class="line">sed -n <span class="string">&#x27;&#123;1!G;h;p&#125;&#x27;</span> data2.txt</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/3.2.JPG"/>

<h2 id="四、改变流"><a href="#四、改变流" class="headerlink" title="四、改变流"></a>四、改变流</h2><h3 id="（一）、分支"><a href="#（一）、分支" class="headerlink" title="（一）、分支"></a>（一）、分支</h3><p>将模式匹配的行定义一个标签，满足模式匹配的行执行标签后的命令，不满足模式匹配的行执行非标签后的命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#此处没有定义标签，既满足模式匹配的行不进行任何操作，其他行执行给定的替换操作</span></span><br><span class="line">sed <span class="string">&#x27;&#123;2,3b;s/This is/Is this/;s/line./test?/&#125;&#x27;</span> data2.txt </span><br><span class="line"><span class="comment">#以下三种方法效果一样</span></span><br><span class="line"><span class="comment">#①</span></span><br><span class="line">sed <span class="string">&#x27;&#123;/header/b lable; s/This is/Is this/</span></span><br><span class="line"><span class="string">:lable                     </span></span><br><span class="line"><span class="string">s/This is/THIS IS/&#125;&#x27;</span> data2.txt</span><br><span class="line"><span class="comment">#②</span></span><br><span class="line">sed <span class="string">&#x27;&#123;/header/b lable;s/This is/Is this/;s/line./test?/;:lable s/This is/THIS IS/&#125;&#x27;</span> data2.txt </span><br><span class="line"><span class="comment">#③</span></span><br><span class="line">sed <span class="string">&#x27;/header/b lable;s/This is/Is this/;s/line./test?/;:lable s/This is/THIS IS/&#x27;</span> data2.txt </span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/4.1.JPG"/>

<p>上面的例子演示了跳转到sed脚本后面的标签上。也可以跳转到脚本中靠前面的标签上，这样就达到了<strong>循环</strong>的效果。 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#此方法会形成了一个无穷循环，不停地查找逗号，直到使用Ctrl+C组合键发送一个信号， 手动停止这个脚本</span></span><br><span class="line"><span class="variable">$echo</span> <span class="string">&quot;I, like, my, teacher, Li.&quot;</span>|sed -n <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">:lable</span></span><br><span class="line"><span class="string">s/,//1p</span></span><br><span class="line"><span class="string">b lable&#125;&#x27;</span></span><br><span class="line"><span class="comment">#加上模式匹配，就会在模式匹配是执行替换命令，无法匹配时停止脚本</span></span><br><span class="line"><span class="variable">$echo</span> <span class="string">&quot;I, like, my, teacher, Li.&quot;</span>|sed -n <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">:lable</span></span><br><span class="line"><span class="string">s/,//1p</span></span><br><span class="line"><span class="string">/,/b lable&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/4.2.JPG"/>

<h3 id="（二）测试"><a href="#（二）测试" class="headerlink" title="（二）测试"></a>（二）测试</h3><p>测试命令会根据替换命令的结果跳转到某个标签，而不是根据地址进行跳转</p>
<p>测试命令使用与分支命令相同的格式：</p>
<p>[address]t [label] </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#第一个替换命令会查找模式文本first。如果匹配了行中的模式，它就会替换文本，而且测 试命令会跳过后面的替换命令。如果第一个替换命令未能匹配模式，第二个替换命令就会被执行</span></span><br><span class="line">sed <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">s/first/matched/</span></span><br><span class="line"><span class="string">t</span></span><br><span class="line"><span class="string">s/This is the/No match on/&#125;&#x27;</span> data2.txt</span><br><span class="line"><span class="comment">#如果替换命令成功匹配并替换了一个模式，测试命令就会跳转到指定的标签。如果替换命令 未能匹配指定的模式，测试命令就不会跳转。</span></span><br><span class="line"><span class="comment">#有了测试命令，就能结束之前用分支命令形成的无限循环。  </span></span><br><span class="line"><span class="variable">$echo</span> <span class="string">&quot;I, like, my, teacher, Li.&quot;</span>|sed -n <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">&gt; :lable</span></span><br><span class="line"><span class="string">&gt; s/,//p</span></span><br><span class="line"><span class="string">&gt; t lable&#125;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/4.3.JPG"/>


<h2 id="五、模式替代"><a href="#五、模式替代" class="headerlink" title="五、模式替代"></a>五、模式替代</h2><h3 id="（一）-amp-符号"><a href="#（一）-amp-符号" class="headerlink" title="（一）&amp;符号"></a>（一）&amp;符号</h3><p>匹配模式中的一个单 词，那就非常简单。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;The cat sleeps in his hat.&quot;</span> | sed <span class="string">&#x27;s/cat/&quot;cat&quot;/&#x27;</span> </span><br></pre></td></tr></table></figure>
<p>但如果你在模式中用通配符（.）来匹配多个单词呢?</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#默认替换匹配的第一个</span></span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;The cat sleeps in his hat.&quot;</span> | sed <span class="string">&#x27;s/.at/&quot;.at&quot;/&#x27;</span> </span><br><span class="line"><span class="comment">#加上g就可以全局匹配</span></span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;The cat sleeps in his hat.&quot;</span> | sed <span class="string">&#x27;s/.at/&quot;.at&quot;/g&#x27;</span> </span><br><span class="line"><span class="comment">#但是，只是想对符合.at模式的单词添加引号，而上述方法不能得到理想的结果</span></span><br></pre></td></tr></table></figure>
<p><code>&amp;</code>符号可以用来代表替换命令中的匹配的模式。不管模式匹 配的是什么样的文本，你都可以在替代模式中使用&amp;符号来使用这段文本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;The cat sleeps in his hat.&quot;</span> | sed <span class="string">&#x27;s/.at/&quot;&amp;&quot;/g&#x27;</span> </span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/5.1.JPG"/>


<h3 id="（二）、代替单独的单词"><a href="#（二）、代替单独的单词" class="headerlink" title="（二）、代替单独的单词"></a>（二）、代替单独的单词</h3><p>当在替换命令中使用圆括号时，必须用转义字符将它们标示为分组字符而不是普通的圆 括号。这跟转义其他特殊字符正好相反。 </p>
<p>sed编辑器用圆括号来定义替换模式中的子模式。你可以在替代模式中使用特殊字符来引用 每个子模式。替代字符由反斜线和数字组成。数字表明子模式的位置。sed编辑器会给第一个子 模式分配字符\1，给第二个子模式分配字符\2，依此类推。</p>
<p>第一个例子中直接将sleeps替换为空，但其后面的空格依然保留了，用子模式的方法就可以很好的解决。</p>
<p>第二个例子中想要在teacher和Li之间加上<code>，</code>号</p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/5.2.JPG"/>


<h2 id="六、在脚本中使用sed"><a href="#六、在脚本中使用sed" class="headerlink" title="六、在脚本中使用sed"></a>六、在脚本中使用sed</h2><h3 id="（一）、使用包装脚本"><a href="#（一）、使用包装脚本" class="headerlink" title="（一）、使用包装脚本"></a>（一）、使用包装脚本</h3><p>命令行的方法倒序文本内容。</p>
<p>脚本的方法倒序文本内容。</p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/6.1.JPG"/>


<h3 id="（二）、重定向sed的输出"><a href="#（二）、重定向sed的输出" class="headerlink" title="（二）、重定向sed的输出"></a>（二）、重定向sed的输出</h3><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/6.2.JPG"/>


<h2 id="七、创建sed实用工具"><a href="#七、创建sed实用工具" class="headerlink" title="七、创建sed实用工具"></a>七、创建sed实用工具</h2><h3 id="（一）、加倍行间距"><a href="#（一）、加倍行间距" class="headerlink" title="（一）、加倍行间距"></a>（一）、加倍行间距</h3><p>向文本文件的行间插入空白行的简单sed脚本。</p>
<p>G命令会简单地将保持空 间内容附加到模式空间内容后。当启动sed编辑器时，保持空间只有一个空行。将它附加到已有 行后面，你就在已有行后面创建了一个空白行。</p>
<p>如果不想要这个空白行，可以用排除符号（!）和尾行符号（$）来确 保脚本不会将空白行加到数据流的后一行后面。 </p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/7.1.JPG"/>


<h3 id="（二）、对含有空白行的文件加行间距"><a href="#（二）、对含有空白行的文件加行间距" class="headerlink" title="（二）、对含有空白行的文件加行间距"></a>（二）、对含有空白行的文件加行间距</h3><p>直接用G命令会发现：在原来空白行的位置有了三个空白行。这个问题的解决办法是，首先删除数据流中的所有空白行，然后用G命令在所有行后插入新的空白行。要删除已有的空白行，需要将d命令和一个匹配空白行的模式一起使用。 </p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/7.2.JPG"/>


<h3 id="（三）、给文件中的行编号"><a href="#（三）、给文件中的行编号" class="headerlink" title="（三）、给文件中的行编号"></a>（三）、给文件中的行编号</h3><p>有些bash shell命令也可以添加行号，但它们会另外加入一些东西（有可能是不需要的间隔）。</p>
<p>可以用等号<code>=</code>来显示数据流中行的行号，但阅读上不友好。</p>
<p>另一种办法是：在获得了等号命令的输出之后，你可以通过管道将输出传给另一个sed编辑器脚本，它会使用N命令来合并这两行。还需要用替换命令将换行符更换成空格或制表符。</p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/7.3.JPG"/>


<h3 id="（四）、打印末尾行"><a href="#（四）、打印末尾行" class="headerlink" title="（四）、打印末尾行"></a>（四）、打印末尾行</h3><p>循环N命令和D命令，你在向模式空间的文本行块增加新行的同时也删除了旧行。分支命令非常适合这个循环。要结束循环，只要识别出后一行并用q命令退出就可以了。 </p>
<p>第一个sed脚本会首先检查这行是不是数据流中后一行。如果是，退出（quit）命令会停止循环。N命令会将下一行附加到模式空间中当前行之后。如果当前行在第2行后面，3,$D命令会删除模式空间中的第一行。这就会在模式空间中创建出滑动窗口效果。<br>第二个脚本，如果当前行在第3行后面，4,$D命令会删除模式空间中的第一行。<br>第三个脚本，如果当前行在第4行后面，5,$D命令会删除模式空间中的第一行。</p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/7.4.JPG"/>

<h3 id="（五）、删除行"><a href="#（五）、删除行" class="headerlink" title="（五）、删除行"></a>（五）、删除行</h3><p><strong>1、删除连续的空白行</strong></p>
<p>区间是/./到/^$/。区间的开始地址会匹配任何含有至少一个字符的行。区间的结束地址会 匹配一个空行。在这个区间内的行不会被删除。 </p>
<p>如果开头有空白行的话，开头的空白行也会被删除</p>
<p><strong>2、删除开头的空白行</strong></p>
<p>/./,$!d 这个则表示从第一个字符到最后的内容统统不删除，即删除开头的空白行。</p>
<p><strong>3、删除结尾的空白行</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;&#123; :start /^\n*$/&#123;$d; N; b start &#125; &#125;&#x27;</span> </span><br></pre></td></tr></table></figure>
<p>在正常脚本的花括号里还有花括号。这允许你在整个命令脚本 中将一些命令分组。该命令组会被应用在指定的地址模式上。地址模式能够匹配只含有一个换行 符的行。如果找到了这样的行，而且还是后一行，删除命令会删掉它。如果不是后一行，N 命令会将下一行附加到它后面，分支命令会跳到循环起始位置重新开始。 </p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/7.5.JPG"/>


<h3 id="六-、删除HTML标签"><a href="#六-、删除HTML标签" class="headerlink" title="(六)、删除HTML标签"></a>(六)、删除HTML标签</h3><p>s/&lt;.*&gt;//g 这种匹配模式会删掉<title>This is the page title</title>等。</p>
<p>s/&lt;[^&gt;]*&gt;//g 这种模式才能解决问题。</p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/7.6.JPG"/>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>sed编辑器基础</title>
    <url>/2020/03/07/sed%E7%BC%96%E8%BE%91%E5%99%A8%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>sed编辑器更多的命令和格式：<br>更多的替换选项、使用地址、删除行、插入和附加文本、修改行、转换命令、打印、使用sed处理文件</p>
<a id="more"></a>

<h1 id="sed编辑器基础"><a href="#sed编辑器基础" class="headerlink" title="sed编辑器基础"></a>sed编辑器基础</h1><h2 id="更多的替换选项"><a href="#更多的替换选项" class="headerlink" title="更多的替换选项"></a>更多的替换选项</h2><h3 id="1、替换标记"><a href="#1、替换标记" class="headerlink" title="1、替换标记"></a>1、替换标记</h3><p>替换命令在替换多行中的文本时能正常工作，但默认情况下它只替换每行中出现的第一处。要让替换命令能够替换一行中不同地方出现的文本必须使用替换标记（substitution flag）。</p>
<p>s/pattern/replacement/flags</p>
<p>有4种可用的替换标记： </p>
<ul>
<li>数字，表明新文本将替换第几处模式匹配的地方 </li>
<li>g，表明新文本将会替换所有匹配的文本 </li>
<li>p，表明原先行的内容要打印出来 </li>
<li>w file，将替换的结果写到文件中</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#默认情况下sed只替换每行中出现的第一处。</span></span><br><span class="line">sed <span class="string">&#x27;s/test/trial/&#x27;</span> sed1.txt</span><br><span class="line"><span class="comment">#sed替换每行中第二初匹配的地方。</span></span><br><span class="line">sed <span class="string">&#x27;s/test/trial/2&#x27;</span> sed1.txt</span><br><span class="line"><span class="comment">#替换所有匹配的文本。</span></span><br><span class="line">sed <span class="string">&#x27;s/test/trial/g&#x27;</span> sed1.txt</span><br><span class="line"><span class="comment">#p替换标记会输出修改过的行。</span></span><br><span class="line"><span class="comment">#sed命令的正常输出就是STANDOUT。</span></span><br><span class="line">sed <span class="string">&#x27;s/test/trial/p&#x27;</span> sed1.txt</span><br><span class="line"><span class="comment">#p替换标记会输出修改过的行。</span></span><br><span class="line">sed <span class="string">&#x27;s/test/trial/p&#x27;</span> sed2.txt</span><br><span class="line"><span class="comment">#-n选项将禁止sed编辑器输出。但p替换标记会输出修改过的行。将二者配合使用的效果就是只输出被替换命令修改过的行。</span></span><br><span class="line">sed -n <span class="string">&#x27;s/test/trial/p&#x27;</span> sed2.txt</span><br><span class="line"><span class="comment">#sed编辑器的正常输出是在STDOUT中，只有那些包含匹配模式的行才会保存在指定的输出文件中。</span></span><br><span class="line">sed <span class="string">&#x27;s/test/trial/w test.txt&#x27;</span> sed2.txt</span><br><span class="line">cat test.txt</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/sed1.jpg"/>

<h3 id="2、替换字符"><a href="#2、替换字符" class="headerlink" title="2、替换字符"></a>2、替换字符</h3><p>有时你会在文本字符串中遇到一些不太方便在替换模式中使用的字符。Linux中一个常见的 例子就是正斜线（/），由于正斜线通常用作字符串分隔符，因而如果它出现在了模式文本中的话，必须用反斜线来转义。</p>
<p>要解决这个问题，sed编辑器允许选择其他字符来作为替换命令中的字符串分隔符（与需要替换的转义字符不一致的一般都可以）。<br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/sed1.2.jpg"/></p>
<h2 id="使用地址"><a href="#使用地址" class="headerlink" title="使用地址"></a>使用地址</h2><p>默认情况下，在sed编辑器中使用的命令会作用于文本数据的所有行。如果只想将命令作用 于特定行或某些行，则必须用行寻址（line addressing）。 </p>
<p>在sed编辑器中有两种形式的行寻址： </p>
<ul>
<li>以数字形式表示行区间 </li>
<li>用文本模式来过滤出行 </li>
</ul>
<h3 id="1、数字方式的行寻址"><a href="#1、数字方式的行寻址" class="headerlink" title="1、数字方式的行寻址"></a>1、数字方式的行寻址</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat test1.txt</span><br><span class="line">sed <span class="string">&#x27;s/dog/cat/&#x27;</span> test1.txt</span><br><span class="line">sed <span class="string">&#x27;2s/dog/cat/&#x27;</span> test1.txt</span><br><span class="line">sed <span class="string">&#x27;2,4s/dog/cat/&#x27;</span> test1.txt</span><br><span class="line">sed <span class="string">&#x27;2,$/dog/cat/&#x27;</span> test1.txt</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/sed2.1.jpg"/>


<h3 id="2、使用文本模式过滤器"><a href="#2、使用文本模式过滤器" class="headerlink" title="2、使用文本模式过滤器"></a>2、使用文本模式过滤器</h3><p><code>/pattern/command</code>必须用正斜线将要指定的pattern封起来。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#方法一</span></span><br><span class="line">cat /etc/passwd|tail | sed <span class="string">&#x27;/apache/s/nologin/modification/&#x27;</span> </span><br><span class="line"><span class="comment">#方法二</span></span><br><span class="line">cat /etc/passwd|tail | sed <span class="string">&#x27;/apache/s$nologin$modification$&#x27;</span></span><br><span class="line">sed <span class="string">&#x27;/root/s/bash/modification/&#x27;</span> /etc/passwd</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/sed2.2.jpg"/>

<h3 id="3、命令组合"><a href="#3、命令组合" class="headerlink" title="3、命令组合"></a>3、命令组合</h3><p>如果需要在单行上执行多条命令，可以用花括号将多条命令组合在一起。sed编辑器会处理 地址行处列出的每条命令。 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;2&#123;</span></span><br><span class="line"><span class="string">&gt; s/fox/elephant/</span></span><br><span class="line"><span class="string">&gt; s/dog/cat/</span></span><br><span class="line"><span class="string">&gt; &#125;&#x27;</span> test1.txt</span><br><span class="line"></span><br><span class="line">sed <span class="string">&#x27;3,$&#123;</span></span><br><span class="line"><span class="string">&gt; s/fox/elephant/</span></span><br><span class="line"><span class="string">&gt; s/dog/cat/</span></span><br><span class="line"><span class="string">&gt; &#125;&#x27;</span> test1.txt</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/sed2.3.jpg"/>

<h3 id="3、删除行"><a href="#3、删除行" class="headerlink" title="3、删除行"></a>3、删除行</h3><ul>
<li>指定地址</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#不加入寻址模式，流中的所有文本行都会被删除</span></span><br><span class="line">sed <span class="string">&#x27;d&#x27;</span> test2.txt</span><br><span class="line"><span class="comment">#加入寻址模式</span></span><br><span class="line">sed <span class="string">&#x27;3d&#x27;</span> test2.txt</span><br><span class="line">sed <span class="string">&#x27;3,5d&#x27;</span> test2.txt</span><br><span class="line">sed <span class="string">&#x27;3,$d&#x27;</span> test2.txt</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/sed3.1.JPG"/>

<ul>
<li>模式匹配</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;/line 2/d&#x27;</span> test2.txt</span><br><span class="line"><span class="comment">#只要符合匹配模式的行都会被删除，所以下面的命令会删除2行</span></span><br><span class="line">sed <span class="string">&#x27;/line 1/d&#x27;</span> test2.txt</span><br><span class="line"><span class="comment">#指定的第一个模式 会“打开”行删除功能，第二个模式会“关闭”行删除功能</span></span><br><span class="line">sed <span class="string">&#x27;/2/,/4/d&#x27;</span> test2.txt</span><br><span class="line"><span class="comment">#因为有两行都匹配到1了，而第二个匹配到的1匹配不到“关闭的模式”，所以后面的内容统统删掉了</span></span><br><span class="line">sed <span class="string">&#x27;/1/,/3/d&#x27;</span> test2.txt</span><br><span class="line">sed <span class="string">&#x27;/1/,/6/d&#x27;</span> test2.txt</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/sed3.2.JPG"/>

<h2 id="插入和附加文本"><a href="#插入和附加文本" class="headerlink" title="插入和附加文本"></a>插入和附加文本</h2><ul>
<li>插入（insert）命令（i）会在指定行前增加一个新行</li>
<li>附加（append）命令（a）会在指定行后增加一个新行</li>
</ul>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/sed4.2.JPG"/>

<p>要向数据流行内部插入或附加数据，必须用寻址来告诉sed编辑器你想让数据出现在什么位置。可以在用这些命令时只指定一个行地址。可以匹配一个数字行号或文本模式，但不能用地址区间。</p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/sed4.1.JPG"/>


<h2 id="修改行"><a href="#修改行" class="headerlink" title="修改行"></a>修改行</h2><p>修改（change）命令允许修改数据流中整行文本的内容。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将第一句修改为I like teacher Li.</span></span><br><span class="line"><span class="comment">#方法一：行定位需要修改的行</span></span><br><span class="line">sed <span class="string">&#x27;1c\I like teacher Li.&#x27;</span> test2.txt</span><br><span class="line"><span class="comment">#方法二：模式匹配定位需要修改的行</span></span><br><span class="line">sed <span class="string">&#x27;/line 1/c\I like teacher Li.&#x27;</span> test2.txt</span><br><span class="line"><span class="comment">#将1至6行都修改为I like teacher Li.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>♥因为1至6行都跟teacher Li无关，所以要强行修改一下 ♥</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed &#39;1,6c\I like teacher Li.&#39; test2.txt</span><br></pre></td></tr></table></figure>

<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/sed5.JPG"/>

<h2 id="转换命令"><a href="#转换命令" class="headerlink" title="转换命令"></a>转换命令</h2><p>转换（transform）命令（y）是唯一可以处理单个字符的sed编辑器命令。</p>
<p>[address]y/inchars/outchars/ </p>
<p>转换命令会对inchars和outchars值进行一对一的映射。inchars中的第一个字符会被转 换为outchars中的第一个字符，第二个字符会被转换成outchars中的第二个字符。这个映射过 程会一直持续到处理完指定字符。如果inchars和outchars的长度不同，则sed编辑器会产生一条错误消息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#会发现转换命令是全局的</span></span><br><span class="line">sed <span class="string">&#x27;y/123/456&#x27;</span> test2.txt</span><br><span class="line"><span class="comment">#匹配行进行修改</span></span><br><span class="line">sed <span class="string">&#x27;1y/1/6&#x27;</span> test2.txt</span><br><span class="line">sed <span class="string">&#x27;6y/1/6&#x27;</span> test2.txt</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/sed6.JPG"/>

<h2 id="回顾打印"><a href="#回顾打印" class="headerlink" title="回顾打印"></a>回顾打印</h2><ul>
<li>p命令用来打印文本行 </li>
<li>等号（=）命令用来打印行号</li>
<li>l（小写的L）命令用来列出行</li>
</ul>
<h3 id="1、打印行"><a href="#1、打印行" class="headerlink" title="1、打印行"></a>1、打印行</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#模式匹配到的行打印出来</span></span><br><span class="line">sed -n <span class="string">&#x27;/li/p&#x27;</span> test2.txt</span><br><span class="line"><span class="comment">#行数匹配到的行打印出来</span></span><br><span class="line">sed -n <span class="string">&#x27;7,8p&#x27;</span> tets2.txt</span><br><span class="line"><span class="comment">#打印出修改之前的行和修改之后的行</span></span><br><span class="line">sed -n <span class="string">&#x27;/qinqin/&#123;</span></span><br><span class="line"><span class="string">&gt; p</span></span><br><span class="line"><span class="string">&gt; s/meimei/baobei/p</span></span><br><span class="line"><span class="string">&gt; &#125;&#x27;</span> test2.txt</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/sed7.1.JPG"/>

<h3 id="2、打印行号"><a href="#2、打印行号" class="headerlink" title="2、打印行号"></a>2、打印行号</h3><p>等号命令会打印行在数据流中的当前行号。行号由数据流中的换行符决定。每次数据流中出 现一个换行符，sed编辑器会认为一行文本结束了。 </p>
<p>在数据流中查找特定文本模式的行，并将其与行号一起打印出来。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -n <span class="string">&#x27;/Li/&#123;</span></span><br><span class="line"><span class="string">&gt; =</span></span><br><span class="line"><span class="string">&gt; p</span></span><br><span class="line"><span class="string">&#125;&#x27;</span> test2.txt</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/sed7.2.JPG"/>


<h2 id="使用sed处理文件"><a href="#使用sed处理文件" class="headerlink" title="使用sed处理文件"></a>使用sed处理文件</h2><h3 id="1、写入文件"><a href="#1、写入文件" class="headerlink" title="1、写入文件"></a>1、写入文件</h3><p>w命令用来向文件写入行。该命令的格式如下：</p>
<p>[address]w filename </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#支持行匹配和模式匹配</span></span><br><span class="line">sed <span class="string">&#x27;7,8w li.txt&#x27;</span> test2.txt</span><br><span class="line">sed <span class="string">&#x27;/Li/w Li.txt&#x27;</span> test2.txt</span><br><span class="line">sed -n <span class="string">&#x27;/qinqin/w qinqin.txt&#x27;</span> test2.txt</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/sed8.1.JPG"/>


<h3 id="2、从文件读取数据"><a href="#2、从文件读取数据" class="headerlink" title="2、从文件读取数据"></a>2、从文件读取数据</h3><p>已经了解了如何在sed命令行上向数据流中插入或附加文本。读取（read）命令（r）允许将一个独立文件中的数据插入到数据流中。 </p>
<p>读取命令的格式如下：</p>
<p>[address]r filename </p>
<p>支持行寻址和模式匹配</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;4r yinyu.txt&#x27;</span> friends.txt</span><br><span class="line">sed <span class="string">&#x27;4r yinyu.txt&#x27;</span> friends.txt</span><br><span class="line">sed <span class="string">&#x27;/yuqi/r yinyu.txt&#x27;</span> friends.txt</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/sed8.2.JPG"/>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;/friends/&#123;</span></span><br><span class="line"><span class="string">r friends.txt</span></span><br><span class="line"><span class="string">&#125;&#x27;</span> beautiful-people.txt</span><br><span class="line"></span><br><span class="line">sed <span class="string">&#x27;/friends/&#123;</span></span><br><span class="line"><span class="string">r friends.txt</span></span><br><span class="line"><span class="string">d&#125;&#x27;</span> beautiful-people.txt</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/sed8.3.JPG"/>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>初步认识sed和gwak</title>
    <url>/2020/03/07/%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86sed%E5%92%8Cgwak/</url>
    <content><![CDATA[<p>想在shell脚本中处理任何类型的数据，就要熟悉Linux中的sed和gawk工具。Linux世界中广泛使用的两个命令行编辑器：sed和gawk</p>
<a id="more"></a>

<h1 id="sed编辑器"><a href="#sed编辑器" class="headerlink" title="sed编辑器"></a>sed编辑器</h1><blockquote>
<p>sed编辑器被称作流编辑器（stream editor），和普通的交互式文本编辑器恰好相反。在交互式文本编辑器中（比如vim），你可以用键盘命令来交互式地插入、删除或替换数据中的文本。流编辑器则会在编辑器处理数据之前基于预先提供的一组规则来编辑数据流。</p>
</blockquote>
<h2 id="1-再命令行定义编辑器命令"><a href="#1-再命令行定义编辑器命令" class="headerlink" title="1.再命令行定义编辑器命令"></a>1.再命令行定义编辑器命令</h2><ul>
<li>可以直接讲数据通过管道得形式传给sed编辑器。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;This is a test&quot;</span>|sed <span class="string">&#x27;s/test/final test&#x27;</span></span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/基础sed1.JPG"/>

<p>sed编辑器并不会修改文本文件的数据。它只会将修改后的数据发送到 STDOUT。如果你查看原来的文本文件，它仍然保留着原始数据。 </p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/基础sed2.JPG"/>


<h2 id="2、在命令行使用多个编辑器命令"><a href="#2、在命令行使用多个编辑器命令" class="headerlink" title="2、在命令行使用多个编辑器命令"></a>2、在命令行使用多个编辑器命令</h2><ul>
<li>要在sed命令行上执行多个命令时，只要用-e选项就可以了。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#多条命令间用分号隔开，分号和命令间不能有空格</span></span><br><span class="line">sed -e <span class="string">&#x27;s/brown/green/;s/dog/cat/&#x27;</span> test1.txt</span><br><span class="line"><span class="comment">#也可以用此提示符来分隔命令</span></span><br><span class="line">sed -e <span class="string">&#x27;</span></span><br><span class="line"><span class="string">&gt; s/brown/green/</span></span><br><span class="line"><span class="string">&gt; s/fox/algea/</span></span><br><span class="line"><span class="string">&gt; s/dog/cat/&#x27;</span> test1.txt</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/基础sed3.JPG"/>

</li>
</ul>
<h2 id="3、从文件中读取编辑器命令"><a href="#3、从文件中读取编辑器命令" class="headerlink" title="3、从文件中读取编辑器命令"></a>3、从文件中读取编辑器命令</h2><ul>
<li>如果有大量要处理的sed命令，那么将它们放进一个单独的文件中通常会更方便一些。 可以在sed命令中用-f选项来指定文件。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -f script1.sed test1.txt</span><br></pre></td></tr></table></figure>
<p>用.sed作为sed脚本文件的扩展名，以避免与bash shell脚本文件搞混。</p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/基础sed4.JPG"/>


<h1 id="gawk程序"><a href="#gawk程序" class="headerlink" title="gawk程序"></a>gawk程序</h1><h2 id="1、gawk命令格式"><a href="#1、gawk命令格式" class="headerlink" title="1、gawk命令格式"></a>1、gawk命令格式</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gawk options program file</span><br></pre></td></tr></table></figure>
<h2 id="2、从命令行读取程序脚本"><a href="#2、从命令行读取程序脚本" class="headerlink" title="2、从命令行读取程序脚本"></a>2、从命令行读取程序脚本</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gawk <span class="string">&#x27;print &quot;I like teacher Li&quot;&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>由于程序脚本被设为显示一行固定的文 本字符串，因此不管你在数据流中输入什么文本，都会得到同样的文本输出。</p>
</li>
<li><p>bash shell提供了一个组合键来生成 EOF（End-of-File）字符。<code>Ctrl+D</code>组合键会在bash中产生一个EOF字符。这个组合键能够终止该gawk 程序并返回到命令行界面提示符下。</p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/基础gawk1.JPG"/>

</li>
</ul>
<h2 id="3、使用数据字段变量"><a href="#3、使用数据字段变量" class="headerlink" title="3、使用数据字段变量"></a>3、使用数据字段变量</h2><ul>
<li>$0代表整个文本行</li>
<li>$1代表文本行中的第1个数据字段 </li>
<li>$2代表文本行中的第2个数据字段 </li>
<li>$n代表文本行中的第n个数据字段</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gawk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span> test1.txt</span><br><span class="line">gawk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> test1.txt</span><br></pre></td></tr></table></figure>
<p>gawk中默认的字段分隔符是任意的空白字符（例如空格或制表符）。</p>
<p>如果你要读取采用了其他字段分隔符的文件，可以用-F选项指定。</p>
<p>/etc/passwd文件用冒号来分隔数字字段，因而如果要划分开每个数据元素，则必须在gawk选项中将冒号指定为字段分隔符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;etc&#x2F;passwd</span><br><span class="line">gawk -F: &#39;&#123;print $1&#125;&#39; &#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/基础gawk2.JPG"/>

<h2 id="4、在程序脚本中使用多个命令"><a href="#4、在程序脚本中使用多个命令" class="headerlink" title="4、在程序脚本中使用多个命令"></a>4、在程序脚本中使用多个命令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#在命令行上的程序脚本中使用多条命令</span><br><span class="line">echo &quot;I like my teacher Li&quot;|gawk &#39;&#123;$4&#x3D;&quot;qinqin&quot;;$5&#x3D;&quot;meimei&quot;;print $0&#125;&#39;</span><br><span class="line"></span><br><span class="line">#也可以用次提示符一次一行地输入程序脚本命令</span><br><span class="line">gawk &#39;&#123;</span><br><span class="line">&gt; $4&#x3D;&quot;qinqin&quot;</span><br><span class="line">&gt; $5&#x3D;&quot;meimei&quot;</span><br><span class="line">&gt; print $0&#125;&#39;</span><br><span class="line">I like my teacher Li</span><br></pre></td></tr></table></figure>
<p>因为没有在命令行中指定文件名，gawk程序会 从STDIN中获得数据。当运行这个程序的时候，它会等着读取来自STDIN的文本。要退出程序， 只需按下Ctrl+D组合键来表明数据结束。 </p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/基础gawk3.JPG"/>

<h2 id="5、从文本中读取程序"><a href="#5、从文本中读取程序" class="headerlink" title="5、从文本中读取程序"></a>5、从文本中读取程序</h2><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/基础gawk4.1.JPG"/>

<p><code>gawk</code>程序在引用变量值时并未像shell脚本一样使用美元符。 </p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/基础gawk4.2.JPG"/>

<h2 id="6、在处理数据前运行脚本"><a href="#6、在处理数据前运行脚本" class="headerlink" title="6、在处理数据前运行脚本"></a>6、在处理数据前运行脚本</h2><p>有时可能需要在处理数据前运行脚本，比如为报告创建标题。<code>BEGIN</code>就可以做到。<code>BEGIN</code>强制<code>gawk</code>在读取数据前执行BEGIN关键字后指定的程序脚本。 </p>
<ul>
<li>这次print命令会在读取数据前显示文本。但在它显示了文本后，它会快速退出，不等待任 何数据。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gawk <span class="string">&#x27;BEGIN &#123;print &quot;the content of gawk.txt&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果想使用正常的程序脚本中处理数据，必须用另一个脚本区域来定义程序。 </li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gawk <span class="string">&#x27;BEGIN &#123;print &quot;the content of gawk.txt&quot;&#125;</span></span><br><span class="line"><span class="string">&gt; &#123;print $0&#125;&#x27;</span> gawk.txt</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/基础gawk5.JPG"/>

<h2 id="7、在处理数据后运行脚本"><a href="#7、在处理数据后运行脚本" class="headerlink" title="7、在处理数据后运行脚本"></a>7、在处理数据后运行脚本</h2><ul>
<li>与BEGIN关键字类似，END关键字允许你指定一个程序脚本，gawk会在读完数据后执行它。</li>
</ul>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/基础gawk6.1.JPG"/>

<ul>
<li>也可以将一组命令组合起来形成一个小脚本文件，同样使用<code>-f</code>选项执行脚本中的命令。</li>
</ul>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/基础gawk6.JPG"/>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>可变剪切之rMART</title>
    <url>/2021/01/14/%E5%8F%AF%E5%8F%98%E5%89%AA%E5%88%87%E4%B9%8BMART/</url>
    <content><![CDATA[<p>RNA-seq高级分析之可变剪切</p>
<a id="more"></a>

<h1 id="可变剪切之rMART"><a href="#可变剪切之rMART" class="headerlink" title="可变剪切之rMART"></a>可变剪切之rMART</h1><p><strong>官方参考资料</strong><br><a href="http://rnaseq-mats.sourceforge.net/">http://rnaseq-mats.sourceforge.net/</a><br><strong>rMATS</strong>:<a href="https://github.com/Xinglab/rmats-turbo/blob/v4.1.0/README.md">https://github.com/Xinglab/rmats-turbo/blob/v4.1.0/README.md</a><br><strong>rmats2sashimiplot</strong>:<a href="https://github.com/Xinglab/rmats2sashimiplot">https://github.com/Xinglab/rmats2sashimiplot</a></p>
<h2 id="一-rMATS软件及相关依赖包的下载"><a href="#一-rMATS软件及相关依赖包的下载" class="headerlink" title="(一)rMATS软件及相关依赖包的下载"></a>(一)rMATS软件及相关依赖包的下载</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#先用conda下载rMATs软件需要的依赖包</span></span><br><span class="line"><span class="comment">#有时候python版本问题搞得我很烦，有些生信软件依赖特定的python版本，所以在软件安装过程中多加注意这个问题</span></span><br><span class="line">conda create rMATs2.7 python=2.7</span><br><span class="line">conda activate rMATs2.7</span><br><span class="line">conda install -y Cython=0.29.14 numpy=1.16.5 blas lapack gsl=2.6 gcc=5.4.0 CMake=3.15.4</span><br><span class="line">conda install libgfortran==1</span><br><span class="line">deactivate rMATs2.7</span><br><span class="line"></span><br><span class="line"><span class="comment">#下载软件并解压rMATs软件</span></span><br><span class="line"><span class="comment">#rMATs不同版本下载网址：https://github.com/Xinglab/rmats-turbo/releases/tag/v4.1.0</span></span><br><span class="line"><span class="built_in">cd</span> /home/gongyuqi/project/AS/rMATS</span><br><span class="line">wget https://github.com/Xinglab/rmats-turbo/releases/download/v4.1.0/rmats_turbo_v4_1_0_python_2_7.tar.gz</span><br><span class="line">tar -zxvf rmats_turbo_v4_1_0_python_2_7.tar.gz</span><br><span class="line"><span class="comment">#永久添加路径到环境变量中</span></span><br><span class="line"><span class="built_in">export</span> PATH=/home/gongyuqi/project/AS/rMATS/rmats-turbo/:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>

<h2 id="二-STAR比对软件的使用"><a href="#二-STAR比对软件的使用" class="headerlink" title="(二)STAR比对软件的使用"></a>(二)STAR比对软件的使用</h2><p>这么多比对软件，为什么选STAR？<br>因为官网用的STAR！据说其他可以做可变剪切的比对软件生成的bam文件，rMATs运行不了~~~</p>
<p><strong>1、构建参考基因组索引</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#激活比对的环境,这个环境里面我下载了各种比对软件，python版本为2.7.15.</span></span><br><span class="line">conda activate alignment2.7 </span><br><span class="line">nohup STAR --runThreadN 30 --runMode genomeGenerate \</span><br><span class="line">--genomeDir /home/gongyuqi/ref/hg38/index/star \</span><br><span class="line">--genomeFastaFiles /home/gongyuqi/ref/hg38/Homo_sapiens.GRCh38.dna.primary_assembly.fa \</span><br><span class="line">--sjdbGTFfile /home/gongyuqi/ref/hg38/Homo_sapiens.GRCh38.102.gtf &amp;</span><br></pre></td></tr></table></figure>
<p><strong>2、用STAR软件进行比对</strong></p>
<p>STAR的使用以及输出文件解读参考资料：<br><a href="https://blog.csdn.net/yssxswl/article/details/105703869">https://blog.csdn.net/yssxswl/article/details/105703869</a><br><a href="https://www.jianshu.com/p/eca16bf2824e">https://www.jianshu.com/p/eca16bf2824e</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#进入fastq文件坐在目录，这里是原始的fastq数据，质控结果挺好的，不用再过滤了，所以我直接比对了</span></span><br><span class="line"><span class="built_in">cd</span> /home/gongyuqi/project/AS/rawdata</span><br><span class="line"><span class="comment">#写循环进行比对</span></span><br><span class="line">ls *.gz|<span class="keyword">while</span> <span class="built_in">read</span> id</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">nohup STAR --runThreadN 20 \</span><br><span class="line">--genomeDir /home/gongyuqi/ref/hg38/index/star \</span><br><span class="line">--readFilesCommand gunzip -c \</span><br><span class="line">--readFilesIn ./<span class="variable">$id</span> \</span><br><span class="line">--outSAMtype BAM SortedByCoordinate \</span><br><span class="line">--outFileNamePrefix /home/gongyuqi/project/AS/aligndata_star/<span class="variable">$&#123;id%%.*&#125;</span>. &amp;</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p><strong>3、比对情况统计并查看</strong></p>
<p>(1)直接查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls *.Log.progress.out|<span class="keyword">while</span> <span class="built_in">read</span> id;<span class="keyword">do</span> sed -n <span class="string">&#x27;1,3p&#x27;</span> <span class="variable">$id</span>;<span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>结果如下，比对情况还是不错的，可以进行后续的分析。<br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/star_align_Log.progress.out.JPG"/></p>
<p>(2)flagstat统计比对情况查看比对情况</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls *.bam|<span class="keyword">while</span> <span class="built_in">read</span> id</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">nohup samtools flagstat -@ 20 <span class="variable">$id</span> &gt; <span class="variable">$&#123;id%%.*&#125;</span>.flagstat.txt &amp;</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">ls *.txt|<span class="keyword">while</span> <span class="built_in">read</span> id;<span class="keyword">do</span> cat <span class="variable">$id</span> | grep <span class="string">&quot;mapped (&quot;</span>;<span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>这个比对结果实在是难以置信！！但是结合上面的比对结果，还是可以相信比对这一步是没有问题的。<br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/star_align_flagstat.JPG"/></p>
<h2 id="三-运行rMATs"><a href="#三-运行rMATs" class="headerlink" title="(三)运行rMATs"></a>(三)运行rMATs</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#首先我们要失活掉比对的环境（alignment2.7），激活rMATs环境</span></span><br><span class="line">conda deactivate alignment2.7</span><br><span class="line">conda activate rMATs2.7</span><br><span class="line"><span class="comment">#虽然rMATS路径被永久添加到环境变量中，但是PATH只认可执行文件，所以这一步还是要切换到rMATs路径下</span></span><br><span class="line"><span class="built_in">cd</span> /home/gongyuqi/project/AS/rMATS/rmats-turbo</span><br><span class="line">input_dir=/home/gongyuqi/project/AS/aligndata_star</span><br><span class="line">python rmats.py \</span><br><span class="line">--b1 <span class="variable">$input_dir</span>/b1.txt \</span><br><span class="line">--b2 <span class="variable">$input_dir</span>/b2.txt \</span><br><span class="line">--gtf /home/gongyuqi/ref/hg38/ensembl/Homo_sapiens.GRCh38.102.gtf \</span><br><span class="line">-t single --readLength 36 --nthread 20 \</span><br><span class="line">--od /home/gongyuqi/project/AS/rMATS/rmats_output \</span><br><span class="line">--tmp /home/gongyuqi/project/AS/rMATS/rmats_tmp</span><br><span class="line"><span class="comment">#运行完记得退出当前环境，因为后面我们要用另外一个环境</span></span><br><span class="line">conda deactivate rMATs2.7</span><br></pre></td></tr></table></figure>
<p>运行上面的代码，会报如下错误：<br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/erro_libgsl.so.25.JPG"/></p>
<p>我查看了一下，/home/gongyuqi/miniconda3/envs/rMATs2.7/lib路径下有这个文件呢！为什么电脑找不到？触及到了我的知识盲区了~~~<br>查了一下午的资料，发现这个报错涉及到查找共享库（动态链接库）问题，根据查到的东西操作了一波居然没有解决，旁边的零食都不香了！😫<br>算了~~~我还是先去吃晚饭吧，已经饿得很瘦了！😫<br>。。。。。。<br>好啦，我吃完饭回来了。我继续倒腾，不放弃。<br>。。。。。。<br>额，我知道了，这段代码运行过程中还涉及到gcc编译，因为它依赖包中有GCC。<br>这两个问题实在是太专业了，今天又学习到了。现在有一点小小的开心！😊<br>解决方法参考资料：<a href="https://www.jianshu.com/p/a62e1d327023">https://www.jianshu.com/p/a62e1d327023</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Linux默认只会在指定的几个目录找共享库（动态链接库），其他目录的要自己加在LD_LIBRARY_PATH</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/home/gongyuqi/miniconda3/envs/rMATs2.7/lib</span><br><span class="line"><span class="comment">#因为上述命令是依赖gcc的，需要gcc进行编译，所以还需要下面的操作</span></span><br><span class="line"><span class="built_in">export</span> LIBRARY_PATH=/home/gongyuqi/miniconda3/envs/rMATs2.7/lib</span><br><span class="line"><span class="comment">#注意，上述都是临时的，治标不治本，下次执行运行rMATs时，依然要重复上述操作。当然你也可以将其永久性添加。</span></span><br></pre></td></tr></table></figure>
<p>运行结果如下，关于这些结果文件的解释说明，可以参考rMATS官网，上面有很详细的阐述。<br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/rMATs_output.JPG"/></p>
<h2 id="四-rmats2sashimiplot可视化"><a href="#四-rmats2sashimiplot可视化" class="headerlink" title="(四)rmats2sashimiplot可视化"></a>(四)rmats2sashimiplot可视化</h2><p>终于到了激动人心的可视化阶段了，一顿操作之后，产生一张漂亮的图放PPT上还是很欣慰的。</p>
<p><strong>1、环境搭建</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda create -n rmats2sashimiplot python=2.7 </span><br><span class="line">conda activate rmats2sashimiplot</span><br><span class="line">conda install -y numpy scipy matplotlib pysam samtools bedtools</span><br></pre></td></tr></table></figure>
<p><strong>2、准备可视化的txt文件</strong>  </p>
<p>以Exon Skipping为例演示,这里我随便找一个基因进行可视化，注意了，这个基因不一定是差异可变剪切的基因哟，因为是我随便找的一个。嘻嘻🤭</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -n <span class="string">&#x27;2p&#x27;</span> SE.MATS.JC.txt &gt; SE.plot.PRMT2.txt</span><br><span class="line">cat SE.plot.PRMT2.txt</span><br></pre></td></tr></table></figure>
<p>文件内容如下：<br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/PRMT2_rMATs.txt.JPG"/></p>
<p><strong>3、可视化的txt文件</strong></p>
<h6 id="一开始，我非常自信的运行了下面的代码"><a href="#一开始，我非常自信的运行了下面的代码" class="headerlink" title="一开始，我非常自信的运行了下面的代码~"></a>一开始，我非常自信的运行了下面的代码~</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gff3=/home/gongyuqi/ref/hg38/ensembl/Homo_sapiens.GRCh38.102.gff3</span><br><span class="line">output_dir=/home/gongyuqi/project/AS/rMATS/rmats2sashimiplot/</span><br><span class="line">rmats2sashimiplot \</span><br><span class="line">--b1 SRR974968.Aligned.sortedByCoord.out.bam,SRR974972.Aligned.sortedByCoord.out.bam,SRR974978.Aligned.sortedByCoord.out.bam,SRR974984.Aligned.sortedByCoord.out.bam \</span><br><span class="line">--b2 SRR974974.Aligned.sortedByCoord.out.bam,SRR974976.Aligned.sortedByCoord.out.bam,SRR974980.Aligned.sortedByCoord.out.bam,SRR974982.Aligned.sortedByCoord.out.bam \</span><br><span class="line">-c chr21:+:46636438:46636547:<span class="variable">$gff3</span> \</span><br><span class="line">-e /home/gongyuqi/project/AS/rMATS/rmats_output/SE.plot.PRMT2.txt \</span><br><span class="line">--l1 treatment --l2 control \</span><br><span class="line">--exon_s 1 --intron_s 5 -t SE \</span><br><span class="line">-o <span class="variable">$output_dir</span>/<span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<h6 id="但是，我遇到了如下报错"><a href="#但是，我遇到了如下报错" class="headerlink" title="但是，我遇到了如下报错"></a>但是，我遇到了如下报错</h6><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/rmats2sashimiplot_chr_error.JPG"/>


<h6 id="我回头看了一下我的bam文件，染色体是以1-2…X-Y形式体现而不是chr1-chr2…chrX-chrY形式体现。我第一次遇到染色体号的问题呢。我要怎么让bam文件中有chr存在且让其存在在正确的位置呢。"><a href="#我回头看了一下我的bam文件，染色体是以1-2…X-Y形式体现而不是chr1-chr2…chrX-chrY形式体现。我第一次遇到染色体号的问题呢。我要怎么让bam文件中有chr存在且让其存在在正确的位置呢。" class="headerlink" title="我回头看了一下我的bam文件，染色体是以1,2…X,Y形式体现而不是chr1,chr2…chrX,chrY形式体现。我第一次遇到染色体号的问题呢。我要怎么让bam文件中有chr存在且让其存在在正确的位置呢。"></a>我回头看了一下我的bam文件，染色体是以1,2…X,Y形式体现而不是chr1,chr2…chrX,chrY形式体现。我第一次遇到染色体号的问题呢。我要怎么让bam文件中有<code>chr</code>存在且让其存在在正确的位置呢。</h6><h6 id="我绞尽脑汁的想了很久很久😫，我还考虑到是不是我参考基因组的问题，不同数据库参考基因组是不是有差异，我要不要换一个数据库的参考基因组。然后我一顿操作，无果-算了，我打一局游戏睡觉吧，明天再想。"><a href="#我绞尽脑汁的想了很久很久😫，我还考虑到是不是我参考基因组的问题，不同数据库参考基因组是不是有差异，我要不要换一个数据库的参考基因组。然后我一顿操作，无果-算了，我打一局游戏睡觉吧，明天再想。" class="headerlink" title="我绞尽脑汁的想了很久很久😫，我还考虑到是不是我参考基因组的问题，不同数据库参考基因组是不是有差异，我要不要换一个数据库的参考基因组。然后我一顿操作，无果~~~算了，我打一局游戏睡觉吧，明天再想。"></a>我绞尽脑汁的想了很久很久😫，我还考虑到是不是我参考基因组的问题，不同数据库参考基因组是不是有差异，我要不要换一个数据库的参考基因组。然后我一顿操作，无果~~~算了，我打一局游戏睡觉吧，明天再想。</h6><h6 id="起床吃早饭骑车去实验室思考查资料有一点小想法了我实践一下看看可不可"><a href="#起床吃早饭骑车去实验室思考查资料有一点小想法了我实践一下看看可不可" class="headerlink" title="起床吃早饭骑车去实验室思考查资料有一点小想法了我实践一下看看可不可"></a>起床<del>吃早饭</del>骑车去实验室<del>思考</del>查资料<del>有一点小想法了</del>我实践一下看看可不可</h6><p>参考资料：<a href="https://www.jianshu.com/p/5ceda0350d0d">https://www.jianshu.com/p/5ceda0350d0d</a></p>
<h6 id="第一步：给bam文件添加chr"><a href="#第一步：给bam文件添加chr" class="headerlink" title="第一步：给bam文件添加chr"></a><font color=blue>第一步：给bam文件添加chr</font></h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#添加chr</span></span><br><span class="line">ls *.bam|<span class="keyword">while</span> <span class="built_in">read</span> id</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">nohup samtools view -h <span class="variable">$id</span> | sed -e <span class="string">&#x27;/^@SQ/s/SN\:/SN\:chr/&#x27;</span> -e <span class="string">&#x27;/^[^@]/s/\t/\tchr/2&#x27;</span>|awk -F <span class="string">&#x27; &#x27;</span> <span class="string">&#x27;$7=($7==&quot;=&quot; || $7==&quot;*&quot;?$7:sprintf(&quot;chr%s&quot;,$7))&#x27;</span> |tr <span class="string">&quot; &quot;</span> <span class="string">&quot;\t&quot;</span> | samtools view -h -b -@ 10 -S - &gt; <span class="variable">$&#123;id%%.*&#125;</span>.Aligned.sortedByCoord.out.chr.bam &amp;</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<h6 id="第二步：使用添加chr的bam文件执行程序"><a href="#第二步：使用添加chr的bam文件执行程序" class="headerlink" title="第二步：使用添加chr的bam文件执行程序"></a><font color=blue>第二步：使用添加chr的bam文件执行程序</font></h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gff3=/home/gongyuqi/ref/hg38/ensembl/Homo_sapiens.GRCh38.102.gff3</span><br><span class="line">output_dir=/home/gongyuqi/project/AS/rMATS/rmats2sashimiplot/</span><br><span class="line">rmats2sashimiplot \</span><br><span class="line">--b1 SRR974968.Aligned.sortedByCoord.out.chr.bam,SRR974972.Aligned.sortedByCoord.out.chr.bam,SRR974978.Aligned.sortedByCoord.out.chr.bam,SRR974984.Aligned.sortedByCoord.out.chr.bam \</span><br><span class="line">--b2 SRR974974.Aligned.sortedByCoord.out.chr.bam,SRR974976.Aligned.sortedByCoord.out.chr.bam,SRR974980.Aligned.sortedByCoord.out.chr.bam,SRR974982.Aligned.sortedByCoord.out.chr.bam \</span><br><span class="line">-c chr21:+:46636438:46636547:<span class="variable">$gff3</span> \</span><br><span class="line">-e /home/gongyuqi/project/AS/rMATS/rmats_output/SE.plot.PRMT2.txt \</span><br><span class="line">--l1 treatment --l2 control \</span><br><span class="line">--exon_s 1 --intron_s 5 -t SE \</span><br><span class="line">-o <span class="variable">$output_dir</span>/SE.plot</span><br></pre></td></tr></table></figure>
<p>可视化结果如下（你会发现，咦~两组间差异不显著呀？因为我随便挑了一个基因可视化呀！我有偷偷可视化某个基因，可视化出来的差异性与我定量和半定量qPCR的结果一致哟，所以上述分析流程应该是OK的~~~嘻嘻嘻🤭不管怎样，这个基因确实存在Exon Skipping。）<br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/ABC_GCB_PRMT2_rMATs.JPG"/></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>技术上</strong><br>1、需要搭建两个重要的环境：运行rMATs的环境，运行rmats2sashimiplot的环境。<br>2、选用STAR进行参考基因组的比对（注意了，参考基因组和注释文件的版本要一致哟）。<br>3、在rMATs的环境下,结合上述生成的bam文件，运行rMATs软件，生成可变剪切事件的文件。<br>4、在rmats2sashimiplot环境下，可视化上述生成的可变剪切事件。</p>
<p><strong>心态上</strong><br>上午解决不了就下午解决，今天解决不了就明天解决。这个方法不行就换个方法。思考良久之后可以适当的问问老师。最关键的还是要按时吃饭按时睡觉。</p>
<p>SRR974972.Aligned.sortedByCoord.out.chr.bam,</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gff3=/home/gongyuqi/ref/hg38/ensembl/Homo_sapiens.GRCh38.102.gff3</span><br><span class="line">output_dir=/home/gongyuqi/project/AS/rMATS/</span><br><span class="line">rmats2sashimiplot \</span><br><span class="line">--b1 SRR974968.Aligned.sortedByCoord.out.chr.bam,SRR974978.Aligned.sortedByCoord.out.chr.bam,SRR974984.Aligned.sortedByCoord.out.chr.bam \</span><br><span class="line">--b2 SRR974974.Aligned.sortedByCoord.out.chr.bam,SRR974976.Aligned.sortedByCoord.out.chr.bam,SRR974980.Aligned.sortedByCoord.out.chr.bam,SRR974982.Aligned.sortedByCoord.out.chr.bam \</span><br><span class="line">-c chr3:+:191375061:191375589:<span class="variable">$gff3</span> \</span><br><span class="line">-e /home/gongyuqi/project/AS/rMATS/ABC_GCB/rmats_output/SE.plot.CCDC50.txt \</span><br><span class="line">--l1 ABC --l2 GCB \</span><br><span class="line">--exon_s 1 --intron_s 5 -t SE \</span><br><span class="line">-o <span class="variable">$output_dir</span>/CCDC50_SE_new.plot</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>NGS</tag>
      </tags>
  </entry>
  <entry>
    <title>可变剪切之SUPPA2</title>
    <url>/2021/01/23/%E5%8F%AF%E5%8F%98%E5%89%AA%E5%88%87%E4%B9%8BSUPPA2/</url>
    <content><![CDATA[<p>RNA-seq高级分析之可变剪切</p>
<a id="more"></a>

<h1 id="可变剪切之SUPPA2"><a href="#可变剪切之SUPPA2" class="headerlink" title="可变剪切之SUPPA2"></a>可变剪切之SUPPA2</h1><p>SUPPA2参考资料：<br><a href="https://github.com/comprna/SUPPA/wiki/SUPPA2-tutorial#differential-splicing-with-local-events">https://github.com/comprna/SUPPA/wiki/SUPPA2-tutorial#differential-splicing-with-local-events</a><br>分析流程中所需要得<strong>参考基因组</strong>、<strong>注释文件</strong>、<strong>R脚本</strong>都可以在该链接中找到并下载</p>
<p>下面这段话引自官网，简单了解一下SUPPA2及其功能</p>
<blockquote>
<p>SUPPA2 obtains the inclusion levels of AS events exploiting transcript quantification. There are different measures for isoform quantification (counts, TMM, FPKM…). We strongly recommend the use of TPM (Transcripts Per Million), because is normalized for gene length first, and then for sequencing depth. This allows direct comparison between samples (check the following video if you want to know more).</p>
</blockquote>
<blockquote>
<p>There are several tools for transcript quantification (this is an interesting review² on this matter). Each one has different pros and cons and the user is free to use the one that fits better to his requirements. We recommend to use Salmon³, because is one of the fastest methods for quantification without compromising accuracy and it also offers some other interesting options like GC bias correction or bootstrapping among others. The commands indicated here are oriented for using this tools.</p>
</blockquote>
<h2 id="一-环境搭建"><a href="#一-环境搭建" class="headerlink" title="(一)环境搭建"></a>(一)环境搭建</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda create -n SUPPA2_3.9 python=3.9.1</span><br><span class="line">conda activate SUPPA2_3.9</span><br><span class="line">conda install -c bioconda salmon suppa matplotlib</span><br></pre></td></tr></table></figure>

<h2 id="二-转录本定量"><a href="#二-转录本定量" class="headerlink" title="(二)转录本定量"></a>(二)转录本定量</h2><h3 id="1、建立索引"><a href="#1、建立索引" class="headerlink" title="1、建立索引"></a>1、建立索引</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">salmon index -t hg19_EnsenmblGenes_sequence_ensenmbl.fasta -i Ensembl_hg19_salmon_index</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/hg19_salmon_index.JPG"/>

<h3 id="2、定量获得TPM值"><a href="#2、定量获得TPM值" class="headerlink" title="2、定量获得TPM值"></a>2、定量获得TPM值</h3><p><strong>(1)、运行salmon软件定量</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">x=_1</span><br><span class="line">y=_2</span><br><span class="line"><span class="keyword">for</span> id <span class="keyword">in</span> &#123;SRR1513329,SRR1513330,SRR1513331,SRR1513332,SRR1513333,SRR1513334&#125;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">nohup salmon quant -i /home/gongyuqi/ref/hg38/ensembl/SUPPA_ref/Ensembl_hg19_salmon_index -l ISF --gcBias -1 $id<span class="variable">$x</span>.fastq.gz -2 $id<span class="variable">$y</span>.fastq.gz -p 20 -o /home/gongyuqi/project/AS/SUPPA2/<span class="variable">$id</span> &amp;</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>展示一个样本的输出结果结构<br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/tree_SRR1513329.JPG"/><br>其中quant.sf文件很重要，要用于后续的分析，展示该文件部分内容<br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/quant_df.JPG"/></p>
<p><strong>(2)、提取所有样本的TPM值并合并为一个文件</strong></p>
<p><code>-k</code> indicates the row used as index<br><code>-f</code> TPM值在第四列，在这里要提取每个样本的TPM值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">suppa_dir=/home/gongyuqi/miniconda3/envs/SUPPA2_3.9/bin/</span><br><span class="line">python <span class="variable">$suppa_dir</span>/multipleFieldSelection.py -i /home/gongyuqi/project/AS/SUPPA2/*/quant.sf -k 1 -f 4 -o /home/gongyuqi/project/AS/SUPPA2/iso_tpm.txt</span><br></pre></td></tr></table></figure>
<p>查看iso_tpm.txt的内容<br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/iso_tmp_txt.JPG"/></p>
<p><strong>(3)、使iso_tpm.txt文件中的转录本id同下载的gtf文件id一致</strong>  </p>
<p>运行此R脚本，会生成iso_tpm_formatted.txt文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Rscript format_Ensembl_ids.R iso_tpm.txt</span><br></pre></td></tr></table></figure>
<p>查看iso_tpm_formatted.txt的内容<br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/iso_tmp_formatted_txt.JPG"/></p>
<h2 id="三、PSI计算"><a href="#三、PSI计算" class="headerlink" title="三、PSI计算"></a>三、PSI计算</h2><p><strong>1、根据参考基因组注释文件生成可变剪切事件文件</strong></p>
<p><code>-i</code> GTF文件<br><code>-o</code> 输出文件前缀<br><code>-e</code> 输出文件中包含的可变剪切类型<br><code>-f</code> 输出的格式  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#生成ioe文件</span></span><br><span class="line">gtf_dir=/home/gongyuqi/ref/hg38/ensembl/SUPPA_ref</span><br><span class="line">python <span class="variable">$suppa_dir</span>/suppa.py generateEvents -i <span class="variable">$gtf_dir</span>/Homo_sapiens.GRCh37.75.formatted.gtf -o ensembl_hg19.events -e SE SS MX RI FL -f ioe</span><br><span class="line"><span class="comment">#合并所有的ioe文件</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$gtf_dir</span></span><br><span class="line">awk <span class="string">&#x27;</span></span><br><span class="line"><span class="string">    FNR==1 &amp;&amp; NR!=1 &#123; while (/^&lt;header&gt;/) getline; &#125;</span></span><br><span class="line"><span class="string">    1 &#123;print&#125;</span></span><br><span class="line"><span class="string">&#x27;</span> *.ioe &gt; ensembl_hg19.events.ioe</span><br></pre></td></tr></table></figure>
<p>结果如下<br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/ensembl_hg19.events.ioe.JPG"/></p>
<p><strong>2、计算样本的PSI值</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/gongyuqi/project/AS/SUPPA2</span><br><span class="line">ioe_merge_file=~/ref/hg38/ensembl/SUPPA_ref/hg19_event/ensembl_hg19.events.ioe</span><br><span class="line">nohup python <span class="variable">$suppa_dir</span>/suppa.py psiPerEvent -i <span class="variable">$ioe_merge_file</span> -e iso_tpm_formatted.txt -o TRA2_events &amp;</span><br></pre></td></tr></table></figure>
<p>查看结果TRA2_events.psi文件<br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/TRA2_events.psi.JPG"/></p>
<p><strong>3、boxplot图可视化</strong></p>
<p><code>-i</code> 输入的PSI矩阵<br><code>-e</code> 需要可视化的某基因的某种可变剪切类型<br><code>-g</code> 样品按顺序分组<br><code>-c</code> 分组名称，1-3好样本为NC组，4-6号样本为KD组<br><code>-o</code> 结果输出地址  </p>
<p>以ENSG00000149554为例进行可视化</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scripts_dir=/home/gongyuqi/project/AS/SUPPA2/scripts</span><br><span class="line">python <span class="variable">$scripts_dir</span>/generate_boxplot_event.py -i TRA2_events.psi -e <span class="string">&quot;ENSG00000149554;SE:chr11:125496728-125497502:125497725-125499127:+&quot;</span> -g 1-3,4-6 -c NC,KD -o ./</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/boxplot_PSI.JPG" width="50%">


<h2 id="四、差异可变剪切分析"><a href="#四、差异可变剪切分析" class="headerlink" title="四、差异可变剪切分析"></a>四、差异可变剪切分析</h2><p>分组情况<br>negative control siRNA ：SRR1513329,SRR1513330,SRR1513331<br>TRA2A/B siRNA ：SRR1513332,SRR1513333,SRR1513334  </p>
<p><strong>1、分别构建两组的TPM和PSI文件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$scripts_dir</span>/split_file.R iso_tpm_formatted.txt SRR1513329,SRR1513330,SRR1513331 SRR1513332,SRR1513333,SRR1513334 TRA2_NC_iso.tpm TRA2_KD_iso.tpm -i</span><br><span class="line"><span class="variable">$scripts_dir</span>/split_file.R TRA2_events.psi SRR1513329,SRR1513330,SRR1513331 SRR1513332,SRR1513333,SRR1513334 TRA2_NC_events.psi TRA2_KD_events.psi -e</span><br></pre></td></tr></table></figure>
<p><strong>2、差异分析</strong> </p>
<p><code>-m empirical</code> 选择empirical方法<br><code>-gc</code> 基因修正<br><code>--save_tpm_events</code> 参数的添加，会多生成一个<br>TRA2_diffSplice_avglogtpm.tab文件，是后续火山图可视化的输入文件之一</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python <span class="variable">$suppa_dir</span>/suppa.py diffSplice -m empirical -gc -i <span class="variable">$ioe_merge_file</span> --save_tpm_events -p TRA2_KD_events.psi TRA2_NC_events.psi -e TRA2_KD_iso.tpm TRA2_NC_iso.tpm -o ./<span class="built_in">test</span>/TRA2_diffSplice</span><br></pre></td></tr></table></figure>
<p>差异分析生成下列3个文件<br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/diffsplice.JPG"/></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat TRA2_diffSplice.dpsi|grep <span class="string">&quot;ENSG00000149554&quot;</span>|less -N</span><br></pre></td></tr></table></figure>
<p>查看dpsi文件，以ENSG00000149554为例，分析结果中会显示这个基因不同的可变剪切类型在两种处理情况下的psi值及其显著性，红色箭头标记的可变剪切事件在两组中的差异是显著的(p_value&lt;0.05)<br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/diffsplice_ENSG00000149554_mark.JPG"/></p>
<p><strong>当然,上述可变剪切差异分析的结果还可以导入R中进行volcanoplot可视化分析，官网提供了具体的R脚本</strong><br>可视化结果如下<br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/volcano_plot.JPG" width="50%"></p>
<p><strong>总结：</strong><br>1、技术路线：salmon定量获得各个样本的TPM值——&gt; 合并样本——&gt; 计算PSI值——&gt; 可变剪切差异分析<br>2、拿到最终的差异分析结果，提取出显著的差异可变剪切事件，写脚本将可变剪切事件的id转换成基因名，就得视觉上更友好的文件了。拿到这个文件开展后续的个性化分析。</p>
]]></content>
      <tags>
        <tag>NGS</tag>
      </tags>
  </entry>
  <entry>
    <title>可变剪切分析之MISO</title>
    <url>/2021/01/09/%E5%8F%AF%E5%8F%98%E5%89%AA%E5%88%87%E4%B9%8BMISO/</url>
    <content><![CDATA[<p>RNA-seq高级分析之可变剪切</p>
<a id="more"></a>

<h1 id="可变剪切分析之MISO"><a href="#可变剪切分析之MISO" class="headerlink" title="可变剪切分析之MISO"></a>可变剪切分析之MISO</h1><p>MISO软件原文档：<a href="https://miso.readthedocs.io/en/fastmiso/index.html#installing-fastmiso">https://miso.readthedocs.io/en/fastmiso/index.html#installing-fastmiso</a></p>
<h2 id="数据下载"><a href="#数据下载" class="headerlink" title="数据下载"></a>数据下载</h2><ul>
<li>写一个bash脚本下载数据<br>一次性下载所有的.fastq.gz文件，本次实验数据是单端测序数据<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#！/bin/bash</span></span><br><span class="line">dir=/home/gongyuqi/.aspera/connect/etc/asperaweb_id_dsa.openssh</span><br><span class="line"><span class="keyword">for</span> id <span class="keyword">in</span>  &#123;84,78,76,72,82,80,74,68&#125; </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">       nohup ascp -QT -l 300m -P33001 -i <span class="variable">$dsa</span> era-fasp@fasp.sra.ebi.ac.uk:/vol1/fastq/SRR974/SRR9749<span class="variable">$id</span>/SRR9749<span class="variable">$id</span>.fastq.gz . &amp;</span><br><span class="line"><span class="keyword">done</span> </span><br></pre></td></tr></table></figure></li>
<li>执行脚本</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod +x download.sh</span><br><span class="line">nohup ./download.sh &amp;</span><br></pre></td></tr></table></figure>
<h2 id="比对"><a href="#比对" class="headerlink" title="比对"></a>比对</h2><p>参考资料：<a href="http://www.360doc.com/content/18/0714/20/19913717_770401548.shtml">http://www.360doc.com/content/18/0714/20/19913717_770401548.shtml</a></p>
<blockquote>
<ul>
<li>tophat进行转录组的比对时，输出的是bam（二进制的sam）文件。</li>
<li>tophat依赖bowtie2（bowtie1也可以），参考基因组索引用bowtie2-build进行构建。</li>
<li>如果FASTA格式的基因组与索引文件不在同一个文件夹下面，tophat会在运行中自动生成，所以记得把参考基因组和索引文件放在同一个文件夹下面，以减少系统运行时的高消耗。</li>
<li>如果GTF或者GFF格式的基因组注释文件存在， tophat会优先比对到注释文件的转录组上。最好事先准备好转录组索引以节约后续的比对时间。</li>
<li>如果没有事先准备好转录组索引，tophat会在运行过程中生成转录组索引，这样就比较耗时耗力了。</li>
</ul>
</blockquote>
<p><strong><table><tr><td bgcolor=GreenYellow>**参考基因组索引构建、转录组索引构建</strong></td></tr></table>**</p>
<p>hg19参考基因组gtf文件下载链接：<a href="https://www.gencodegenes.org/human/release_36lift37.html">https://www.gencodegenes.org/human/release_36lift37.html</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#建立hg19参考基因组索引文件</span></span><br><span class="line">nohup time bowtie2-build path/to/hg19.fa ./hg19 &gt; hg19.bowtie_index.log 2&gt;&amp;1 &amp;</span><br><span class="line"><span class="comment">#建立hg19转录组索引文件</span></span><br><span class="line"><span class="comment">#../index/bowtie/hg19为上一步构建的hg19参考基因组索引文件的相对路径及前缀</span></span><br><span class="line">nohup tophat -G ../gencode.v36lift37.annotation.gtf --transcriptome-index=hg19.tr ../index/bowtie/hg19 &amp;</span><br></pre></td></tr></table></figure>

<p><strong><table><tr><td bgcolor=GreenYellow>**参考基因组的比对</strong></td></tr></table>** </p>
<h5 id="比对方法一"><a href="#比对方法一" class="headerlink" title="比对方法一"></a>比对方法一</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#以其中一个样本为例，走一波比对转录组流程。</span></span><br><span class="line"><span class="comment">#理论上可以节约时间，但是实际跑起来非常耗时！</span></span><br><span class="line"><span class="comment">#1G左右得样本跑了4个小时都没有跑完！！！不知道问题出在那儿，但是还是果断kill掉</span></span><br><span class="line">tr_index=/home/gongyuqi/ref/hg19/transcriptome-index/hg19.tr</span><br><span class="line">gene_index=~/ref/hg19/index/bowtie/hg19</span><br><span class="line">tophat2 -o ../aligndata/SRR974980.out --transcriptome-index=<span class="variable">$tr</span> -p 30 --phred64-quals <span class="variable">$gene_index</span> SRR974980.fastq.gz</span><br></pre></td></tr></table></figure>
<h5 id="比对方法二"><a href="#比对方法二" class="headerlink" title="比对方法二"></a>比对方法二</h5><ul>
<li>写一个比对的bash脚本文件（align.txt），如下<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">ls *.gz|<span class="keyword">while</span> <span class="built_in">read</span> id</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">nohup tophat -G ~/ref/hg19/gencode.v36lift37.annotation.gtf -p 30 -o ../aligndata/<span class="variable">$id</span>.out ~/ref/hg19/index/bowtie/hg19 <span class="variable">$id</span> &amp;</span><br><span class="line"><span class="keyword">done</span> </span><br></pre></td></tr></table></figure></li>
<li>执行这个脚本，然后去睡觉，早上醒来看看比对得结果如何~<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nohup bash align.txt &amp;</span><br></pre></td></tr></table></figure>
运行结果<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/align1.JPG"/>


</li>
</ul>
<p>每个文件夹打开结果如下<br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/align2.JPG"/></p>
<p>大概了解一下样本的运行日志</p>
<blockquote>
<p>注意reads的长度——36。miso后续分析中需要知道这个值<br>注意其中有一个error,至于为什么有这个报错，先不追究<br>注意比对结果的那个统计文件align_summary.txt,查看这个文件发现各个样本比对情况都挺好的。这就是为什么这里暂时不追究那个报错<br>最后会统计样本比对时长<br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/align4.JPG"/></p>
</blockquote>
<p>3、bam文件排序及索引文件建立</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls *.bam|<span class="keyword">while</span> <span class="built_in">read</span> id; <span class="keyword">do</span> samtools sort -@ 30 -m 8G -O bam <span class="variable">$id</span> -o <span class="variable">$&#123;id%%.*&#125;</span>.accepted_hits.sorted.bam;<span class="keyword">done</span></span><br><span class="line">ls *sorted.bam|<span class="keyword">while</span> <span class="built_in">read</span> id; <span class="keyword">do</span> nohup samtools index -@ 30 <span class="variable">$id</span> &amp; <span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<h2 id="运行MISO"><a href="#运行MISO" class="headerlink" title="运行MISO"></a>运行MISO</h2><p><strong><table><tr><td bgcolor=GreenYellow>**下载hg19的GFF文件并构建索引</strong></td></tr></table>**</p>
<p>具体下载网页及详情：<a href="https://miso.readthedocs.io/en/fastmiso/annotation.html">https://miso.readthedocs.io/en/fastmiso/annotation.html</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/gongyuqi/project/AS/annotation/human/hg19</span><br><span class="line">wget hollywood.mit.edu/burgelab/miso/annotations/ver2/miso_annotations_hg19_v2.zip</span><br><span class="line">unzip miso_annotations_hg19_v2.zip</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/unzipgff.JPG"/>

<p>这里我们以外显子的gff3为例构建索引</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">index_gff --index SE.hg19.gff3 ./index</span><br></pre></td></tr></table></figure>
<p>结果如下<br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/ESgff3index.JPG"/></p>
<p><strong><table><tr><td bgcolor=GreenYellow>**以单端测序样本为例运行miso</strong></td></tr></table>**</p>
<p>这一步生成的结果是很关键的，会计算alternative splicing events的PSI值。而这个在最后可视化的阶段会以posterior distributions over Ψ(PSI)的形式呈现——即sashimi_plot图最右边一列的柱状图。</p>
<ul>
<li>写一个miso_run的脚本，内容如下<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">cd</span> /home/gongyuqi/project/AS/aligndata/accpted_bam</span><br><span class="line">index_db=/home/gongyuqi/project/AS/annotation/human/hg19/index/</span><br><span class="line">out_dir=/home/gongyuqi/project/AS/miso_step1</span><br><span class="line">ls *.sorted.bam|<span class="keyword">while</span> <span class="built_in">read</span> id</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">nohup miso --run <span class="variable">$index_db</span> <span class="variable">$id</span> --output-dir <span class="variable">$out_dir</span>/<span class="variable">$&#123;id%%.*&#125;</span> --read-len 36 &amp;</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li>
<li>运行脚本<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nohup ./miso_run.sh &amp;</span><br></pre></td></tr></table></figure>
举例查看其中一个样本的运行结果</li>
</ul>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/miso_run_out.JPG"/>


<table><tr><td bgcolor=GreenYellow>**样本间比较**</td></tr></table>

<p>这个软件最大的问题在于只能进行两个样本的比较，这一点就很气！！！<br>气归气，还是先运行一下，至少先把流程走完，先学起来。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">compare_miso --compare-samples SRR974978/ SRR974982/ comparison/</span><br></pre></td></tr></table></figure>

<p><strong><table><tr><td bgcolor=GreenYellow>**过滤</strong></td></tr></table>**</p>
<p>设置各种参数的阈值，目的是筛选差异显著的alternative splicing events。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">filter_events \</span><br><span class="line">--filter  SRR974978_vs_SRR974982.miso_bf \</span><br><span class="line">--num-inc 1 \</span><br><span class="line">--num-exc 1 \</span><br><span class="line">--num-sum-inc-exc 10 \</span><br><span class="line">--delta-psi 0.20 \</span><br><span class="line">--bayes-factor 10 \</span><br><span class="line">--output-dir ./filter_out</span><br></pre></td></tr></table></figure>
<p>过滤前后.misoz_bf文件中的alternative splicing events有明显减少<br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/filter.JPG"/></p>
<p><strong><table><tr><td bgcolor=GreenYellow>**可视化</strong></td></tr></table>**</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">index_db=/home/gongyuqi/project/AS/annotation/human/hg19/index/</span><br><span class="line"><span class="comment">#下面做演示的剪切事件是从上一步过滤后的.miso_bf.filtered文件中提取的一个</span></span><br><span class="line">sashimi_plot \</span><br><span class="line">--plot-event <span class="string">&quot;chr20:1093906:1094052:+@chr20:1099396:1099545:+@chr20:1106141:1106293:+&quot;</span> \</span><br><span class="line"><span class="variable">$index_db</span> \</span><br><span class="line">sashimi_plot_settings.txt  \</span><br><span class="line">--output-dir ./sashimi_plot</span><br></pre></td></tr></table></figure>

<p>其中sashimi_plot_settings.txt是配置文件，内容如下。当然，也可以根据自己的作图需要修改相应的参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[data]</span><br><span class="line"><span class="comment"># directory where BAM files are</span></span><br><span class="line">bam_prefix = /home/gongyuqi/project/AS/aligndata/accpted_bam/</span><br><span class="line"><span class="comment"># directory where MISO output is</span></span><br><span class="line">miso_prefix = /home/gongyuqi/project/AS/miso_step1</span><br><span class="line"></span><br><span class="line">bam_files = [</span><br><span class="line">    <span class="string">&quot;SRR974978.accepted_hits.sorted.bam&quot;</span>,</span><br><span class="line">    <span class="string">&quot;SRR974984.accepted_hits.sorted.bam&quot;</span>,</span><br><span class="line">    <span class="string">&quot;SRR974968.accepted_hits.sorted.bam&quot;</span>,</span><br><span class="line">    <span class="string">&quot;SRR974972.accepted_hits.sorted.bam&quot;</span>,</span><br><span class="line">    <span class="string">&quot;SRR974982.accepted_hits.sorted.bam&quot;</span>,</span><br><span class="line">    <span class="string">&quot;SRR974980.accepted_hits.sorted.bam&quot;</span>,</span><br><span class="line">    <span class="string">&quot;SRR974974.accepted_hits.sorted.bam&quot;</span>,</span><br><span class="line">    <span class="string">&quot;SRR974976.accepted_hits.sorted.bam&quot;</span>]</span><br><span class="line"></span><br><span class="line">miso_files = [</span><br><span class="line">    <span class="string">&quot;SRR974978&quot;</span>,</span><br><span class="line">    <span class="string">&quot;SRR974984&quot;</span>,</span><br><span class="line">    <span class="string">&quot;SRR974968&quot;</span>,</span><br><span class="line">    <span class="string">&quot;SRR974972&quot;</span>,</span><br><span class="line">    <span class="string">&quot;SRR974982&quot;</span>,</span><br><span class="line">    <span class="string">&quot;SRR974980&quot;</span>,</span><br><span class="line">    <span class="string">&quot;SRR974974&quot;</span>,</span><br><span class="line">    <span class="string">&quot;SRR974976&quot;</span>]</span><br><span class="line"></span><br><span class="line">[plotting]</span><br><span class="line"><span class="comment"># Dimensions of figure to be plotted (in inches)</span></span><br><span class="line">fig_width = 4</span><br><span class="line">fig_height = 10</span><br><span class="line"><span class="comment"># Factor to scale down introns and exons by</span></span><br><span class="line">intron_scale = 30</span><br><span class="line">exon_scale = 4</span><br><span class="line"><span class="comment"># Whether to use a log scale or not when plotting</span></span><br><span class="line">logged = False</span><br><span class="line">font_size = 6</span><br><span class="line"></span><br><span class="line"><span class="comment"># Max y-axis</span></span><br><span class="line">ymax = 150</span><br><span class="line"></span><br><span class="line"><span class="comment"># Whether to plot posterior distributions inferred by MISO</span></span><br><span class="line">show_posteriors = True</span><br><span class="line"></span><br><span class="line"><span class="comment"># Whether to show posterior distributions as bar summaries</span></span><br><span class="line">bar_posteriors = False</span><br><span class="line"></span><br><span class="line"><span class="comment"># Whether to plot the number of reads in each junction</span></span><br><span class="line">number_junctions = True</span><br><span class="line"></span><br><span class="line">resolution = .5</span><br><span class="line">posterior_bins = 40</span><br><span class="line">gene_posterior_ratio = 5</span><br><span class="line"></span><br><span class="line"><span class="comment"># List of colors for read denisites of each sample</span></span><br><span class="line">colors = [<span class="string">&quot;#CC0011&quot;</span>,</span><br><span class="line">          <span class="string">&quot;#CC0011&quot;</span>,</span><br><span class="line">          <span class="string">&quot;#CC0011&quot;</span>,</span><br><span class="line">          <span class="string">&quot;#CC0011&quot;</span>,</span><br><span class="line">          <span class="string">&quot;#FF8800&quot;</span>,</span><br><span class="line">          <span class="string">&quot;#FF8800&quot;</span>,</span><br><span class="line">          <span class="string">&quot;#FF8800&quot;</span>,</span><br><span class="line">          <span class="string">&quot;#FF8800&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Number of mapped reads in each sample</span></span><br><span class="line"><span class="comment"># (Used to normalize the read density for RPKM calculation)</span></span><br><span class="line">coverages = [27232306,</span><br><span class="line">             16799279,</span><br><span class="line">             31298963,</span><br><span class="line">             26308550,</span><br><span class="line">             27067722,</span><br><span class="line">             17372484,</span><br><span class="line">             26095030,</span><br><span class="line">             26980460]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Bar color for Bayes factor distribution</span></span><br><span class="line"><span class="comment"># plots (--plot-bf-dist)</span></span><br><span class="line"><span class="comment"># Paint them blue</span></span><br><span class="line">bar_color = <span class="string">&quot;b&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Bayes factors thresholds to use for --plot-bf-dist</span></span><br><span class="line">bf_thresholds = [0, 1, 2, 5, 10, 20]</span><br></pre></td></tr></table></figure>
<p>可视化结果如下<br>因为我们选取的剪切事件是SRR974978和SRR974982之间的差异剪切事件，所以在多个样本间趋势不是很明显。但这里我们先学个方法。<br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/sashimi_plot1.JPG"/></p>
]]></content>
      <tags>
        <tag>NGS</tag>
      </tags>
  </entry>
  <entry>
    <title>特定版本R包下载及其报错</title>
    <url>/2020/02/16/%E7%89%B9%E5%AE%9A%E7%89%88%E6%9C%ACR%E5%8C%85%E4%B8%8B%E8%BD%BD%E5%8F%8A%E5%85%B6%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<p>Error: Failed to install ‘unknown package’ from URL:<br>(converted from warning) installation of package ‘dtw’ had non-zero exit status</p>
<a id="more"></a>

<h1 id="特定版本R包下载及其报错"><a href="#特定版本R包下载及其报错" class="headerlink" title="特定版本R包下载及其报错"></a>特定版本R包下载及其报错</h1><h2 id="下载Seurat-2-×-×"><a href="#下载Seurat-2-×-×" class="headerlink" title="下载Seurat 2.×.×"></a>下载Seurat 2.×.×</h2><p>首先查看版本信息：<a href="https://github.com/satijalab/seurat/releases">https://github.com/satijalab/seurat/releases</a></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">require(devtools)</span><br><span class="line">install_version(<span class="string">&quot;Seurat&quot;</span>,version = <span class="string">&quot;2.3.3&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>报错如下</strong></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">Error: Failed to install <span class="string">&#x27;unknown package&#x27;</span> from URL:</span><br><span class="line">(converted from warning) installation of package ‘dtw’ had non-zero exit status</span><br></pre></td></tr></table></figure>
<p>显示R包<code>dtw</code>退出码非零，即不正常退出，思考再三，是不是因为这个Seurat依赖的R包没有存在并且下载不成功导致的呢？<br>尝试单独下载R包<code>dtw </code></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">install.packages(<span class="string">&quot;dtw&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">package ‘dtw’ successfully unpacked and MD5 sums checked</span><br><span class="line">The downloaded binary packages are <span class="keyword">in</span> ...</span><br></pre></td></tr></table></figure>
<h2 id="再次下载Seurat-2-×-×"><a href="#再次下载Seurat-2-×-×" class="headerlink" title="再次下载Seurat 2.×.×"></a>再次下载Seurat 2.×.×</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">require(devtools)</span><br><span class="line">install_version(<span class="string">&quot;Seurat&quot;</span>,version = <span class="string">&quot;2.3.3&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>再次得到报错信息</strong></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">Error: Failed to install <span class="string">&#x27;unknown package&#x27;</span> from URL:</span><br><span class="line">(converted from warning) installation of package ‘doSNOW’ had non-zero exit status</span><br></pre></td></tr></table></figure>
<ul>
<li>此次报错和上次类似，但变成另一个R包退出码非零，说明上次的排错思路可能是对的。</li>
<li>于是后面每次出现类似的报错就单独下载相应的R包，在尝试下载Seurat 2.3.3。</li>
</ul>
<p><strong>第N次得到报错信息</strong></p>
<ol>
<li>用以下方法试图下载Seurat 2.3.3依赖的R包<code>SDMTool</code></li>
</ol>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#方法1</span></span><br><span class="line">install.packages(<span class="string">&quot;SDMTools&quot;</span>)</span><br><span class="line"><span class="comment">#方法2</span></span><br><span class="line">BiocManager::install(<span class="string">&quot;SDMTools&quot;</span>)</span><br><span class="line"><span class="comment">#方法3</span></span><br><span class="line">source(<span class="string">&quot;https://bioconductor.org/biocLite.R&quot;</span>)</span><br><span class="line">biocLite(<span class="string">&quot;SDMTools&quot;</span>)</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>遗憾的是，报错了，报错信息都是以下内容</li>
</ol>
<p>😭<font color=blue>你时常感概，国内的网怎么老是不能通向世界呢😭</font></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">package ‘SDMTools’ is not available (<span class="keyword">for</span> R version <span class="number">3.5</span>.2)</span><br></pre></td></tr></table></figure>
<ol>
<li>所以只好手动下载<code>SDMTools</code>,手动安装  </li>
</ol>
<ul>
<li><p>首先登陆<a href="https://cran.r-project.org/">CRAN官网</a>，点击进入<strong>Download R for Windows</strong>（这个视不同系统而定）</p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/CRANwedsite.JPG"/>
</li>
<li><p>点击contrib</p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/CRANcontrib.JPG"/>
</li>
<li><p>点击相应的R版本，进入R包界面，<code>ctrl+F</code>搜索所需要的R包，下载到本地</p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/DMTools.JPG"/>
</li>
<li><p>进入Rstudio,点击Tools,点击install packages…或者直接点击environment下的install</p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/unautoinstall.JPG"/>   
然后点击install即可

</li>
</ul>
<h2 id="当你再次下载Seurat-2-3-3时，遇上第N-1次报错"><a href="#当你再次下载Seurat-2-3-3时，遇上第N-1次报错" class="headerlink" title="当你再次下载Seurat 2.3.3时，遇上第N+1次报错"></a>当你再次下载Seurat 2.3.3时，遇上第N+1次报错</h2><p>当你解决了上诉报错问题后，你还会收到各种各样的报错，比如缺少这个包，缺少那个包。你就当体验一次手动解决R包之间的依赖关系好了。直到不再提示缺少什么R包。</p>
<h2 id="再再再次次次下载Seurat-2-3-3"><a href="#再再再次次次下载Seurat-2-3-3" class="headerlink" title="再再再次次次下载Seurat 2.3.3"></a>再再再次次次下载Seurat 2.3.3</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">require(devtools)</span><br><span class="line">install_version(<span class="string">&quot;Seurat&quot;</span>,version = <span class="string">&quot;2.3.3&quot;</span>)</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/seuratdone.JPG"/>

<p><strong>成功！！！</strong></p>
<h2 id="加载Seurat并查看相关信息"><a href="#加载Seurat并查看相关信息" class="headerlink" title="加载Seurat并查看相关信息"></a>加载Seurat并查看相关信息</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(Seurat)</span><br><span class="line">sessionInfo()</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/seuratinfo.JPG"/>
]]></content>
      <tags>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title>磁盘管理 （分区、格式化、挂载、卸载）</title>
    <url>/2020/02/08/%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>磁盘管理（基础篇）</p>
<a id="more"></a>

<h1 id="磁盘管理-（分区、格式化、挂载、卸载）"><a href="#磁盘管理-（分区、格式化、挂载、卸载）" class="headerlink" title="磁盘管理 （分区、格式化、挂载、卸载）"></a>磁盘管理 （分区、格式化、挂载、卸载）</h1><h2 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h2><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/磁盘结构.JPG"/>  

<ul>
<li>磁盘的0磁道0柱面1扇区存储的是MBR（主引导记录）信息，位于最外圈。    </li>
<li>MBR共512个字节，446的主引导程序+64的分区表+2的魔数（分区结束符）组成。<br>一个分区占16个字节，64个字节的分区表，所以主分区和扩展分区加起来不能超过4个。  </li>
</ul>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/MBR.JPG"/>
  
## 磁盘表示      
- /dev/sda1  
  /dev 设备文件目录  
  sd：sata,sas,usb,scsi接口硬盘    hd：代表IDE接口的硬盘   
  a：linux用字母表示第几块磁盘，a代表第一块 
  1：linux用数字表示某块磁盘的第几个分区   
## 磁盘使用概述  
- 磁盘初始化  
  MBR OR GPT  
- 磁盘分区  
  一个磁盘只能分4个分区：主分区+扩展分区<=4  
- 格式化  
  文件系统主要负责数据如何存储在硬盘上  
- 磁盘挂载  
  设备必须经过挂在才可以使用  

<p><strong>分区介绍</strong><br>计算机中存放信息的主要的存储设备就是硬盘，但是硬盘不能直接使用，必须对硬盘进行分割，分割成一块一块的硬盘区域就是磁盘分区。传统的磁盘管理中，将一个硬盘分为两大类分区：主分区和扩展分区。主分区是能够安装操作系统，能够进行计算机启动的分区，这样的分区可以直接格式化，然后安装操作系统，直接存放文件。扩展分区无法直接使用，必须在扩展分区中再次划分逻辑驱动器，才可以经过格式化后存放数据。  </p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/磁盘分区.JPG"/>   

<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/diskpartition.JPG"/>


<p><strong>fdisk分区命令</strong><br>linux fdisk是一个创建和维护分区表的程序，它兼容DOS类型的分区表、BSD或者SUN类型的磁盘列表。<br>语法：fdisk [命令选项][参数]<br>必要选项：-l 列出所有分区表<br>参数：可以是指定的磁盘，如果不指定，默认列出所有磁盘<br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/fdiskresult.JPG"/></p>
<ul>
<li>一共3块磁盘：/dev/sda、/dev/sdb、/dev/sdc  </li>
<li>/dev/sda这块磁盘进行了分区，带<code>*</code>的分区/dev/sda1表示系统启动盘。Id：83表示linux的基本分区，Id：8e表示linux的逻辑卷分区。System:Extended表示扩展分区。System:Linux LVM表示逻辑卷分区。  </li>
<li>/dev/sdb、/dev/sdc这两块盘并没有进行磁盘分区。  </li>
<li>/dev/mapper/centos-root为卷组。</li>
<li>/dev/mapper/centos-swap为交换分区。    </li>
</ul>
<p><font color=blue>主分区可以直接格式化存数据，扩展分区要划逻辑驱动器，对逻辑驱动器进行格式化后才能存数据。</font></p>
<h2 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h2><p><strong>练习</strong>  </p>
<ul>
<li>分一个主分区  </li>
<li>分一个扩展分区，并分两个逻辑驱动器  </li>
<li>分一个交换分区</li>
</ul>
<ol>
<li>添加一个主分区（500M）。</li>
<li>添加一个扩展分区（剩下所有的空间）。此时再想添加一个主分区，就会发现扇区不够了。</li>
<li>SWAP（交换）分区是一种通过在硬盘中预先划分一定的空间，然后将把内存中暂时不常用的数据临时存放到硬盘中，以便腾出物理内存空间让更活跃的程序服务来使用的技术，其设计目的是为了解决真实物理内存不足的问题。但由于交换分区毕竟是通过硬盘设备读写数据的，速度肯定要比物理内存慢，所以只有当真实的物理内存耗尽后才会调用交换分区的资源。  </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fdisk /dev/sdb</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/devsdb1.JPG"/>  

<ol>
<li>添加两个逻辑驱动器 /dev/sdb5  /dev/sdb6 各分500M空间 </li>
</ol>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/devsdb2.JPG"/>

<ol start="3">
<li>添加一个交换分区  </li>
</ol>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/devsdb3.JPG"/>

<ol start="4">
<li>查看/dev/sdb磁盘分区结果  </li>
</ol>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/devsdbfinal.JPG"/>

<h2 id="磁盘格式化"><a href="#磁盘格式化" class="headerlink" title="磁盘格式化"></a>磁盘格式化</h2><p><strong>格式化</strong>  </p>
<ul>
<li>格式化是指对磁盘或磁盘中的分区进行初始化的一种操作，这种操作通常会导致现有的磁盘或分区中所有的文件被清楚。<br>格式化就相当于给磁盘装一个大管家，这位大管家负责数据怎么在硬盘中读入读出。但是这位大管家在接管这块硬盘的时候会一股脑清除里面原来的东西，接着再按照自己的方式管理这块磁盘。  </li>
<li>格式化通常分为低级格式化和高级格式化。如果没有特别指明，对硬盘的格式化通常是指高级格式化。  </li>
</ul>
<p><strong>文件系统</strong>  </p>
<ul>
<li>文件系统：负责管理和存储数据的系统<br>数据是以什么方式存在于硬盘，又是以什么方式读出的。  </li>
<li>文件系统类型<br>ext2、ext3、ext4、xfs </li>
</ul>
<p><strong>mkfs</strong><br>mkfs [options] device<br>命令选项<br>-t：指定文件系统类型</p>
<p><strong>练习</strong>  </p>
<ul>
<li>主分区<font color=blue>格式化为ext4</font>  </li>
<li>两个逻辑分区分别<font color=blue>格式化为xfs、ext3</font>  </li>
<li><font color=blue>交换分区的格式化</font>   </li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将/dev/sdb1主分区格式化为ext4文件系统</span></span><br><span class="line">mkfs -t ext4 /dev/sdb1</span><br></pre></td></tr></table></figure>

<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/ext4.JPG"/>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将/dev/sdb5逻辑分区格式化为xfs文件系统 </span></span><br><span class="line">mkfs -t xfs /dev/sdb5</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/xfs.JPG"/>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将/dev/sdb6逻辑分区格式化为ext3文件系统</span></span><br><span class="line">mkfs -t ext3 /dev/sdb6</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/ext3.JPG"/>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将/dev/sdb7交换分区格式化</span></span><br><span class="line">mkswap /dev/sdb7</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/swap.JPG"/>

<h2 id="磁盘挂载"><a href="#磁盘挂载" class="headerlink" title="磁盘挂载"></a>磁盘挂载</h2><p><strong>挂载</strong>  </p>
<ul>
<li>linux中的所有设备必须经过挂载才可以被用户使用</li>
<li>挂载的方式其实是将某个设备挂到文件系统的某个文件夹   </li>
</ul>
<p><strong>mount</strong>  </p>
<ul>
<li>命令语法<br>mount device directory </li>
<li>命令选项<br>-a：挂载所有文件系统，参考文件/etc/fstab<br>-l：显示当前挂载<br>-t：文件系统类型<br>-o：指定挂载权限  </li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看当前系统的挂载信息，发现并没有/dev/sdb相关的挂载信息</span></span><br><span class="line">mount -l</span><br></pre></td></tr></table></figure>
<p><strong>手动挂载/dev/sdb1、/dev/sdb5、/dev/sdb6</strong><br><font color=blue>系统重启后，手动挂载方式挂载的分区不会生效</font></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir /opt/sdb1</span><br><span class="line">mkdir /opt/sdb5</span><br><span class="line">mkdir /opt/sdb6</span><br><span class="line">mount /dev/sdb1 /opt/sdb1 <span class="comment">#mount -t ext4 /dev/sdb1 /opt/sdb1</span></span><br><span class="line">mount /dev/sdb5 /opt/sdb5 <span class="comment">#mount -t xfs /dev/sdb5 /opt/sdb5</span></span><br><span class="line">mount /dev/sdb6 /opt/sdb6 <span class="comment">#mount -t ext3 /dev/sdb6 /opt/sdb6</span></span><br><span class="line"><span class="comment">#不使用-t参数指定文件系统类型，系统也会自动识别文件系统类型</span></span><br><span class="line"><span class="comment">#查看当前系统挂载信息，发现多出了/dev/sdb相关信息</span></span><br><span class="line">mount -l</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/mount_l1.JPG"/>

<p><strong>umount</strong>  </p>
<ul>
<li>umount：卸载文件系统  </li>
<li>umount 设备挂载点|设备源<br>-l 加上<code>-l</code>参数进行卸载即——在该设备处于使用中是不进行卸载，在该设备处于空闲时进行卸载</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#卸载3个挂载点</span></span><br><span class="line">umount /dev/sdb1 <span class="comment">#umount /opt/sdb1</span></span><br><span class="line">umount /dev/sdb5 <span class="comment">#umount /opt/sdb5</span></span><br><span class="line">umount /dev/sdb6 <span class="comment">#umount /opt/sdb6</span></span><br><span class="line"><span class="comment">#查看系统当前挂载信息,发现/dev/sdb相关信息消失</span></span><br><span class="line">mount -l | tail</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#尝试对/dev/sdb5进行只读挂载</span></span><br><span class="line">mount -o ro /dev/sdb5 /opt/sdb</span><br><span class="line"><span class="comment">#查看当前挂载信息</span></span><br><span class="line">mount -l | tail  </span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/mount_l2.JPG"/>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#检测/dev/sdb5的权限</span></span><br><span class="line"><span class="built_in">cd</span> /opt/sdb5</span><br><span class="line">touch test.txt</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/mount_l2_1.JPG"/>

<p><strong>自动挂载</strong>  </p>
<ul>
<li>/etc/fstab文件<br>设备  挂载点  文件系统  权限  备份  检测<br><u>权限</u><br>  auto：系统自动挂载，fstab默认就是这个选项<br>  defaults：rw、suid、dev、exec、auto、nouser、async<br>  noauto：开机不自动挂载<br>  nouser：只有超级用户可以挂载<br>  ro：按只读权限挂载<br>  rw：按可读可写权限挂载<br>  user：任何用户都可以挂载<br><u>备份</u><br>  1：允许dump备份程序备份<br>  0：忽略备份操作<br><u>fsck磁盘检测设置</u><br>  0：永远不检测<br>  /目录分区永远都是1<br>  2：其他分区从2开始，数字越小越先检查，如果两个分区的数字相同，则同时检查    </li>
</ul>
<p><strong>练习</strong>   </p>
<ul>
<li>自动挂载一下分区</li>
<li>主分区 格式化ext4 /opt/sdb1  </li>
<li>扩展分区中的两个逻辑驱动器 格式化为xfs ext3  /opt/sdb[5-6]   </li>
<li>交换分区 swap    </li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看以下当前交换分区的大小</span></span><br><span class="line">free -m</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/freem3.JPG"/>

<p><font color=blue>想要设备文件的挂载永久生效，就需要把挂载的信息写入配置文件/etv/fstab。</font></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/fstab</span><br><span class="line"><span class="comment">#添加以下内容到/etc/fstab文件中</span></span><br><span class="line"><span class="comment">#/dev/sdb</span></span><br><span class="line">/dev/sdb1  /opt/sdb1  ext4  defaults  0 0</span><br><span class="line">/dev/sdb5  /opt/sdb5  xfs   ro        0 0</span><br><span class="line">/dev/sdb6  /opt/sdb6  ext3  rw        0 0</span><br><span class="line">/dev/sdb7  swap       swap  defaults  0 0</span><br><span class="line"><span class="comment">#挂载</span></span><br><span class="line">mount -a</span><br><span class="line"><span class="comment">#查看挂载系统当前挂载信息,主分区和两个逻辑分区都挂载成功</span></span><br><span class="line">mount -l</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/automountresult.JPG"/>  

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用设备名（/dev/sdb[number]）的方式挂载可能会出现找不到设备而加载失败的问题。uuid作为系统中存储设备提供的唯一标志字符串，使用UUID则不会出现这样的情况   </span></span><br><span class="line"><span class="comment">#查看uuid的3种方法   </span></span><br><span class="line">blkid</span><br><span class="line">lsblk</span><br><span class="line">ll /dev/disk/by-uuid</span><br><span class="line"><span class="comment">#也就是说，将上述/dev/sdb1换成其对应的uuid，其他的不变</span></span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/uuid1.JPG"/>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/uuid2.JPG"/>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/uuid3.JPG"/>




<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看当前交换分区大小，Swap分区大小没有变化，mount -a不能挂载swap分区</span></span><br><span class="line">free -m</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">&lt;img src=<span class="string">&quot;https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/freem1.JPG&quot;</span>/&gt;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line"><span class="comment">#swap分区的挂载方式</span></span><br><span class="line">swapon -a  <span class="comment">#会自动读取/etc/fstab文件中的分区挂载信息</span></span><br><span class="line"><span class="comment">#也可以通过查看交换分区的大小,相比之前，Swap大小增加了1G</span></span><br><span class="line">free -m</span><br></pre></td></tr></table></figure>

<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/freem2.JPG"/>


<h2 id="另外两个命令df、du"><a href="#另外两个命令df、du" class="headerlink" title="另外两个命令df、du"></a>另外两个命令df、du</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#df命令用于显示目前在Linux系统上的文件系统的磁盘使用情况统计</span></span><br><span class="line">df -Th</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/dfTh.JPG"/>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#du查看文件大小</span></span><br><span class="line">du -h /addfirst/reference/mouse/index/bowtie2-build-index/genome.1.bt2    </span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/duh.JPG"/>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#du -sh查看文件夹大小</span></span><br><span class="line">du -sh /addfirst/reference/</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/dush.JPG"/>   

<h2 id="卸载分区（以-dev-sdb为例）"><a href="#卸载分区（以-dev-sdb为例）" class="headerlink" title="卸载分区（以/dev/sdb为例）"></a>卸载分区（以/dev/sdb为例）</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看当前分区情况</span></span><br><span class="line">df -lh</span><br><span class="line"><span class="comment">#卸载/dev/sdb5分区，但是重启后又会恢复到挂载状态</span></span><br><span class="line">umount /dev/sdb5</span><br><span class="line"><span class="comment">#查看当前分区情况，可以看到/dev/sdb5分区消失</span></span><br><span class="line">df -lh</span><br><span class="line"><span class="comment">#卸载了还可以再挂载，数据都还在</span></span><br></pre></td></tr></table></figure>
<h2 id="删除分区"><a href="#删除分区" class="headerlink" title="删除分区"></a>删除分区</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fdisk /dev/sdb</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/deletepartition.JPG"/>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看/dev/sdb的分区信息</span></span><br><span class="line">fdisk -l /dev/sdb</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/deletedevsdbinfo.JPG"/>

<h2 id="磁盘卸载"><a href="#磁盘卸载" class="headerlink" title="磁盘卸载"></a>磁盘卸载</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#删除掉配置文件/etc/fstab中/dev/sdb的相关信息</span></span><br><span class="line">vim /etc/fstab</span><br><span class="line">reboot</span><br><span class="line"><span class="comment">#重启后查看是否卸载</span></span><br><span class="line">df -lh</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/permanentlydelete.JPG"/>

<p>😄然后关机，就可以删掉相应的硬盘，重新开机后一切正常。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.linuxprobe.com/chapter-06.html">https://www.linuxprobe.com/chapter-06.html</a><br><a href="https://www.bilibili.com/video/av76344853?p=36">https://www.bilibili.com/video/av76344853?p=36</a><br><a href="https://www.cnblogs.com/maohai-kdg/p/12067101.html">https://www.cnblogs.com/maohai-kdg/p/12067101.html</a></p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>2020 ATAC-seq analysis</title>
    <url>/2020/12/08/2020%20ATAC-seq%20analysis/</url>
    <content><![CDATA[<p>ATAC-seq最新处理流程</p>
<a id="more"></a>

<h1 id="2020-ATAC-seq-analysis"><a href="#2020-ATAC-seq-analysis" class="headerlink" title="2020 ATAC-seq analysis"></a><strong>2020 ATAC-seq analysis</strong></h1><h2 id="一、ATAC-seq个性化的conda-environment的搭建"><a href="#一、ATAC-seq个性化的conda-environment的搭建" class="headerlink" title="一、ATAC-seq个性化的conda environment的搭建"></a>一、ATAC-seq个性化的conda environment的搭建</h2><h3 id="1、git-clone"><a href="#1、git-clone" class="headerlink" title="1、git clone"></a>1、git clone</h3><p>git clone文章中提到的atac-seq-pipeline (里面有你接下来分析所需要的绝大部分东西。另外一定要去看README.md，这个文档会告诉你分析ATAC-seq需要做些准备，进行些什么工作。)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/ATAC</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/ENCODE-DCC/atac-seq-pipeline</span><br></pre></td></tr></table></figure>
<h3 id="2、环境搭建"><a href="#2、环境搭建" class="headerlink" title="2、环境搭建"></a>2、环境搭建</h3><p>（1）conda base environment搭建</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#一路yes下去</span></span><br><span class="line">$ wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh</span><br><span class="line">$ bash Miniconda3-4.6.14-Linux-x86_64.sh</span><br><span class="line"><span class="comment">#最后一个yes时你同意了每次自动启动conda的base环境，显示安装完成后，一定要退出当前的终端，再重新打开一次，你就会发现在游标的最左边多了一个（base）,你的base conda environment就激活啦！你的conda环境搭建就成功了一小步(*^__^*) 嘻嘻……</span></span><br></pre></td></tr></table></figure>
<p>（2）失活掉base conda environment自动激活的设置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ conda config --<span class="built_in">set</span> auto_activate_base <span class="literal">false</span></span><br><span class="line"><span class="comment">#同样的完成上诉操作后，记得退出当前终端，再次打开一个新的终端。你就会发现游标的最左边没有（base）了</span></span><br></pre></td></tr></table></figure>
<p>（3）安装pipeline’s conda environment</p>
<p>！？你是不是充满了疑问！？下面的两个shell脚本哪里冒出来的，干什么用的。不要忘了，我们第一步git clone了这个atac-seq-pipeline呢！这两个脚本就是就是来源于这个clone下来的pipeline的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 网不给力的朋友，比如说我，这一部就是整个分析流程的限速步骤！！！网络给力这一步也需要花一些时间，读一下两个shell文件就知道为什么啦。</span></span><br><span class="line">$ bash scripts/uninstall_conda_env.sh  <span class="comment"># uninstall it for clean-install</span></span><br><span class="line"><span class="comment">#下面这个shell脚本会创建两个分析ATAC-seq数据所需要的环境，一个基于python3，一个基于python2的</span></span><br><span class="line">$ bash scripts/install_conda_env.sh</span><br></pre></td></tr></table></figure>
<p>（4）激活安装的conda环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ conda activate encode-atac-seq-pipeline</span><br><span class="line"><span class="comment">#你一定会疑问为什么是encode-atac-seq-pipeline,阅读一下scripts/install_conda_env.sh这个脚本就知道啦。因为源文档作者把这个环境名命名为encode-atac-seq-pipeline。</span></span><br></pre></td></tr></table></figure>
<p>（5）查看所有的conda环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda env list</span><br></pre></td></tr></table></figure>
<p>我们会看到有一个基于python2的环境，没有标明python版本的那个encode-atac-seq-pipeline是基于python3的。有些软件是要基于特定版本的python运行的。<br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/conda environment.JPG"/></p>
<h2 id="二、数据下载"><a href="#二、数据下载" class="headerlink" title="二、数据下载"></a>二、数据下载</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#一次性下载所有的......_1.fastq.gz和......_2.fastq.gz样本</span></span><br><span class="line">dir=/home/gongyuqi/.aspera/connect/etc/asperaweb_id_dsa.openssh</span><br><span class="line">x=_1</span><br><span class="line">y=_2</span><br><span class="line"><span class="keyword">for</span> id <span class="keyword">in</span> &#123;93,98,99&#125;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">ascp -QT -l 300m -P33001 -i <span class="variable">$dir</span> era-fasp@fasp.sra.ebi.ac.uk:/vol1/fastq/SRR126/0<span class="variable">$id</span>/SRR126920<span class="variable">$id</span>/SRR126920$id<span class="variable">$x</span>.fastq.gz .</span><br><span class="line">ascp -QT -l 300m -P33001 -i <span class="variable">$dir</span> era-fasp@fasp.sra.ebi.ac.uk:/vol1/fastq/SRR126/0<span class="variable">$id</span>/SRR126920<span class="variable">$id</span>/SRR126920$id<span class="variable">$y</span>.fastq.gz . </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h2 id="三、bowtie2比对"><a href="#三、bowtie2比对" class="headerlink" title="三、bowtie2比对"></a>三、bowtie2比对</h2><h3 id="1、-fastqc-multiqc查看原始数据的质量情况"><a href="#1、-fastqc-multiqc查看原始数据的质量情况" class="headerlink" title="1、 fastqc+multiqc查看原始数据的质量情况"></a>1、 fastqc+multiqc查看原始数据的质量情况</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda install -y fastqc multiqc</span><br><span class="line"><span class="built_in">cd</span> raw </span><br><span class="line">fastqc -t 8 *gz -o ./</span><br><span class="line">multiqc *.gzip -o ./</span><br></pre></td></tr></table></figure>
<p>multiqc结果表明原始数据质量已经很好了，完全没有adaptor残留,连PCR重复都是勉强过关的。per base sequence content和kmer content两项指标不合格，但是并不会对后续的比对造成多大的负面影响，同时这两项指标通过过滤软件的处理可能并不会后得到改善。这样的数据其实可以直接比对的。<br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/multiqc.JPG"/></p>
<h3 id="2、-过滤低质量的reads"><a href="#2、-过滤低质量的reads" class="headerlink" title="2、 过滤低质量的reads"></a>2、 过滤低质量的reads</h3><p>（如果原始数据需要进行过滤处理，那么走下面这个过滤流程，我们这里就不过滤了）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nohup cat rawdata.txt|<span class="keyword">while</span> <span class="built_in">read</span> id</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">arr=(<span class="variable">$&#123;id&#125;</span>)</span><br><span class="line">fq1=<span class="variable">$&#123;arr[0]&#125;</span></span><br><span class="line">fq2=<span class="variable">$&#123;arr[1]&#125;</span></span><br><span class="line">trim_galore -j 35 --phred33 --length 35 -e 0.1 --stringency 4 --paired -o ../clean <span class="variable">$fq1</span> <span class="variable">$fq2</span></span><br><span class="line"><span class="keyword">done</span> &amp;</span><br><span class="line"><span class="comment">#过滤后的数据质量控制，看数据是否有得到改善，有没有去掉adaptor非常重要</span></span><br><span class="line"><span class="built_in">cd</span> clean</span><br><span class="line">fastqc -t 20 *gz -o ./</span><br><span class="line">multiqc *.gzip -o ./</span><br></pre></td></tr></table></figure>


<h3 id="3、-比对参考基因组"><a href="#3、-比对参考基因组" class="headerlink" title="3、 比对参考基因组"></a>3、 比对参考基因组</h3><ul>
<li><p>比对</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nohup cat sample.txt | <span class="keyword">while</span> <span class="built_in">read</span> id</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">arr=(<span class="variable">$&#123;id&#125;</span>)</span><br><span class="line">fq1=<span class="variable">$&#123;arr[0]&#125;</span></span><br><span class="line">fq2=<span class="variable">$&#123;arr[1]&#125;</span></span><br><span class="line">sample=<span class="variable">$&#123;fq1%%_*&#125;</span>.sort.bam</span><br><span class="line">bowtie2  --very-sensitive -X2000 --mm --threads 8 -x /home/gongyuqi/ref/mm10/index/mm10 -1 <span class="variable">$fq1</span> -2 <span class="variable">$fq2</span>|samtools sort -O bam -@ 8 - -o ../align/<span class="variable">$sample</span> </span><br><span class="line"><span class="keyword">done</span> &amp;</span><br></pre></td></tr></table></figure>
</li>
<li><p>比对情况统计及查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls *.bam | <span class="keyword">while</span> <span class="built_in">read</span> id</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">nohup samtools flagstat -@ 4 <span class="variable">$id</span>  &gt; <span class="variable">$&#123;id%%.*&#125;</span>.<span class="built_in">stat</span> &amp;</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">ls *.<span class="built_in">stat</span> | <span class="keyword">while</span> <span class="built_in">read</span> id; <span class="keyword">do</span> cat <span class="variable">$id</span> | grep <span class="string">&quot;mapped (&quot;</span>;<span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/mapped.JPG"/>
</li>
<li><p>生成bam文件的索引文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nohup ls *sort.bam|<span class="keyword">while</span> <span class="built_in">read</span> id; <span class="keyword">do</span> samtools index -@ 10 <span class="variable">$id</span>;<span class="keyword">done</span> &amp;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="四、PCR去除重及质控制"><a href="#四、PCR去除重及质控制" class="headerlink" title="四、PCR去除重及质控制"></a>四、PCR去除重及质控制</h2><h3 id="1、初步过滤"><a href="#1、初步过滤" class="headerlink" title="1、初步过滤"></a>1、初步过滤</h3><p>#=============================<br>#Remove unmapped, mate unmapped<br>#not primary alignment, reads failing platform<br>#Only keep properly paired reads<br>#Obtain name sorted BAM file<br>#=============================================</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#fixmate要求输入的bam文件按名称排序，所以第一步初步过滤后要按reads名称排序一下</span></span><br><span class="line">nohup ls *.sort.bam|<span class="keyword">while</span> <span class="built_in">read</span> id; <span class="keyword">do</span> samtools view -@ 8 -F 524 -f 2 -u <span class="variable">$id</span> | samtools sort -@ 8 -n /dev/stdin -o ../filter/<span class="variable">$&#123;id%%.*&#125;</span>.filt.nmsrt.bam;<span class="keyword">done</span> &amp;</span><br><span class="line"><span class="comment">#multimapping=4是bowtie2的默认设置</span></span><br><span class="line"><span class="built_in">cd</span> ../filter</span><br><span class="line">multimapping=4 </span><br><span class="line">nohup ls *filt.nmsrt.bam|<span class="keyword">while</span> <span class="built_in">read</span> id;<span class="keyword">do</span> samtools view -@ 8 -h <span class="variable">$id</span>|assign_multimappers.py -k <span class="variable">$multimapping</span> --paired-end |samtools fixmate -@ 8 -r /dev/stdin <span class="variable">$&#123;id%%.*&#125;</span>.filt.nmsrt.fixmate.bam; <span class="keyword">done</span> &amp;</span><br></pre></td></tr></table></figure>
<h3 id="2、进一步"><a href="#2、进一步" class="headerlink" title="2、进一步"></a>2、进一步</h3><p>#===============================================<br>#Remove orphan reads (pair was removed)<br>#and read pairs mapping to different chromosomes<br>#Obtain position sorted BAM<br>#===============================================</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#多个样本写循环</span></span><br><span class="line">nohup ls *.filt.nmsrt.fixmate.bam|<span class="keyword">while</span> <span class="built_in">read</span> id; <span class="keyword">do</span> samtools view -@ 8 -F 1804 -f 2 -u <span class="variable">$id</span> | samtools sort -@ 8 /dev/stdin -o <span class="variable">$&#123;id%%.*&#125;</span>.prefilt.bam;<span class="keyword">done</span> &amp;</span><br></pre></td></tr></table></figure>
<h3 id="3、标记PCR重复"><a href="#3、标记PCR重复" class="headerlink" title="3、标记PCR重复"></a>3、标记PCR重复</h3><p>#===============<br>#Mark duplicates<br>#===============</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MARKDUP=/home/gongyuqi/miniconda3/envs/encode-atac-seq-pipeline/share/picard-2.20.7-0/picard.jar</span><br><span class="line"><span class="comment">#多个样本写循环</span></span><br><span class="line">nohup ls *.prefilt.bam|<span class="keyword">while</span> <span class="built_in">read</span> id;<span class="keyword">do</span> java -Xmx16G -jar <span class="variable">$MARKDUP</span> MarkDuplicates INPUT=<span class="variable">$id</span> OUTPUT=<span class="variable">$&#123;id%%.*&#125;</span>.prefilt.dupmark.bam METRICS_FILE=<span class="variable">$&#123;id%%.*&#125;</span>.prefilt.dupmark.qc VALIDATION_STRINGENCY=LENIENT ASSUME_SORTED=<span class="literal">true</span> REMOVE_DUPLICATES=<span class="literal">false</span>;<span class="keyword">done</span> &amp;</span><br></pre></td></tr></table></figure>
<h3 id="4、去除PCR重复、建立索引文件、按name排序的bam文件、质控文件"><a href="#4、去除PCR重复、建立索引文件、按name排序的bam文件、质控文件" class="headerlink" title="4、去除PCR重复、建立索引文件、按name排序的bam文件、质控文件"></a>4、去除PCR重复、建立索引文件、按name排序的bam文件、质控文件</h3><p>#============================<br>#Remove duplicates<br>#Index final position sorted BAM<br>#Create final name sorted BAM<br>#============================</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#多个样本写循环</span></span><br><span class="line"><span class="comment">#去重</span></span><br><span class="line">nohup ls *.prefilt.dupmark.bam|<span class="keyword">while</span> <span class="built_in">read</span> id;<span class="keyword">do</span> samtools view -@ 16 -F 1804 -f 2 -b <span class="variable">$id</span> &gt; <span class="variable">$&#123;id%%.*&#125;</span>.nodup.bam;<span class="keyword">done</span> &amp;</span><br><span class="line"><span class="comment">#构建索引文件</span></span><br><span class="line">nohup ls *nodup.bam|<span class="keyword">while</span> <span class="built_in">read</span> id;<span class="keyword">do</span> samtools index <span class="variable">$id</span>;<span class="keyword">done</span> &amp;</span><br></pre></td></tr></table></figure>
<h3 id="5、测序文库复杂度的检验"><a href="#5、测序文库复杂度的检验" class="headerlink" title="5、测序文库复杂度的检验"></a>5、测序文库复杂度的检验</h3><p>#=============================<br>#Compute library complexity<br>#=============================<br>#Sort by name<br>#convert to bedPE and obtain fragment coordinates<br>#sort by position and strand<br>#Obtain unique count statistics<br>#================================================</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#多个样本写循环</span></span><br><span class="line">nohup ls *.nodup.bam|<span class="keyword">while</span> <span class="built_in">read</span> id;<span class="keyword">do</span> samtools sort -@ 16 -n <span class="variable">$id</span> -o <span class="variable">$&#123;id%%.*&#125;</span>.nodup.srt.name.bam;<span class="keyword">done</span> &amp;</span><br><span class="line">nohup ls *.nodup.srt.name.bam|<span class="keyword">while</span> <span class="built_in">read</span> id; <span class="keyword">do</span> bedtools bamtobed -bedpe -i <span class="variable">$id</span> | awk <span class="string">&#x27;BEGIN&#123;OFS=&quot;\t&quot;&#125;&#123;print $1,$2,$4,$6,$9,$10&#125;&#x27;</span> | grep -v <span class="string">&#x27;chrM&#x27;</span> | sort | uniq -c | awk <span class="string">&#x27;BEGIN&#123;mt=0;m0=0;m1=0;m2=0&#125; ($1==1)&#123;m1=m1+1&#125; ($1==2)&#123;m2=m2+1&#125; &#123;m0=m0+1&#125; &#123;mt=mt+$1&#125; END&#123;m1_m2=-1.0; if(m2&gt;0) m1_m2=m1/m2;printf &quot;%d\t%d\t%d\t%d\t%f\t%f\t%f\n&quot;,mt,m0,m1,m2,m0/mt,m1/m0,m1_m2&#125;&#x27;</span> &gt; <span class="variable">$&#123;id%%.*&#125;</span>.nodup.pbc.qc;<span class="keyword">done</span> &amp;</span><br></pre></td></tr></table></figure>
<p>Library complexity measures计算结果如下，…nodup.pbc.qc文件格式为：<br>TotalReadPairs<br>DistinctReadPairs<br>OneReadPair<br>TwoReadPairs<br>NRF=Distinct/Total<br>PBC1=OnePair/Distinct<br>PBC2=OnePair/TwoPair</p>
<p>针对NRF、PBC1、PBC2这几个指标，ENCODE官网提供的标准如下:</p>
<p><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/NRF-PBC1-PBC2.jpeg"></p>
<p>我们此次4个样本的分析结果显示这几个指标的值如下所示：</p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/NRF PBC1 PBC2.JPG"/>

<p>除了第一个样本（SRR12692092），其他样本计算结果显示NRF、PBC1、PBC2的值都非常完美，说明我们进行过滤和PCR去重的bam文件质量上没有问题，可以用于后续的分析。</p>
<h3 id="6、插入片段质控检测"><a href="#6、插入片段质控检测" class="headerlink" title="6、插入片段质控检测"></a>6、插入片段质控检测</h3><table><tr><td bgcolor=GreenYellow>用于评估ATAC/Chip实验质量好坏的一个重要指标</td></tr></table>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#多个样本循环</span></span><br><span class="line">picard_jar=/home/gongyuqi/miniconda3/envs/encode-atac-seq-pipeline/share/picard-2.20.7-0/picard.jar</span><br><span class="line">nohup ls *.nodup.srt.name.bam | <span class="keyword">while</span> <span class="built_in">read</span> id; <span class="keyword">do</span> java -Xmx6G -XX:ParallelGCThreads=1 -jar <span class="variable">$&#123;picard_jar&#125;</span> CollectInsertSizeMetrics INPUT=<span class="variable">$id</span> OUTPUT=<span class="variable">$&#123;id%%.*&#125;</span>.INSERT.DATA H=<span class="variable">$&#123;id%%.*&#125;</span>.INSERT.PLOT.pdf VERBOSITY=ERROR QUIET=TRUE USE_JDK_DEFLATER=TRUE USE_JDK_INFLATER=TRUE W=1000 STOP_AFTER=5000000; <span class="keyword">done</span> &amp;</span><br></pre></td></tr></table></figure>
<p>成功的ATAC-seq实验会生成具有逐级递减和周期性的峰，对应无核小体区域（Nucleosome free region, NRF,100bp）,单核区域（mono-nucleosome,200bp），双核区域（400bp），三核区域（600bp）。</p>
<p>本次结果显示样本质量OK</p>
<p><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/SRR12692092.INSERT.PLOT.jpg" width="50%"><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/SRR12692093.INSERT.PLOT.jpg" width="50%"></p>
<p><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/SRR12692098.INSERT.PLOT.jpg" width="50%"><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/SRR12692099.INSERT.PLOT.jpg" width="50%"></p>
<h3 id="7、TSS富集"><a href="#7、TSS富集" class="headerlink" title="7、TSS富集"></a>7、TSS富集</h3><p><strong>以BRM014-10uM_24h_wt样本为例，可视化peaks在基因组上的分布特征(TSS区域；TSS、gene-body、TSE区域)</strong></p>
<ul>
<li>both -R and -S can accept multiple files</li>
<li>UCSC官网下载小鼠参考基因组注释文件，详情参考：<a href="http://www.bio-info-trainee.com/2494.html">http://www.bio-info-trainee.com/2494.html</a></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#生成bw文件用于后续的computeMatrix</span></span><br><span class="line">nohup ls *.nodup.bam |<span class="keyword">while</span> <span class="built_in">read</span> id</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">nohup bamCoverage --normalizeUsing CPM -b <span class="variable">$id</span> -o <span class="variable">$&#123;id%%.*&#125;</span>.nodup.bw</span><br><span class="line"><span class="keyword">done</span> &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment">#注释文件绝对路劲</span></span><br><span class="line">refseq=/home/gongyuqi/ref/mm10/mouse.ucsc.refseq.bed</span><br><span class="line"></span><br><span class="line"><span class="comment">#TSS</span></span><br><span class="line"><span class="comment">##生成plotHeatmap需要的gz文件</span></span><br><span class="line">nohup computeMatrix reference-point  --referencePoint TSS  -p 30 \</span><br><span class="line">-b 3000 -a 3000 \</span><br><span class="line">-R <span class="variable">$refseq</span> \</span><br><span class="line">-S SRR12692098.nodup.bw SRR12692099.nodup.bw \</span><br><span class="line">--skipZeros -o BRM014-10uM_24h_wt_TSS.gz \</span><br><span class="line">--outFileSortedRegions BRM014-10uM_24h_wt_TSS.bed &amp;</span><br><span class="line"><span class="comment">##可视化文件</span></span><br><span class="line">nohup plotHeatmap -m BRM014-10uM_24h_wt_TSS.gz  -out BRM014-10uM_24h_wt_TSS_rainbow.png --colorMap rainbow &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment">#TSS_gene-body_TSE</span></span><br><span class="line"><span class="comment">##生成plotHeatmap需要的gz文件</span></span><br><span class="line">nohup computeMatrix scale-regions -p 30 \</span><br><span class="line">-a 3000 -b 3000 -m 5000 \</span><br><span class="line">-R <span class="variable">$refseq</span> \</span><br><span class="line">-S SRR12692098.nodup.bw SRR12692099.nodup.bw \</span><br><span class="line">--skipZeros -o BRM014-10uM_24h_wt_TSS_gene0body_TSE.gz \</span><br><span class="line">--outFileSortedRegions BRM014-10uM_24h_wt_TSS.bed &amp;</span><br><span class="line"><span class="comment">##可视化文件</span></span><br><span class="line">nohup plotHeatmap -m BRM014-10uM_24h_wt_TSS_genebody_TSE.gz  -out BRM014-10uM_24h_wt_TSS_genebody_TSE.png --colorMap rainbow &amp;</span><br></pre></td></tr></table></figure>
<p><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/BRM014-10uM_24h_wt_TSS_rainbow.png" width="50%"><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/BRM014-10uM_24h_wt_TSS_genebody_TSE.png" width="50%"></p>
<h2 id="五、生成tagAlign格式文件"><a href="#五、生成tagAlign格式文件" class="headerlink" title="五、生成tagAlign格式文件"></a>五、生成tagAlign格式文件</h2><h3 id="1-Convert-PE-BAM-to-tagAlign"><a href="#1-Convert-PE-BAM-to-tagAlign" class="headerlink" title="1. Convert PE BAM to tagAlign"></a>1. Convert PE BAM to tagAlign</h3><ul>
<li>对于单端序列。直接用bed格式就可以；对于双端序列，推荐用bedpe格式。这两种格式都可以称之为tagAlign，可以作为macs的输入文件。</li>
<li>tagAligen格式相比bam，文件大小会小很多，更加方便文件的读取。在转换得到tagAlign格式之后，我们就可以很容易的将坐标进行偏移</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nohup ls *nodup.srt.name.bam|<span class="keyword">while</span> <span class="built_in">read</span> id; <span class="keyword">do</span> bedtools bamtobed -bedpe -mate1 -i <span class="variable">$id</span>  | gzip -nc &gt; <span class="variable">$&#123;id%%.*&#125;</span>.nodup.srt.name.bedpe.gz;<span class="keyword">done</span> &amp;</span><br><span class="line"><span class="comment">#含有chrM的染色体的TagAlign文件</span></span><br><span class="line">nohup ls *.nodup.srt.name.bedpe.gz | <span class="keyword">while</span> <span class="built_in">read</span> id; <span class="keyword">do</span> zcat <span class="variable">$id</span> | awk <span class="string">&#x27;BEGIN&#123;OFS=&quot;\t&quot;&#125;&#123;printf &quot;%s\t%s\t%s\tN\t1000\t%s\n%s\t%s\t%s\tN\t1000\t%s\n&quot;,$1,$2,$3,$9,$4,$5,$6,$10&#125;&#x27;</span> | gzip -nc &gt; <span class="variable">$&#123;id%%.*&#125;</span>.nodup.srt.name.tagAlign.gz; <span class="keyword">done</span> &amp;</span><br><span class="line"><span class="comment">#去除chrM的染色体的TagAlign文件</span></span><br><span class="line">nohup ls *nodup.srt.name.bedpe.gz|<span class="keyword">while</span> <span class="built_in">read</span> id; <span class="keyword">do</span> zcat <span class="variable">$id</span> | grep -P -v <span class="string">&quot;^chrM&quot;</span> | awk <span class="string">&#x27;BEGIN&#123;OFS=&quot;\t&quot;&#125;&#123;printf &quot;%s\t%s\t%s\tN\t1000\t%s\n%s\t%s\t%s\tN\t1000\t%s\n&quot;,$1,$2,$3,$9,$4,$5,$6,$10&#125;&#x27;</span> | gzip -nc &gt; <span class="variable">$&#123;id%%.*&#125;</span>.nodup.nomit.srt.name.tagAlign.gz; <span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<h3 id="2-Stand-Cross-Correlation-analysis"><a href="#2-Stand-Cross-Correlation-analysis" class="headerlink" title="2. Stand Cross Correlation analysis"></a>2. Stand Cross Correlation analysis</h3><table><tr><td bgcolor=GreenYellow>用于评估ATAC/Chip实验质量好坏的一个重要指标</td></tr></table>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">NREADS=25000000</span><br><span class="line">nohup ls *.nodup.srt.name.bedpe.gz | <span class="keyword">while</span> <span class="built_in">read</span> id; <span class="keyword">do</span> zcat <span class="variable">$id</span> | grep -v “chrM” | shuf -n <span class="variable">$&#123;NREADS&#125;</span> --random-source=&lt;(openssl enc -aes-256-ctr -pass pass:$(zcat -f <span class="variable">$&#123;id%%.*&#125;</span>.nodup.srt.name.tagAlign.gz | wc -c) -nosalt &lt;/dev/zero 2&gt;/dev/null) | awk <span class="string">&#x27;BEGIN&#123;OFS=&quot;\t&quot;&#125;&#123;print $1,$2,$3,&quot;N&quot;,&quot;1000&quot;,$9&#125;&#x27;</span> | gzip -nc &gt; <span class="variable">$&#123;id%%.*&#125;</span>.nodup.nomit.srt.name.$((NREADS / <span class="number">1000000</span>)).tagAlign.gz; <span class="keyword">done</span> &amp;</span><br><span class="line"><span class="comment">#命令最终会生成交叉相关质量评估文件，*.cc.qc文件中会输出包含11列的信息，重点关注9-11列的信息，cc.plot.pdf文件相当于*.cc.qc文件的可视化</span></span><br><span class="line">nohup ls *$((NREADS / <span class="number">1000000</span>)).tagAlign.gz | <span class="keyword">while</span> <span class="built_in">read</span> id; <span class="keyword">do</span> Rscript $(<span class="built_in">which</span> run_spp.R) -c=<span class="variable">$id</span> -p=10 -filtchr=chrM -savp=<span class="variable">$&#123;id%%.*&#125;</span>.cc.plot.pdf -out=<span class="variable">$&#123;id%%.*&#125;</span>.cc.qc; <span class="keyword">done</span> &amp;</span><br><span class="line"><span class="comment">#质控结果查看，主要看NSC,RSC,Quality tag三个值即输出文件的第9列，第10列，第11列。</span></span><br><span class="line">ls *.cc.qc|<span class="keyword">while</span> <span class="built_in">read</span> id; <span class="keyword">do</span> cat <span class="variable">$id</span> | awk <span class="string">&#x27;&#123;print $9, &quot;\t&quot;, $10, &quot;\t&quot;, $11&#125;&#x27;</span>;<span class="keyword">done</span> </span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/cc.qc.JPG" width="50%">
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/SRR12692092.cc.plot.jpg" width="50%"><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/SRR12692093.cc.plot.jpg" width="50%">

<p><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/SRR12692098.cc.plot.jpg" width="50%"><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/SRR12692099.cc.plot.jpg" width="50%"></p>
<ul>
<li>质控结果解读<blockquote>
<p>Normalized strand cross-correlation coefficent (NSC)：NSC是最大交叉相关值除以背景交叉相关的比率(所有可能的链转移的最小交叉相关值)。NSC值越大表明富集效果越好，NSC值低于1.1表明较弱的富集，小于1表示无富集。NSC值稍微低于1.05，有较低的信噪比或很少的峰，这肯能是生物学真实现象，比如有的因子在特定组织类型中只有很少的结合位点；也可能确实是数据质量差。</p>
<p>Relative strand cross-correlation coefficient (RSC)：RSC是片段长度相关值减去背景相关值除以phantom-peak相关值减去背景相关值。RSC的最小值可能是0，表示无信号；富集好的实验RSC值大于1；低于1表示质量低。</p>
<p>QualityTag: Quality tag based on thresholded RSC (codes: -2:veryLow,-1:Low,0:Medium,1:High,2:veryHigh)</p>
<p>查看交叉相关性质量评估结果，主要看NSC,RSC,Quality tag三个值，这三个值分别对应输出文件的第9列，第10列，第11列。</p>
</blockquote>
</li>
</ul>
<h2 id="六、Call-Peaks"><a href="#六、Call-Peaks" class="headerlink" title="六、Call Peaks"></a>六、Call Peaks</h2><h3 id="1、去除线粒体基因的TagAlign格式文件进行shift操作，输入macs2软件去callpeak"><a href="#1、去除线粒体基因的TagAlign格式文件进行shift操作，输入macs2软件去callpeak" class="headerlink" title="1、去除线粒体基因的TagAlign格式文件进行shift操作，输入macs2软件去callpeak"></a>1、去除线粒体基因的TagAlign格式文件进行shift操作，输入macs2软件去callpeak</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">smooth_window=150 <span class="comment"># default</span></span><br><span class="line">shiftsize=$(( -<span class="variable">$smooth_window</span>/<span class="number">2</span> ))</span><br><span class="line">pval_thresh=0.01</span><br><span class="line">nohup ls *nodup.nomit.srt.name.tagAlign.gz | <span class="keyword">while</span> <span class="built_in">read</span> id; \</span><br><span class="line"><span class="keyword">do</span> macs2 callpeak \</span><br><span class="line">-t <span class="variable">$id</span> -f BED -n <span class="string">&quot;<span class="variable">$&#123;id%%.*&#125;</span>&quot;</span> -g mm -p <span class="variable">$pval_thresh</span> \</span><br><span class="line">--<span class="built_in">shift</span> <span class="variable">$shiftsize</span> --extsize <span class="variable">$smooth_window</span> --nomodel -B --SPMR --keep-dup all --call-summits; \</span><br><span class="line"><span class="keyword">done</span> &amp;</span><br></pre></td></tr></table></figure>
<h3 id="2、去除ENCODE列入黑名单的区域"><a href="#2、去除ENCODE列入黑名单的区域" class="headerlink" title="2、去除ENCODE列入黑名单的区域"></a>2、去除ENCODE列入黑名单的区域</h3><ul>
<li>去除黑名单的bed文件，用于后续的peaks注释<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">BLACKLIST=/home/gongyuqi/project/ATAC/mm10.blacklist.bed.gz</span><br><span class="line"><span class="comment">#*_summits.bed为macs2软件callpeak的结果文件之一</span></span><br><span class="line">nohup ls *_summits.bed | <span class="keyword">while</span> <span class="built_in">read</span> id; <span class="keyword">do</span> bedtools intersect -a <span class="variable">$id</span> -b <span class="variable">$BLACKLIST</span> -v &gt; <span class="variable">$&#123;id%%.*&#125;</span>_filt_blacklist.bed; <span class="keyword">done</span> &amp;</span><br><span class="line"><span class="comment">#查看过滤黑名单的区域前后的bed文件的peaks数</span></span><br><span class="line">ls *summits.bed|<span class="keyword">while</span> <span class="built_in">read</span> id; <span class="keyword">do</span> cat <span class="variable">$id</span> |wc -l &gt;&gt;summits.bed.txt;<span class="keyword">done</span></span><br><span class="line">ls *summits_filt_blacklist.bed|<span class="keyword">while</span> <span class="built_in">read</span> id; <span class="keyword">do</span> cat <span class="variable">$id</span> |wc -l &gt;&gt;summits_filt_blacklist.bed.txt;<span class="keyword">done</span></span><br><span class="line">past summits.bed.txt summits_filt_blacklist.bed.txt </span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/before_after_blacklist-bed.JPG"/>





</li>
</ul>
<ul>
<li>去除黑名单的narrowPeaks文件，用于后续的IDR评估<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用IDR需要先对MACS2的结果文件narrowPeak根据-log10(p-value)进行排序,-log10(p-value)在第八列。</span></span><br><span class="line"><span class="comment"># Sort by Col8 in descending order and replace long peak names in Column 4 with Peak_&lt;peakRank&gt;</span></span><br><span class="line"><span class="comment">#*_peaks.narrowPeak为macs2软件callpeak的结果文件之一</span></span><br><span class="line">NPEAKS=300000 </span><br><span class="line">ls *_peaks.narrowPeak | <span class="keyword">while</span> <span class="built_in">read</span> id; <span class="keyword">do</span> sort -k 8gr,8gr <span class="variable">$id</span> | awk <span class="string">&#x27;BEGIN&#123;OFS=&quot;\t&quot;&#125;&#123;$4=&quot;Peak_&quot;NR ; print $0&#125;&#x27;</span> | head -n <span class="variable">$&#123;NPEAKS&#125;</span> | gzip -nc &gt; <span class="variable">$&#123;id%%_*&#125;</span>.narrowPeak.gz; <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">BLACKLIST=../BLACKLIST/mm10.blacklist.bed.gz</span><br><span class="line"></span><br><span class="line"><span class="comment">#生成不压缩文件</span></span><br><span class="line">ls *.narrowPeak.gz | <span class="keyword">while</span> <span class="built_in">read</span> id; <span class="keyword">do</span> bedtools intersect -v -a <span class="variable">$id</span> -b <span class="variable">$&#123;BLACKLIST&#125;</span> | awk <span class="string">&#x27;BEGIN&#123;OFS=&quot;\t&quot;&#125; &#123;if ($5&gt;1000) $5=1000; print $0&#125;&#x27;</span> | grep -P <span class="string">&#x27;chr[\dXY]+[ \t]&#x27;</span>  &gt; <span class="variable">$&#123;id%%.*&#125;</span>.narrowPeak.filt_blacklist; <span class="keyword">done</span></span><br><span class="line"><span class="comment">#生成压缩文件</span></span><br><span class="line"><span class="comment">#ls *.narrowPeak.gz | while read id; do bedtools intersect -v -a $id -b $&#123;BLACKLIST&#125; | awk &#x27;BEGIN&#123;OFS=&quot;\t&quot;&#125; &#123;if ($5&gt;1000) $5=1000; print $0&#125;&#x27; | grep -P &#x27;chr[\dXY]+[ \t]&#x27; | gzip -nc &gt; $&#123;id%%.*&#125;.narrowPeak.filt_blacklist.gz; done</span></span><br></pre></td></tr></table></figure>
<h3 id="3、Irreproducibility-Discovery-Rate-IDR-评估"><a href="#3、Irreproducibility-Discovery-Rate-IDR-评估" class="headerlink" title="3、Irreproducibility Discovery Rate (IDR)评估"></a>3、Irreproducibility Discovery Rate (IDR)评估</h3><table><tr><td bgcolor=GreenYellow>用于评估重复样本间peaks一致性的重要指标</td></tr></table>
首先生成narrowPeak_sample.txt文件，方便后续循环处理，生成文件内容如下：
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/narrowPeak for idr.JPG"/>

</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nohup cat narrowPeak_sample.txt | <span class="keyword">while</span> <span class="built_in">read</span> id</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">arr=(<span class="variable">$&#123;id&#125;</span>)</span><br><span class="line">Rep1=<span class="variable">$&#123;arr[0]&#125;</span></span><br><span class="line">Rep2=<span class="variable">$&#123;arr[1]&#125;</span></span><br><span class="line">sample=<span class="variable">$&#123;Rep1%%.*&#125;</span>_<span class="variable">$&#123;Rep2%%.*&#125;</span>_idr</span><br><span class="line">idr --samples <span class="variable">$Rep1</span> <span class="variable">$Rep2</span> --input-file-type narrowPeak -o <span class="variable">$sample</span> --plot  </span><br><span class="line"><span class="keyword">done</span> &amp;</span><br></pre></td></tr></table></figure>
<ul>
<li>DMSO_24h_wt （样本处理情况）</li>
<li>SRR12692092.filt_blacklist.narrowPeak SRR12692093.filt_blacklist.narrowPeak</li>
<li>没有通过IDR阈值的显示为红色</li>
</ul>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/SRR12692092_SRR12692093_idr_command.png"/>

<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/SRR12692092_SRR12692093_idr.png"/>

<ul>
<li>BRM014-10uM_24h_wt （样本处理情况）</li>
<li>SRR12692098.filt_blacklist.narrowPeak SRR12692099.filt_blacklist.narrowPeak</li>
<li>没有通过IDR阈值的显示为红色</li>
</ul>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/SRR12692098_SRR12692099_idr_command.png"/>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/SRR12692098_SRR12692099_idr.png"/>

<blockquote>
<p>IDR评估会同时考虑peaks间的overlap和富集倍数的一致性。通过IDR阈值（0.05）的占比越大，说明重复样本间peaks一致性越好。从idr的分析结果看，我们的测试数据还可以的呢。</p>
</blockquote>
<p><strong>IDR评估相关参考资料：</strong>  </p>
<p><a href="https://www.jianshu.com/p/d8a7056b4294?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation">重复样本的处理——IDR</a></p>
<h3 id="4、Fraction-of-reads-in-peaks-FRiP-评估"><a href="#4、Fraction-of-reads-in-peaks-FRiP-评估" class="headerlink" title="4、Fraction of reads in peaks (FRiP)评估"></a>4、Fraction of reads in peaks (FRiP)评估</h3><table><tr><td bgcolor=GreenYellow>反映样本富集效果好坏的评价指标</td></tr></table>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#生成bed文件</span></span><br><span class="line">nohup ls *.nodup.bam|<span class="keyword">while</span> <span class="built_in">read</span> id;<span class="keyword">do</span> (bedtools bamtobed -i <span class="variable">$id</span> &gt;<span class="variable">$&#123;id%%.*&#125;</span>.nodup.bed) ;<span class="keyword">done</span> &amp;</span><br><span class="line"><span class="comment">#批量计算FRiP</span></span><br><span class="line">ls *_summits_filt_blacklist.bed|<span class="keyword">while</span>  <span class="built_in">read</span> id;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$id</span></span><br><span class="line">bed=<span class="variable">$&#123;id%%_*&#125;</span>.nodup.bed </span><br><span class="line">Reads=$(bedtools intersect -a <span class="variable">$bed</span> -b <span class="variable">$id</span> |wc -l|awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>)</span><br><span class="line">totalReads=$(wc -l <span class="variable">$bed</span>|awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$Reads</span>  <span class="variable">$totalReads</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;==&gt; FRiP value:&#x27;</span> $(bc &lt;&lt;&lt; <span class="string">&quot;scale=2;100*<span class="variable">$Reads</span>/<span class="variable">$totalReads</span>&quot;</span>)<span class="string">&#x27;%&#x27;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>FRiP值在5%以上算比较好的。但也不绝对，这是个软阈值，可以作为一个参考。</p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/FRiP.JPG"/>

<p><strong>FRiP评估相关参考资料：</strong></p>
<p><a href="https://www.jianshu.com/p/09e05bcd6981?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation">https://www.jianshu.com/p/09e05bcd6981?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation</a></p>
<h2 id="七、Peak-annotation"><a href="#七、Peak-annotation" class="headerlink" title="七、Peak annotation"></a>七、Peak annotation</h2><h3 id="1、Feature-Distribution"><a href="#1、Feature-Distribution" class="headerlink" title="1、Feature Distribution"></a>1、Feature Distribution</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">setwd(<span class="string">&quot;path to bed file&quot;</span>)</span><br><span class="line">library(ChIPpeakAnno)</span><br><span class="line">library(TxDb.Mmusculus.UCSC.mm10.knownGene)</span><br><span class="line">library(org.Mm.eg.db)</span><br><span class="line">library(BiocInstaller)</span><br><span class="line">library(ChIPseeker)</span><br><span class="line">txdb &lt;- TxDb.Mmusculus.UCSC.mm10.knownGene</span><br><span class="line">promoter &lt;- getPromoters(TxDb=txdb, upstream=<span class="number">3000</span>, downstream=<span class="number">3000</span>)</span><br><span class="line">files = <span class="built_in">list</span>(DMSO_24h_wt_rep1 = <span class="string">&quot;SRR12692092_summits_filt_blacklist.bed&quot;</span>,</span><br><span class="line">             DMSO_24h_wt_rep2 = <span class="string">&quot;SRR12692093_summits_filt_blacklist.bed&quot;</span>,</span><br><span class="line">             BRM014_10uM_24h_wt_rep1 = <span class="string">&quot;SRR12692098_summits_filt_blacklist.bed&quot;</span>,</span><br><span class="line">             BRM014_10uM_24h_wt_rep2 = <span class="string">&quot;SRR12692099_summits_filt_blacklist.bed&quot;</span>)</span><br><span class="line"><span class="comment">#汇总所有样本</span></span><br><span class="line"><span class="comment">#plotAnnoBar和plotDistToTSS这两个柱状图都支持多个数据同时展示</span></span><br><span class="line">peakAnnoList &lt;- lapply(files, annotatePeak, </span><br><span class="line">                       TxDb=txdb,</span><br><span class="line">                       tssRegion=<span class="built_in">c</span>(-<span class="number">3000</span>, <span class="number">3000</span>))</span><br><span class="line">plotAnnoBar(peakAnnoList,title = <span class="string">&quot;                        Feature Distribution&quot;</span>)</span><br><span class="line">plotDistToTSS(peakAnnoList,title = <span class="string">&quot;                 Feature Distribution relative to TSS&quot;</span>)</span><br><span class="line"><span class="comment">#例举单个样本</span></span><br><span class="line">peakAnno &lt;- annotatePeak(files[[<span class="number">1</span>]],<span class="comment"># 分别改成2或者3或者4即可，分别对应四个文件</span></span><br><span class="line">                        tssRegion=<span class="built_in">c</span>(-<span class="number">3000</span>, <span class="number">3000</span>),</span><br><span class="line">                        TxDb=txdb,</span><br><span class="line">                        annoDb=<span class="string">&quot;org.Mm.eg.db&quot;</span>)</span><br><span class="line">plotAnnoPie(peakAnnoLipeakAnnost)</span><br><span class="line">upsetplot(peakAnno, vennpie=<span class="literal">TRUE</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/Feature Distribution.jpeg" width="50%"><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/Feature Distribution TSS.jpeg" width="50%"></p>
<p><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/plotAnnoPie.jpeg" width="50%"><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/upsetplot(peakAnno, vennpie=TRUE).jpeg" width="50%"></p>
<h3 id="2、查看peaks在全基因组上的分布"><a href="#2、查看peaks在全基因组上的分布" class="headerlink" title="2、查看peaks在全基因组上的分布"></a>2、查看peaks在全基因组上的分布</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#输入文件的准备</span></span><br><span class="line">DMSO_24h_wt_rep1&lt;-read.csv(<span class="string">&quot;SRR12692092_summits_filt_blacklist.csv&quot;</span>)</span><br><span class="line">DMSO_24h_wt_rep1&lt;-DMSO_24h_wt_rep1[,-<span class="number">4</span>]</span><br><span class="line">DMSO_24h_wt_rep2&lt;-read.csv(<span class="string">&quot;SRR12692093_summits_filt_blacklist.csv&quot;</span>)</span><br><span class="line">DMSO_24h_wt_rep2&lt;-DMSO_24h_wt_rep2[,-<span class="number">4</span>]</span><br><span class="line">BRM014_10uM_24h_wt_rep1&lt;-read.csv(<span class="string">&quot;SRR12692098_summits_filt_blacklist.csv&quot;</span>)</span><br><span class="line">BRM014_10uM_24h_wt_rep1&lt;-BRM014_10uM_24h_wt_rep1[,-<span class="number">4</span>]</span><br><span class="line">BRM014_10uM_24h_wt_rep2&lt;-read.csv(<span class="string">&quot;SRR12692099_summits_filt_blacklist.csv&quot;</span>)</span><br><span class="line">BRM014_10uM_24h_wt_rep2&lt;-BRM014_10uM_24h_wt_rep2[,-<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#以DMSO_24h_wt_rep1为例</span></span><br><span class="line">set.seed(<span class="number">123</span>)</span><br><span class="line">circos.initializeWithIdeogram(plotType = <span class="built_in">c</span>(<span class="string">&quot;axis&quot;</span>, <span class="string">&quot;labels&quot;</span>))</span><br><span class="line">circos.track(ylim = <span class="built_in">c</span>(<span class="number">0</span>, <span class="number">1</span>), panel.fun = <span class="keyword">function</span>(x, y) &#123;</span><br><span class="line">  chr = CELL_META$sector.index</span><br><span class="line">  xlim = CELL_META$xlim</span><br><span class="line">  ylim = CELL_META$ylim</span><br><span class="line">  circos.rect(xlim[<span class="number">1</span>], <span class="number">0</span>, xlim[<span class="number">2</span>], <span class="number">1</span>)</span><br><span class="line">&#125;, track.height = <span class="number">0.15</span>, bg.border = <span class="literal">NA</span>, bg.col=rainbow(<span class="number">24</span>))</span><br><span class="line">text(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;DMSO_24h_wt_rep1&quot;</span>, cex = <span class="number">1.5</span>)</span><br><span class="line">circos.genomicDensity(DMSO_24h_wt_rep1, col = <span class="built_in">c</span>(<span class="string">&quot;#000080&quot;</span>), track.height = <span class="number">0.2</span>)</span><br><span class="line">circos.clear()</span><br></pre></td></tr></table></figure>
<p>看到这样的结果，第一反应就是————为什么两种处理情况下染色体开放程度那么像！？难道我代码有问题！？经过反复检查验证（将一个样本chr1上的peaks都删掉，再次运行上述代码，就会发现显著的改变），可以确定分析上是没有问题的。这两种处理导致的差异可能不是很显著。再加上20万+的peaks放在这个小小的circos图上展示，有些差异会被掩盖掉。就如在做TSS富集分析的时候，单独看TSS前后3Kb区域，可以看到有两个峰，但在看TSS-genebody-TSE区域是，TSS处相对微弱的那个峰就被掩盖掉了。</p>
<p><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/DMSO_24h_wt_rep1.jpeg" width="50%"><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/DMSO_24h_wt_rep2.jpeg" width="50%"><br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/BRM014_10uM_24h_wt_rep1.jpeg" width="50%"><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/BRM014_10uM_24h_wt_rep2.jpeg" width="50%"></p>
<h3 id="3、拿到每个样本中peaks对应得基因名"><a href="#3、拿到每个样本中peaks对应得基因名" class="headerlink" title="3、拿到每个样本中peaks对应得基因名"></a>3、拿到每个样本中peaks对应得基因名</h3><p>这一步非常重要，拿到基因名就可以根据课题需要进行差异分析等</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#以DMSO_24h_wt样本为例</span></span><br><span class="line"><span class="comment">#replicate 1</span></span><br><span class="line">peakAnno_DMSO_24h_wt_rep1 &lt;- annotatePeak(files[[<span class="number">1</span>]],</span><br><span class="line">                                          tssRegion=<span class="built_in">c</span>(-<span class="number">3000</span>, <span class="number">3000</span>),</span><br><span class="line">                                          TxDb=txdb,</span><br><span class="line">                                          annoDb=<span class="string">&quot;org.Mm.eg.db&quot;</span>)</span><br><span class="line">genelist_DMSO_24h_wt_rep1_uniqe&lt;-as.data.frame(unique(peakAnno_DMSO_24h_wt_rep1@anno@elementMetadata@listData[[<span class="string">&quot;SYMBOL&quot;</span>]]))</span><br><span class="line">colnames(genelist_DMSO_24h_wt_rep1_uniqe)&lt;-<span class="string">&quot;symbol&quot;</span></span><br><span class="line"><span class="comment">#replicate 2</span></span><br><span class="line">peakAnno_DMSO_24h_wt_rep2 &lt;- annotatePeak(files[[<span class="number">2</span>]],</span><br><span class="line">                                          tssRegion=<span class="built_in">c</span>(-<span class="number">3000</span>, <span class="number">3000</span>),</span><br><span class="line">                                          TxDb=txdb,</span><br><span class="line">                                          annoDb=<span class="string">&quot;org.Mm.eg.db&quot;</span>)</span><br><span class="line">genelist_DMSO_24h_wt_rep2_uniqe&lt;-as.data.frame(unique(peakAnno_DMSO_24h_wt_rep2@anno@elementMetadata@listData[[<span class="string">&quot;SYMBOL&quot;</span>]]))</span><br><span class="line">colnames(genelist_DMSO_24h_wt_rep2_uniqe)&lt;-<span class="string">&quot;symbol&quot;</span></span><br><span class="line"><span class="comment">#重复样本间共同的开放基因</span></span><br><span class="line">venn.diagram(</span><br><span class="line">  x=<span class="built_in">list</span>(</span><br><span class="line">    DMSO_24h_wt_rep1=genelist_DMSO_24h_wt_rep1_uniqe$symbol,</span><br><span class="line">    DMSO_24h_wt_rep2=genelist_DMSO_24h_wt_rep2_uniqe$symbol</span><br><span class="line">  ),</span><br><span class="line">  filename = <span class="string">&quot;DMSO_24h_wt.png&quot;</span>,</span><br><span class="line">  lty=<span class="string">&quot;dotted&quot;</span>,</span><br><span class="line">  lwd=<span class="number">3</span>,</span><br><span class="line">  col=<span class="string">&quot;transparent&quot;</span>,</span><br><span class="line">  fill=<span class="built_in">c</span>(<span class="string">&quot;darkorchid1&quot;</span>,<span class="string">&quot;cornflowerblue&quot;</span>),</span><br><span class="line">  alpha=<span class="number">0.5</span>,</span><br><span class="line">  </span><br><span class="line">  label.col=<span class="built_in">c</span>(<span class="string">&quot;darkorchid1&quot;</span>,<span class="string">&quot;white&quot;</span>,<span class="string">&quot;darkblue&quot;</span>) ,</span><br><span class="line">  cex=<span class="number">1</span>,</span><br><span class="line">  fontfamily=<span class="string">&quot;serif&quot;</span>,</span><br><span class="line">  fontface=<span class="string">&quot;bold&quot;</span>,</span><br><span class="line">  cat.default.pos=<span class="string">&quot;text&quot;</span>,</span><br><span class="line">  cat.col=<span class="built_in">c</span>(<span class="string">&quot;darkorchid1&quot;</span>,<span class="string">&quot;darkblue&quot;</span>),</span><br><span class="line">  cat.cex=<span class="number">0.6</span>,</span><br><span class="line">  cat.fontfamily=<span class="string">&quot;serif&quot;</span>,</span><br><span class="line">  cat.dist=<span class="built_in">c</span>(<span class="number">0.3</span>,<span class="number">0.3</span>),</span><br><span class="line">  cat.pos=<span class="number">0</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看各组内样本间的overlapping reads：DMSO_24h_wt， BRM014_10uM_24h_wt；</span></span><br><span class="line"><span class="comment">#以及组间peaks的异同情况：DMSO_24h_wt vs. BRM014_10uM_24h_wt</span></span><br><span class="line"><span class="comment">#代码类似上面的，就不一一展示了</span></span><br></pre></td></tr></table></figure>
<p>从下图可以看出，不管是组间还是组内，差异的peaks数目都不是很多了，这一点也验证了我们上面做的再全基因组范围内查看peaks的分布结果。</p>
<p><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/DMSO_24h_wt.png" width="50%"><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/BRM014_10uM_24h_wt.png" width="50%"><br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/DMSO_BRM014.png" width="50%"></p>
]]></content>
      <tags>
        <tag>NGS</tag>
      </tags>
  </entry>
  <entry>
    <title>scRNA-seq数据分析流程</title>
    <url>/2020/02/07/scRNA-seq/</url>
    <content><![CDATA[<p>···</p>
<a id="more"></a>

<h1 id="scRNA-seq数据分析流程"><a href="#scRNA-seq数据分析流程" class="headerlink" title="scRNA-seq数据分析流程"></a>scRNA-seq数据分析流程</h1><p>以下分析流程以GSE111229数据为例(为什么用它呢，因为它数据量小呀，嘿嘿🤭)在进行分析之前，首先了解一下该套数据的基本情况。<br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/GSE111229information.JPG" width="30%" height="30%"><br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/GSE111229datasize.JPG"/>  </p>
<p>由此可基本了解，此数据为<font color=red>单端测序</font>数据，物种为<font color=red>小鼠</font>。768个样本即768个单细胞测序数据，总大小才10G。这在单细胞测序数据中真的是<strong>非常小</strong>！<strong>非常罕见</strong>啦！</p>
<h2 id="😄数据分析上游-Linux-😄"><a href="#😄数据分析上游-Linux-😄" class="headerlink" title="😄数据分析上游(Linux)😄"></a>😄数据分析上游(Linux)😄</h2><p>因为是单细胞<strong>转录组</strong>测序数据，和转录组测序的上游分析没什么区别。所以以下分析流程都是在conda构建的rna环境下进行，这个环境也是很久之前搭建好的，在此不再赘述。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda activat rna</span><br></pre></td></tr></table></figure>

<p>运行上述代码后，可以看到提示符(prompt)左边多了一个<u>(rna)</u>环境，此环境里面，预先装好了处理RNA-seq数据所需要的相关软件。<br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/environment.JPG"/></p>
<h3 id="数据下载"><a href="#数据下载" class="headerlink" title="数据下载"></a>数据下载</h3><blockquote>
<p><strong>如果样本量不多，网速又不理想</strong>，推荐<a href="https://www.ebi.ac.uk/">EBI-ENA</a>数据库，此数据库下载网速还可以，另外该数据库除了提供SRA文件外，还提供FASTQ文件，省去了从NCBI下载SRA文件转为FASTQ文件的麻烦(如何单个文件数据量大，此格式转换步骤非常耗时)。<br><strong>如果样本量特别多，网速又比较理想</strong>，推荐使用Aspera、prfetch、wget、curl。前两者大大优于后两者。Aspera Connect的下载速度是最快了，此方法也可以下载FASTQ和SRA文件，免去了SRA转至FASTQ的过程，该过程很耗时，十分耗时。 </p>
</blockquote>
<h4 id="进入EBI官网，输入SRP号"><a href="#进入EBI官网，输入SRP号" class="headerlink" title="进入EBI官网，输入SRP号"></a>进入EBI官网，输入SRP号</h4><p><em>1</em><br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/EBI.JPG"/><br><em>2</em><br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/EBI2.JPG"/><br><em>3</em><br>以其中一个样本SRR6791132为例，点击SRR6791132进入下载界面，鼠标右键红色箭头处——“复制链接地址”<br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/EBI3.JPG"/></p>
<h4 id="进入linux进行数据下载"><a href="#进入linux进行数据下载" class="headerlink" title="进入linux进行数据下载"></a>进入linux进行数据下载</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p scRNA-seq/fastq &amp;&amp; <span class="built_in">cd</span> scRNA-seq/fastq  </span><br><span class="line">wget ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR679/002/SRR6791132/SRR6791132.fastq.gz    </span><br><span class="line">wget ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR679/005/SRR6791135/SRR6791135.fastq.gz  </span><br><span class="line">wget ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR679/005/SRR6791135/SRR6791135.fastq.gz</span><br><span class="line">```  </span><br><span class="line">&lt;font color=blue&gt;注意注意，特别注意，要下载整套数据最好使用Aspera或者prefetch，本宝宝没有办法呀，网不好，空间也不大，linux中的数据操作只能用三个样本做演示了，熟悉一下分析流程。如果是整套数据，记得写小循环，放后台，就不用一直守着它了，最好是睡觉的时候跑，不耽误事。&lt;/font&gt;    </span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"><span class="comment">### 质控  </span></span><br><span class="line">```bash   </span><br><span class="line"><span class="comment">#首先查看数据质量情况，进行如下操作 </span></span><br><span class="line">mkdir -p /scRNA-seq/html &amp;&amp; <span class="built_in">cd</span> /scRNA-seq/html</span><br><span class="line">ls /scRNA-seq/fastq/*gz|xargs fastqc -t 4 -o ./</span><br><span class="line">```   </span><br><span class="line">上述操作会得到html文件和zip文件  </span><br><span class="line">&lt;img src=<span class="string">&quot;https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/quality.JPG&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">网页打开其中一个html文件可查看测序数据的质量，该数据整体质量还不错（[质控报告解读教程](https://www.jianshu.com/p/835fd925d6ee)） </span><br><span class="line"></span><br><span class="line">&lt;img src=<span class="string">&quot;https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/html.JPG&quot;</span> width=<span class="string">&quot;50%&quot;</span> height=<span class="string">&quot;50%&quot;</span>&gt;  </span><br><span class="line"></span><br><span class="line">大部分测序数据都会出现如下情况，不过这个问题不大  </span><br><span class="line">&lt;img src=<span class="string">&quot;https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/pbsc.JPG&quot;</span> width=<span class="string">&quot;50%&quot;</span> height=<span class="string">&quot;50%&quot;</span>&gt;  </span><br><span class="line">```bash  </span><br><span class="line"><span class="comment">#接下来过滤掉质量不好的数据，使trim_galore软件  </span></span><br><span class="line"><span class="comment">#mkdir /scRNA-seq/clean</span></span><br><span class="line"><span class="comment">#ls /scRNA-seq/fastq/*gz|while read id; do trim_galore -q 25 --phred33 --length 35 -e 0.1 --stringency 5 -o . $id;done  </span></span><br><span class="line"><span class="comment">#在此会发现过滤后的数据质量反而没有过滤前的质量好，有时候数据分析就是会这样，过滤参数很难调整。。。所以在此后续步骤使用未过滤的数据进行处理。  </span></span><br></pre></td></tr></table></figure>
<h3 id="比对"><a href="#比对" class="headerlink" title="比对"></a>比对</h3><p>1、小鼠参考基因组<br>首先下载<font color=red>小鼠参考基因组</font>，hisat2或者bowtie2构建<font color=red>小鼠参考基因组索引</font>。也可以直接下载参考基因组索引文件。另外还需要下载<font color=red>小鼠参考基因组注释文件</font>。(此步骤很早前处理RNA-seq数据时就已经完成了，就不再赘述)<br><em>hisat2构建的mm10参考基因组索引文件</em><br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/hisat2mm10.JPG"/><br><em>mm10注释文件</em><br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/mm10注释.JPG"/>   </p>
<p>2、进行参考基因组比对</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#同参考基因组索引进行比对，生成bam文件。参考基因组索引一定是引用前缀&quot;genome&quot;。另外注意，此处数据为单端测序数据！</span></span><br><span class="line">ls *.gz | <span class="keyword">while</span> <span class="built_in">read</span> id; <span class="keyword">do</span> hisat2 -p 4 -x /addfirst/reference/mouse/index/hisat2-build-index/mm10/genome -U <span class="variable">$id</span> -S <span class="variable">$&#123;id%%.*&#125;</span>.hisat2.sam;<span class="keyword">done</span>   </span><br><span class="line">mkdir /scRNA-seq/align &amp;&amp; <span class="built_in">cd</span> /scRNA-seq/align   </span><br><span class="line">cp /scRNA-seq/fastq/*.sam /scRNA-seq/fastq/*.bam ./  </span><br><span class="line"><span class="comment">#使用samtools软件将sam文件转成bam文件  </span></span><br><span class="line">ls *.sam | <span class="keyword">while</span> <span class="built_in">read</span> id; <span class="keyword">do</span> samtools sort -O bam -@ 4 -o <span class="variable">$&#123;id%%.*&#125;</span>.hisat2.bam <span class="variable">$id</span>; <span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>比对结果如下：82.25%的比对率，比较的凑合了，一般情况最好90%以上，后两个数据的比对率实在不能看。真实处理环境一定要<strong>仔细调节过滤参数！！！</strong><br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/ALIGN.JPG"/></p>
<p>可以比较一下bam、fasatq、sam文件的大小。<br>sam文件远远大于bam和fastq文件。生信分析上游一定要对文件大小保持高度敏感，避免不必要的错误。另外，数据量大的话，可以在生成sam文件时通过<code>|</code>将结果进一步生成bam文件，这样可以大大节省存储空间。<br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/bamsamfastq.JPG"/>   </p>
<h3 id="构建index文件"><a href="#构建index文件" class="headerlink" title="构建index文件"></a>构建index文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls *.bam | xargs -i samtools index &#123;&#125;</span><br><span class="line">```  </span><br><span class="line">&lt;img src=<span class="string">&quot;https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/bamindex.JPG&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">### 生成reads表达矩阵  </span></span><br><span class="line">```bash </span><br><span class="line">gtf=/addfirst/reference/mouse/gencode.vM23.annotation.gtf   </span><br><span class="line">featureCounts -T 4 -p -t exon -g gene_id -a <span class="variable">$gtf</span> -o all.id.txt *.bam 1&gt;counts.id.log 2&gt;&amp;1   </span><br><span class="line">查看counts矩阵  </span><br><span class="line">less -S all.id.txt</span><br><span class="line">```   </span><br><span class="line"> &lt;img src=<span class="string">&quot;https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/reads.JPG&quot;</span>/&gt;    </span><br><span class="line"> 查看counts矩阵会发现绝大多数基因表达量都是0，因为对于大多数细胞来说，大多数基因都是测不到的，这个属于正常现象。在此，我们只用了3个样本做演示，总数据则有768个样本。  </span><br><span class="line"> &lt;img src=<span class="string">&quot;https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/countsmatrix.JPG&quot;</span>/&gt;    </span><br><span class="line"> 理论上按照上面的分析流程生成的表达矩阵数据和下图中NCBI官网上的rawCounts.txt.gz的内容应该是差不多的，只是所用处理软件不同会有一点点区别。  </span><br><span class="line"> &lt;img src=<span class="string">&quot;https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/NCBImatrix.JPG&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">至此，scRNA-seq上游分析结束，这里比较重要的是**数据质量**，数据质量直接决定比对的效率，影响最终生成的表达矩阵的可靠性。所以质控步骤要严格把控，送样测序也要选靠谱的公司。   </span><br><span class="line"></span><br><span class="line"><span class="comment">## 😄数据分析下游(R)😄   </span></span><br><span class="line"><span class="comment">### 数据(data.frame)的构建</span></span><br><span class="line">如果是使用rawCounts数据进行下游分析，首先要对数据进行标准化，然后再做后续分析。该篇文章是使用rpkm的数据进行下游分析，这里也直接使用rpkm的数据进行下游分析。   </span><br><span class="line">```R   </span><br><span class="line">a=read.table(<span class="string">&#x27;../GSE111229_Mammary_Tumor_fibroblasts_768samples_rpkmNormalized.txt.gz&#x27;</span>,header = T ,sep = <span class="string">&#x27;\t&#x27;</span>)  <span class="comment">##把表达矩阵文件载入R，header=T :保留文件头部信息，seq=&#x27;\t&#x27;以tap为分隔符</span></span><br><span class="line"><span class="comment"># 记得检测数据</span></span><br><span class="line">a[1:6,1:4] <span class="comment">#对于a矩阵取第1~6行，第1~4列</span></span><br><span class="line"><span class="comment">## 读取RNA-seq的counts定量结果，表达矩阵需要进行简单的过滤</span></span><br><span class="line">dat=a[apply(a,1, <span class="keyword">function</span>(x) sum(x&gt;0) &gt; floor(ncol(a)/50)),]   </span><br><span class="line"><span class="comment">#筛选表达量合格的行,列数不变   </span></span><br><span class="line"><span class="comment">#上面的apply()指令代表对矩阵a进行行计算，判断每行表达量&gt;1的样本总个数，并筛选出细胞表达量合格的基因（行）</span></span><br><span class="line"><span class="comment">#第一个参数是指要参与计算的矩阵——a</span></span><br><span class="line"><span class="comment">#第二个参数是指按行计算还是按列计算，1——表示按行计算，2——按列计算；</span></span><br><span class="line"><span class="comment">#第三个参数是指具体的运算参数,定义一个函数x（即表达量为x）</span></span><br><span class="line">dat[1:4,1:4]      </span><br><span class="line">```   </span><br><span class="line">&lt;img src=<span class="string">&quot;https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/a.JPG&quot;</span>/&gt;  </span><br><span class="line">&lt;img src=<span class="string">&quot;https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/dat.JPG&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">```R  </span><br><span class="line"><span class="comment">#层次聚类</span></span><br><span class="line">hc=hclust(dist(t(<span class="built_in">log</span>(dat+0.1)))) <span class="comment">##样本间层次聚类</span></span><br><span class="line"><span class="comment"># 如果是基因聚类，可以选择 wgcna 等算法  </span></span><br><span class="line">plot(hc,labels = F) <span class="comment">##此图可以看出678个样本大致可以分为几类，在此大致可分为4类   </span></span><br><span class="line">clus = cutree(hc, 4) <span class="comment">#对hclust()函数的聚类结果进行剪枝，即选择输出指定类别数的系谱聚类结果。</span></span><br><span class="line">group_list= as.factor(clus) <span class="comment">##转换为因子属性</span></span><br><span class="line">table(group_list) <span class="comment">##统计频数    </span></span><br><span class="line">```  </span><br><span class="line">&lt;img src=<span class="string">&quot;https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/hclust.JPG&quot;</span> width=<span class="string">&quot;60%&quot;</span> height=<span class="string">&quot;60%&quot;</span>&gt;    </span><br><span class="line"></span><br><span class="line">&lt;img src=<span class="string">&quot;https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/grouplist.JPG&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">```R  </span><br><span class="line"><span class="comment">#提取批次信息</span></span><br><span class="line">colnames(dat) <span class="comment">#取列名</span></span><br><span class="line">library(stringr)</span><br><span class="line">plate=str_split(colnames(dat),<span class="string">&#x27;_&#x27;</span>,simplify = T)[,3] <span class="comment">#str_split()函数可以分割字符串。取列名，以&#x27;_&#x27;号分割，提取第三列。</span></span><br><span class="line">table(plate) <span class="comment">#以为这768个样本是放在两个384孔检测的，后续要检测测序数据是否存在批次效应，所以要预先提取批次信息 </span></span><br><span class="line">n_g = apply(a,2,<span class="keyword">function</span>(x) sum(x&gt;0)) <span class="comment">#统计每个样本有表达的基因有多少行</span></span><br><span class="line"><span class="comment">#reads数量大于1的那些基因为有表达，一般来说单细胞转录组过半数的基因是不会表达的。  </span></span><br><span class="line">df=data.frame(g=group_list,plate=plate,n_g=n_g) <span class="comment">#新建数据框(细胞的属性信息) </span></span><br><span class="line"><span class="comment">##(样本为行名，列分别为：样本分类信息，样本批次，样本表达的基因数——不是表达量的和，而是种类数或者说个数) </span></span><br><span class="line">df<span class="variable">$all</span>=<span class="string">&#x27;all&#x27;</span> <span class="comment">#添加列，列名为&quot;all&quot;，没事意思，就是后面有需要</span></span><br><span class="line">metadata=df  </span><br><span class="line">df[1:4,1:4]</span><br><span class="line">save(dat,metadata,file = <span class="string">&#x27;../input_rpkm.Rdata&#x27;</span>) <span class="comment">#保存a,dat,df这变量到上级目录的input.Rdata   </span></span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/df.JPG"/>    

<h3 id="检测是否存在批次效应"><a href="#检测是否存在批次效应" class="headerlink" title="检测是否存在批次效应"></a>检测是否存在批次效应</h3><p>因为该篇文章使用两块384孔进行测序，所以要先确定两块板是否存在批次效应，如果存在，则两块板的样本不能合并分析，如果不存在批次效应，则两块板可以进行批次分析。</p>
<p><strong>PCA主成份分析</strong>  </p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">rm(<span class="built_in">list</span> = ls())  <span class="comment">## 魔幻操作，一键清空~</span></span><br><span class="line">options(stringsAsFactors = <span class="built_in">F</span>)</span><br><span class="line">load(file = <span class="string">&#x27;../input_rpkm.Rdata&#x27;</span>)</span><br><span class="line">dat[<span class="number">1</span>:<span class="number">4</span>,<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">head(metadata) </span><br><span class="line">plate=metadata$plate</span><br><span class="line"><span class="comment">## 下面是画PCA的必须操作</span></span><br><span class="line">dat_back=dat</span><br><span class="line">dat=t(dat)  <span class="comment">#做PCA之前一定要进行数据转置</span></span><br><span class="line">dat=as.data.frame(dat)</span><br><span class="line">dat=cbind(dat,plate ) <span class="comment">#cbind根据列进行合并，即叠加所有列，矩阵添加批次信息</span></span><br><span class="line">dat[<span class="number">1</span>:<span class="number">4</span>,<span class="number">12688</span>:<span class="number">12690</span>]  <span class="comment">#检测是否添加上了批次信息</span></span><br><span class="line">table(dat$plate)</span><br><span class="line">library(<span class="string">&quot;FactoMineR&quot;</span>)</span><br><span class="line">library(<span class="string">&quot;factoextra&quot;</span>) </span><br><span class="line">dat.pca &lt;- PCA(dat[,-ncol(dat)], graph = <span class="literal">FALSE</span>)</span><br><span class="line">fviz_pca_ind(dat.pca,<span class="comment">#repel =T, geom.ind = &quot;point&quot;, </span></span><br><span class="line">             col.ind = dat$plate, <span class="comment"># color by groups</span></span><br><span class="line">             addEllipses = <span class="literal">FALSE</span>, <span class="comment"># Concentration ellipses</span></span><br><span class="line">             legend.title = <span class="string">&quot;Groups&quot;</span></span><br><span class="line">)   </span><br><span class="line">```   </span><br><span class="line">&lt;img src=&quot;https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/PCA.jpeg&quot; width=&quot;60%&quot; height=&quot;60%&quot;&gt;</span><br><span class="line">      </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**tSNE分析**  </span><br><span class="line">```R </span><br><span class="line">rm(<span class="built_in">list</span> = ls())  <span class="comment">## 魔幻操作，一键清空~</span></span><br><span class="line">options(stringsAsFactors = <span class="built_in">F</span>)   </span><br><span class="line">library(Rtsne) </span><br><span class="line">load(file = <span class="string">&#x27;../input_rpkm.Rdata&#x27;</span>)</span><br><span class="line">dat[<span class="number">1</span>:<span class="number">4</span>,<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">dat_matrix &lt;- t(dat)  </span><br><span class="line">dat_matrix=log2(dat_matrix+<span class="number">0.01</span>)</span><br><span class="line">set.seed(<span class="number">42</span>) <span class="comment"># 如果想得到可重复的结果，就种一颗种子吧😄</span></span><br><span class="line">tsne_out &lt;- Rtsne(dat_matrix,pca=<span class="literal">FALSE</span>,perplexity=<span class="number">30</span>,theta=<span class="number">0.0</span>)   </span><br><span class="line"><span class="comment">##添加颜色</span></span><br><span class="line">tsnes=tsne_out$Y</span><br><span class="line">tsnes=as.data.frame(tsnes)</span><br><span class="line">group=<span class="built_in">c</span>(<span class="built_in">rep</span>(<span class="string">&#x27;plate1&#x27;</span>,<span class="number">384</span>),<span class="built_in">rep</span>(<span class="string">&#x27;plate2&#x27;</span>,<span class="number">384</span>))</span><br><span class="line">colnames(tsnes)&lt;-<span class="built_in">c</span>(<span class="string">&quot;tSNE1&quot;</span>,<span class="string">&quot;tSNE2&quot;</span>)  </span><br><span class="line">library(ggfortify)</span><br><span class="line">ggplot(tsnes, aes(x = tSNE1, y = tSNE2))+ geom_point(aes(col=group))+ theme_classic()</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/tSNE.jpeg" width="60%" height="60%">

<h3 id="细胞亚群"><a href="#细胞亚群" class="headerlink" title="细胞亚群"></a>细胞亚群</h3><pre><code class="R">#########################
##针对所有细胞做PCA分析##  
#########################
rm(list = ls())  ## 魔幻操作，一键清空
options(stringsAsFactors = F)
load(file = &#39;../input_rpkm.Rdata&#39;)
dat[1:4,1:4]
head(metadata) 
group&lt;-metadata$g
#做好数据备份
dat_back=dat
dat=t(dat) #记得转置数据
dat=as.data.frame(dat)
dat=cbind(dat,group ) #cbind根据列进行合并，即叠加所有列，为矩阵添加分组信息
dat[1:4,12688:12690]
table(dat$group)
library(&quot;FactoMineR&quot;)
library(&quot;factoextra&quot;) 
dat.pca &lt;- PCA(dat[,-ncol(dat)], graph = FALSE)
fviz_pca_ind(dat.pca,#repel =T,
             geom.ind = &quot;point&quot;, # show points only (nbut not &quot;text&quot;)
             col.ind = dat$group, # color by groups
             addEllipses = FALSE, # Concentration ellipses
             legend.title = &quot;Groups&quot;  
             )   

#########################
##针对所有细胞做tSNE分析##  
#########################
rm(list = ls())  ## 魔幻操作，一键清空~
options(stringsAsFactors = F)
library(Rtsne) 
load(file = &#39;../input_rpkm.Rdata&#39;)
dat[1:4,1:4]
dat_matrix &lt;- t(dat)
dat_matrix=log2(dat_matrix+0.01)
# Set a seed if you want reproducible results
set.seed(42)
tsne_out &lt;- Rtsne(dat_matrix,pca=FALSE,perplexity=30,theta=0.0) 
group=metadata$g
##添加颜色
tsnes=tsne_out$Y
tsnes=as.data.frame(tsnes)
colnames(tsnes)&lt;-c(&quot;tSNE1&quot;,&quot;tSNE2&quot;)
ggplot(tsnes, aes(x = tSNE1, y = tSNE2))+ geom_point(aes(col=group))+ theme_classic()
</code></pre>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/wholePCA.jpeg" width="60%" height="60%">  
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/wholetSNE.jpeg" width="60%" height="60%">   

<p>单细胞测序分析旨在分出不同细胞亚群(展现细胞间的异质性)，力求寻找某类亚群与某特定生物学功能之间的联系。而要探讨细胞分群，就必须要知道PCA和tSNE。<br><strong>PCA(Principal Component Analysis)</strong><br><strong>tSNE(t-Distributed Stochastic Neighbor Embedding)</strong><br>什么样的算法才是最理想的能够将细胞分群的算法呢？<br>1）局部结构：属于同一个亚群的细胞，聚类尽可能近<br>2）全局结构：属于不同亚群的细胞，聚类尽可能分来   </p>
<ul>
<li>PCA的方法侧重于去抓样本中隐含的主要效应，从而让差异大的样本在图上呈现较远的距离。常规RNA-seq项目中，处理效应、批次效应、离群效应等属于较大的效应，PCA的方法可以良好的去展示这些效应。   </li>
<li>如果影响样本分组的不是主要效应，而是一些更小的效应，PCA则无法对样本进行准确的区分。scRNA-seq的可视化主要期望对各个细胞亚群有良好的区分。每次检测的上万甚至几十万个细胞中，几乎肯定可以区分出几十中细胞亚群，包括一些稀有的细胞。而区分这些细胞亚群（尤其是稀有细胞类型）的效应，往往不是主要效应（即大量基因的差异），而是一些微小效应（少量标记基因差异）。如果使用PCA进行分析的话，就会掩盖掉某些微小的但是有可能非常重要的细胞群。   </li>
<li>tSNE算法就属于可以同时兼顾局部结构和全局结构的非线性降维可视化算法。tSNE不同于PCA（PCA主要目标是尽量去抓取群体中的主要效益），tSNE算法的主要目标是：降维后的数据依然保持最为相似的紧密成簇。这就保证了哪怕某些稀有细胞只是少量基因区别于其他细胞亚群，在tSNE中依然可以与其他细胞有良好的区分。<font color=blue>结论：PCA是常规转录组常用的数据降维和样本关系可视化的方法，但针对群体单细胞转录组数据，tSNE是明显胜过PCA的方法！</font>   </li>
</ul>
<p>参考资料<br><a href="http://www.sohu.com/a/320164491_278730">http://www.sohu.com/a/320164491_278730</a></p>
]]></content>
      <tags>
        <tag>NGS</tag>
      </tags>
  </entry>
  <entry>
    <title>scRNA-seq数据分析实战（一）</title>
    <url>/2020/02/08/scRNA-seq%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>single cell RNA-seq  &amp;&amp; SMART-seq2<br>上游分析：Linux<br>下游分析：用转录组思想初步了解探究单细胞转录组数据（注意：处理单细胞转录组和转录组是有很大区别的，完全将转录组思想应用于单细胞转录组数据分析是万万不可取的！！！）</p>
<a id="more"></a>

<h1 id="scRNA-seq数据分析流程"><a href="#scRNA-seq数据分析流程" class="headerlink" title="scRNA-seq数据分析流程"></a>scRNA-seq数据分析流程</h1><p>以下分析流程以GSE111229数据为例(为什么用它呢，因为它数据量小呀，嘿嘿🤭)在进行分析之前，首先了解一下该套数据的基本情况。<br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/GSE111229information.JPG" width="30%" height="30%"><br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/GSE111229datasize.JPG"/>  </p>
<p>由此可基本了解，此数据为<font color=red>单端测序</font>数据，物种为<font color=red>小鼠</font>。768个样本即768个单细胞测序数据，总大小才10G。这在单细胞测序数据中真的是<strong>非常小</strong>！<strong>非常罕见</strong>啦！</p>
<h2 id="😄数据分析上游-Linux-😄"><a href="#😄数据分析上游-Linux-😄" class="headerlink" title="😄数据分析上游(Linux)😄"></a>😄数据分析上游(Linux)😄</h2><p>因为是单细胞<strong>转录组</strong>测序数据，和转录组测序的上游分析没什么区别。所以以下分析流程都是在conda构建的rna环境下进行，这个环境也是很久之前搭建好的，在此不再赘述。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda activat rna</span><br></pre></td></tr></table></figure>
<p>运行上述代码后，可以看到提示符(prompt)左边多了一个<u>(rna)</u>环境，此环境里面，预先装好了处理RNA-seq数据所需要的相关软件。<br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/environment.JPG"/></p>
<h3 id="数据下载"><a href="#数据下载" class="headerlink" title="数据下载"></a>数据下载</h3><blockquote>
<p><strong>如果样本量不多，网速又不理想</strong>，推荐<a href="https://www.ebi.ac.uk/">EBI-ENA</a>数据库，此数据库下载网速还可以，另外该数据库除了提供SRA文件外，还提供FASTQ文件，省去了从NCBI下载SRA文件转为FASTQ文件的麻烦(如何单个文件数据量大，此格式转换步骤非常耗时)。<br><strong>如果样本量特别多，网速又比较理想</strong>，推荐使用Aspera、prfetch、wget、curl。前两者大大优于后两者。Aspera Connect的下载速度是最快了，此方法也可以下载FASTQ和SRA文件，免去了SRA转至FASTQ的过程，该过程很耗时，十分耗时。 </p>
</blockquote>
<h4 id="进入EBI官网，输入SRP号"><a href="#进入EBI官网，输入SRP号" class="headerlink" title="进入EBI官网，输入SRP号"></a>进入EBI官网，输入SRP号</h4><p><em>1</em><br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/EBI.JPG"/><br><em>2</em><br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/EBI2.JPG"/><br><em>3</em><br>以其中一个样本SRR6791132为例，点击SRR6791132进入下载界面，鼠标右键红色箭头处——“复制链接地址”<br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/EBI3.JPG"/></p>
<h4 id="进入linux进行数据下载"><a href="#进入linux进行数据下载" class="headerlink" title="进入linux进行数据下载"></a>进入linux进行数据下载</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p scRNA-seq/fastq &amp;&amp; <span class="built_in">cd</span> scRNA-seq/fastq  </span><br><span class="line">wget ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR679/002/SRR6791132/SRR6791132.fastq.gz    </span><br><span class="line">wget ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR679/005/SRR6791135/SRR6791135.fastq.gz  </span><br><span class="line">wget ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR679/005/SRR6791135/SRR6791135.fastq.gz</span><br></pre></td></tr></table></figure>
<p><font color=blue>注意注意，特别注意，要下载整套数据最好使用Aspera或者prefetch，本宝宝没有办法呀，网不好，空间也不大，linux中的数据操作只能用三个样本做演示了，熟悉一下分析流程。如果是整套数据，记得写小循环，放后台，就不用一直守着它了，最好是睡觉的时候跑，不耽误事。</font>    </p>
<h3 id="质控"><a href="#质控" class="headerlink" title="质控"></a>质控</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#首先查看数据质量情况，进行如下操作 </span></span><br><span class="line">mkdir -p /scRNA-seq/html &amp;&amp; <span class="built_in">cd</span> /scRNA-seq/html</span><br><span class="line">ls /scRNA-seq/fastq/*gz|xargs fastqc -t 4 -o ./</span><br></pre></td></tr></table></figure>
<p>上述操作会得到html文件和zip文件<br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/quality.JPG"/></p>
<p>网页打开其中一个html文件可查看测序数据的质量，该数据整体质量还不错（<a href="https://www.jianshu.com/p/835fd925d6ee">质控报告解读教程</a>） </p>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/html.JPG" width="50%" height="50%">  

<p>大部分测序数据都会出现如下情况，不过这个问题不大<br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/pbsc.JPG" width="50%" height="50%"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#接下来过滤掉质量不好的数据，使trim_galore软件  </span></span><br><span class="line"><span class="comment">#mkdir /scRNA-seq/clean</span></span><br><span class="line"><span class="comment">#ls /scRNA-seq/fastq/*gz|while read id; do trim_galore -q 25 --phred33 --length 35 -e 0.1 --stringency 5 -o . $id;done  </span></span><br><span class="line"><span class="comment">#在此会发现过滤后的数据质量反而没有过滤前的质量好，有时候数据分析就是会这样，过滤参数很难调整。。。所以在此后续步骤使用未过滤的数据进行处理。  </span></span><br></pre></td></tr></table></figure>
<h3 id="比对"><a href="#比对" class="headerlink" title="比对"></a>比对</h3><p>1、小鼠参考基因组<br>首先下载<font color=red>小鼠参考基因组</font>，hisat2或者bowtie2构建<font color=red>小鼠参考基因组索引</font>。也可以直接下载参考基因组索引文件。另外还需要下载<font color=red>小鼠参考基因组注释文件</font>。(此步骤很早前处理RNA-seq数据时就已经完成了，就不再赘述)<br><em>hisat2构建的mm10参考基因组索引文件</em><br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/hisat2mm10.JPG"/><br><em>mm10注释文件</em><br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/mm10注释.JPG"/>   </p>
<p>2、进行参考基因组比对</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#同参考基因组索引进行比对，生成bam文件。参考基因组索引一定是引用前缀&quot;genome&quot;。另外注意，此处数据为单端测序数据！</span></span><br><span class="line">ls *.gz | <span class="keyword">while</span> <span class="built_in">read</span> id; <span class="keyword">do</span> hisat2 -p 4 -x /addfirst/reference/mouse/index/hisat2-build-index/mm10/genome -U <span class="variable">$id</span> -S <span class="variable">$&#123;id%%.*&#125;</span>.hisat2.sam;<span class="keyword">done</span>   </span><br><span class="line">mkdir /scRNA-seq/align &amp;&amp; <span class="built_in">cd</span> /scRNA-seq/align   </span><br><span class="line">cp /scRNA-seq/fastq/*.sam /scRNA-seq/fastq/*.bam ./  </span><br><span class="line"><span class="comment">#使用samtools软件将sam文件转成bam文件  </span></span><br><span class="line">ls *.sam | <span class="keyword">while</span> <span class="built_in">read</span> id; <span class="keyword">do</span> samtools sort -O bam -@ 4 -o <span class="variable">$&#123;id%%.*&#125;</span>.hisat2.bam <span class="variable">$id</span>; <span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>比对结果如下：82.25%的比对率，比较的凑合了，一般情况最好90%以上，后两个数据的比对率实在不能看。真实处理环境一定要<strong>仔细调节过滤参数！！！</strong><br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/ALIGN.JPG"/></p>
<p>可以比较一下bam、fasatq、sam文件的大小。<br>sam文件远远大于bam和fastq文件。生信分析上游一定要对文件大小保持高度敏感，避免不必要的错误。另外，数据量大的话，可以在生成sam文件时通过<code>|</code>将结果进一步生成bam文件，这样可以大大节省存储空间。<br><img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/bamsamfastq.JPG"/>   </p>
<h3 id="构建index文件"><a href="#构建index文件" class="headerlink" title="构建index文件"></a>构建index文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls *.bam | xargs -i samtools index &#123;&#125;</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/bamindex.JPG"/>

<h3 id="生成reads表达矩阵"><a href="#生成reads表达矩阵" class="headerlink" title="生成reads表达矩阵"></a>生成reads表达矩阵</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gtf=/addfirst/reference/mouse/gencode.vM23.annotation.gtf   </span><br><span class="line">featureCounts -T 4 -p -t exon -g gene_id -a <span class="variable">$gtf</span> -o all.id.txt *.bam 1&gt;counts.id.log 2&gt;&amp;1   </span><br><span class="line">查看counts矩阵  </span><br><span class="line">less -S all.id.txt</span><br></pre></td></tr></table></figure>
 <img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/reads.JPG"/>    
 查看counts矩阵会发现绝大多数基因表达量都是0，因为对于大多数细胞来说，大多数基因都是测不到的，这个属于正常现象。在此，我们只用了3个样本做演示，总数据则有768个样本。  
 <img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/countsmatrix.JPG"/>    
 理论上按照上面的分析流程生成的表达矩阵数据和下图中NCBI官网上的rawCounts.txt.gz的内容应该是差不多的，只是所用处理软件不同会有一点点区别。  
 <img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/NCBImatrix.JPG"/>

<p>至此，scRNA-seq上游分析结束，这里比较重要的是<strong>数据质量</strong>，数据质量直接决定比对的效率，影响最终生成的表达矩阵的可靠性。所以质控步骤要严格把控，送样测序也要选靠谱的公司。   </p>
<h2 id="😄数据分析下游-R-😄"><a href="#😄数据分析下游-R-😄" class="headerlink" title="😄数据分析下游(R)😄"></a>😄数据分析下游(R)😄</h2><h3 id="数据-data-frame-的构建"><a href="#数据-data-frame-的构建" class="headerlink" title="数据(data.frame)的构建"></a>数据(data.frame)的构建</h3><p>如果是使用rawCounts数据进行下游分析，首先要对数据进行标准化，然后再做后续分析。该篇文章是使用rpkm的数据进行下游分析，这里也直接使用rpkm的数据进行下游分析。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">a=read.table(<span class="string">&#x27;../GSE111229_Mammary_Tumor_fibroblasts_768samples_rpkmNormalized.txt.gz&#x27;</span>,header = <span class="built_in">T</span> ,sep = <span class="string">&#x27;\t&#x27;</span>)  <span class="comment">##把表达矩阵文件载入R，header=T :保留文件头部信息，seq=&#x27;\t&#x27;以tap为分隔符</span></span><br><span class="line"><span class="comment"># 记得检测数据</span></span><br><span class="line">a[<span class="number">1</span>:<span class="number">6</span>,<span class="number">1</span>:<span class="number">4</span>] <span class="comment">#对于a矩阵取第1~6行，第1~4列</span></span><br><span class="line"><span class="comment">## 读取RNA-seq的counts定量结果，表达矩阵需要进行简单的过滤</span></span><br><span class="line">dat=a[apply(a,<span class="number">1</span>, <span class="keyword">function</span>(x) <span class="built_in">sum</span>(x&gt;<span class="number">0</span>) &gt; <span class="built_in">floor</span>(ncol(a)/<span class="number">50</span>)),]   </span><br><span class="line"><span class="comment">#筛选表达量合格的行,列数不变   </span></span><br><span class="line"><span class="comment">#上面的apply()指令代表对矩阵a进行行计算，判断每行表达量&gt;1的样本总个数，并筛选出细胞表达量合格的基因（行）</span></span><br><span class="line"><span class="comment">#第一个参数是指要参与计算的矩阵——a</span></span><br><span class="line"><span class="comment">#第二个参数是指按行计算还是按列计算，1——表示按行计算，2——按列计算；</span></span><br><span class="line"><span class="comment">#第三个参数是指具体的运算参数,定义一个函数x（即表达量为x）</span></span><br><span class="line">dat[<span class="number">1</span>:<span class="number">4</span>,<span class="number">1</span>:<span class="number">4</span>]      </span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/a.JPG"/>  
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/dat.JPG"/>

<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#层次聚类</span></span><br><span class="line">hc=hclust(dist(t(<span class="built_in">log</span>(dat+<span class="number">0.1</span>)))) <span class="comment">##样本间层次聚类</span></span><br><span class="line"><span class="comment"># 如果是基因聚类，可以选择 wgcna 等算法  </span></span><br><span class="line">plot(hc,labels = <span class="built_in">F</span>) <span class="comment">##此图可以看出678个样本大致可以分为几类，在此大致可分为4类   </span></span><br><span class="line">clus = cutree(hc, <span class="number">4</span>) <span class="comment">#对hclust()函数的聚类结果进行剪枝，即选择输出指定类别数的系谱聚类结果。</span></span><br><span class="line">group_list= as.factor(clus) <span class="comment">##转换为因子属性</span></span><br><span class="line">table(group_list) <span class="comment">##统计频数    </span></span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/hclust.JPG" width="60%" height="60%">    

<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/grouplist.JPG"/>

<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#提取批次信息</span></span><br><span class="line">colnames(dat) <span class="comment">#取列名</span></span><br><span class="line">library(stringr)</span><br><span class="line">plate=str_split(colnames(dat),<span class="string">&#x27;_&#x27;</span>,simplify = <span class="built_in">T</span>)[,<span class="number">3</span>] <span class="comment">#str_split()函数可以分割字符串。取列名，以&#x27;_&#x27;号分割，提取第三列。</span></span><br><span class="line">table(plate) <span class="comment">#以为这768个样本是放在两个384孔检测的，后续要检测测序数据是否存在批次效应，所以要预先提取批次信息 </span></span><br><span class="line">n_g = apply(a,<span class="number">2</span>,<span class="keyword">function</span>(x) <span class="built_in">sum</span>(x&gt;<span class="number">0</span>)) <span class="comment">#统计每个样本有表达的基因有多少行</span></span><br><span class="line"><span class="comment">#reads数量大于1的那些基因为有表达，一般来说单细胞转录组过半数的基因是不会表达的。  </span></span><br><span class="line">df=data.frame(g=group_list,plate=plate,n_g=n_g) <span class="comment">#新建数据框(细胞的属性信息) </span></span><br><span class="line"><span class="comment">##(样本为行名，列分别为：样本分类信息，样本批次，样本表达的基因数——不是表达量的和，而是种类数或者说个数) </span></span><br><span class="line">df$<span class="built_in">all</span>=<span class="string">&#x27;all&#x27;</span> <span class="comment">#添加列，列名为&quot;all&quot;，没事意思，就是后面有需要</span></span><br><span class="line">metadata=df  </span><br><span class="line">df[<span class="number">1</span>:<span class="number">4</span>,<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">save(dat,metadata,file = <span class="string">&#x27;../input_rpkm.Rdata&#x27;</span>) <span class="comment">#保存a,dat,df这变量到上级目录的input.Rdata   </span></span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/df.JPG"/>    

<h3 id="检测是否存在批次效应"><a href="#检测是否存在批次效应" class="headerlink" title="检测是否存在批次效应"></a>检测是否存在批次效应</h3><p>因为该篇文章使用两块384孔进行测序，所以要先确定两块板是否存在批次效应，如果存在，则两块板的样本不能合并分析，如果不存在批次效应，则两块板可以进行批次分析。</p>
<p><strong>PCA主成份分析</strong></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">rm(<span class="built_in">list</span> = ls())  <span class="comment">## 魔幻操作，一键清空~</span></span><br><span class="line">options(stringsAsFactors = <span class="built_in">F</span>)</span><br><span class="line">load(file = <span class="string">&#x27;../input_rpkm.Rdata&#x27;</span>)</span><br><span class="line">dat[<span class="number">1</span>:<span class="number">4</span>,<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">head(metadata) </span><br><span class="line">plate=metadata$plate</span><br><span class="line"><span class="comment">## 下面是画PCA的必须操作</span></span><br><span class="line">dat_back=dat</span><br><span class="line">dat=t(dat)  <span class="comment">#做PCA之前一定要进行数据转置</span></span><br><span class="line">dat=as.data.frame(dat)</span><br><span class="line">dat=cbind(dat,plate ) <span class="comment">#cbind根据列进行合并，即叠加所有列，矩阵添加批次信息</span></span><br><span class="line">dat[<span class="number">1</span>:<span class="number">4</span>,<span class="number">12688</span>:<span class="number">12690</span>]  <span class="comment">#检测是否添加上了批次信息</span></span><br><span class="line">table(dat$plate)</span><br><span class="line">library(<span class="string">&quot;FactoMineR&quot;</span>)</span><br><span class="line">library(<span class="string">&quot;factoextra&quot;</span>) </span><br><span class="line">dat.pca &lt;- PCA(dat[,-ncol(dat)], graph = <span class="literal">FALSE</span>)</span><br><span class="line">fviz_pca_ind(dat.pca,<span class="comment">#repel =T, geom.ind = &quot;point&quot;, </span></span><br><span class="line">             col.ind = dat$plate, <span class="comment"># color by groups</span></span><br><span class="line">             addEllipses = <span class="literal">FALSE</span>, <span class="comment"># Concentration ellipses</span></span><br><span class="line">             legend.title = <span class="string">&quot;Groups&quot;</span></span><br><span class="line">)   </span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/PCA.jpeg" width="60%" height="60%">
      


<p><strong>tSNE分析</strong></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">rm(<span class="built_in">list</span> = ls())  <span class="comment">## 魔幻操作，一键清空~</span></span><br><span class="line">options(stringsAsFactors = <span class="built_in">F</span>)   </span><br><span class="line">library(Rtsne) </span><br><span class="line">load(file = <span class="string">&#x27;../input_rpkm.Rdata&#x27;</span>)</span><br><span class="line">dat[<span class="number">1</span>:<span class="number">4</span>,<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">dat_matrix &lt;- t(dat)  </span><br><span class="line">dat_matrix=log2(dat_matrix+<span class="number">0.01</span>)</span><br><span class="line">set.seed(<span class="number">42</span>) <span class="comment"># 如果想得到可重复的结果，就种一颗种子吧😄</span></span><br><span class="line">tsne_out &lt;- Rtsne(dat_matrix,pca=<span class="literal">FALSE</span>,perplexity=<span class="number">30</span>,theta=<span class="number">0.0</span>)   </span><br><span class="line"><span class="comment">##添加颜色</span></span><br><span class="line">tsnes=tsne_out$Y</span><br><span class="line">tsnes=as.data.frame(tsnes)</span><br><span class="line">group=<span class="built_in">c</span>(<span class="built_in">rep</span>(<span class="string">&#x27;plate1&#x27;</span>,<span class="number">384</span>),<span class="built_in">rep</span>(<span class="string">&#x27;plate2&#x27;</span>,<span class="number">384</span>))</span><br><span class="line">colnames(tsnes)&lt;-<span class="built_in">c</span>(<span class="string">&quot;tSNE1&quot;</span>,<span class="string">&quot;tSNE2&quot;</span>)  </span><br><span class="line">library(ggfortify)</span><br><span class="line">ggplot(tsnes, aes(x = tSNE1, y = tSNE2))+ geom_point(aes(col=group))+ theme_classic()</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/tSNE.jpeg" width="60%" height="60%">

<h3 id="细胞亚群"><a href="#细胞亚群" class="headerlink" title="细胞亚群"></a>细胞亚群</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#########################</span></span><br><span class="line"><span class="comment">##针对所有细胞做PCA分析##  </span></span><br><span class="line"><span class="comment">#########################</span></span><br><span class="line">rm(<span class="built_in">list</span> = ls())  <span class="comment">## 魔幻操作，一键清空</span></span><br><span class="line">options(stringsAsFactors = <span class="built_in">F</span>)</span><br><span class="line">load(file = <span class="string">&#x27;../input_rpkm.Rdata&#x27;</span>)</span><br><span class="line">dat[<span class="number">1</span>:<span class="number">4</span>,<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">head(metadata) </span><br><span class="line">group&lt;-metadata$g</span><br><span class="line"><span class="comment">#做好数据备份</span></span><br><span class="line">dat_back=dat</span><br><span class="line">dat=t(dat) <span class="comment">#记得转置数据</span></span><br><span class="line">dat=as.data.frame(dat)</span><br><span class="line">dat=cbind(dat,group ) <span class="comment">#cbind根据列进行合并，即叠加所有列，为矩阵添加分组信息</span></span><br><span class="line">dat[<span class="number">1</span>:<span class="number">4</span>,<span class="number">12688</span>:<span class="number">12690</span>]</span><br><span class="line">table(dat$group)</span><br><span class="line">library(<span class="string">&quot;FactoMineR&quot;</span>)</span><br><span class="line">library(<span class="string">&quot;factoextra&quot;</span>) </span><br><span class="line">dat.pca &lt;- PCA(dat[,-ncol(dat)], graph = <span class="literal">FALSE</span>)</span><br><span class="line">fviz_pca_ind(dat.pca,<span class="comment">#repel =T,</span></span><br><span class="line">             geom.ind = <span class="string">&quot;point&quot;</span>, <span class="comment"># show points only (nbut not &quot;text&quot;)</span></span><br><span class="line">             col.ind = dat$group, <span class="comment"># color by groups</span></span><br><span class="line">             addEllipses = <span class="literal">FALSE</span>, <span class="comment"># Concentration ellipses</span></span><br><span class="line">             legend.title = <span class="string">&quot;Groups&quot;</span>  </span><br><span class="line">             )   </span><br><span class="line"></span><br><span class="line"><span class="comment">#########################</span></span><br><span class="line"><span class="comment">##针对所有细胞做tSNE分析##  </span></span><br><span class="line"><span class="comment">#########################</span></span><br><span class="line">rm(<span class="built_in">list</span> = ls())  <span class="comment">## 魔幻操作，一键清空~</span></span><br><span class="line">options(stringsAsFactors = <span class="built_in">F</span>)</span><br><span class="line">library(Rtsne) </span><br><span class="line">load(file = <span class="string">&#x27;../input_rpkm.Rdata&#x27;</span>)</span><br><span class="line">dat[<span class="number">1</span>:<span class="number">4</span>,<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">dat_matrix &lt;- t(dat)</span><br><span class="line">dat_matrix=log2(dat_matrix+<span class="number">0.01</span>)</span><br><span class="line"><span class="comment"># Set a seed if you want reproducible results</span></span><br><span class="line">set.seed(<span class="number">42</span>)</span><br><span class="line">tsne_out &lt;- Rtsne(dat_matrix,pca=<span class="literal">FALSE</span>,perplexity=<span class="number">30</span>,theta=<span class="number">0.0</span>) </span><br><span class="line">group=metadata$g</span><br><span class="line"><span class="comment">##添加颜色</span></span><br><span class="line">tsnes=tsne_out$Y</span><br><span class="line">tsnes=as.data.frame(tsnes)</span><br><span class="line">colnames(tsnes)&lt;-<span class="built_in">c</span>(<span class="string">&quot;tSNE1&quot;</span>,<span class="string">&quot;tSNE2&quot;</span>)</span><br><span class="line">ggplot(tsnes, aes(x = tSNE1, y = tSNE2))+ geom_point(aes(col=group))+ theme_classic()</span><br></pre></td></tr></table></figure>
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/wholePCA.jpeg" width="60%" height="60%">  
<img src="https://blog-image-host.oss-cn-shanghai.aliyuncs.com/gyqblog/wholetSNE.jpeg" width="60%" height="60%">   

<p>单细胞测序分析旨在分出不同细胞亚群(展现细胞间的异质性)，力求寻找某类亚群与某特定生物学功能之间的联系。而要探讨细胞分群，就必须要知道PCA和tSNE。<br><strong>PCA(Principal Component Analysis)</strong><br><strong>tSNE(t-Distributed Stochastic Neighbor Embedding)</strong><br>什么样的算法才是最理想的能够将细胞分群的算法呢？<br>1）局部结构：属于同一个亚群的细胞，聚类尽可能近<br>2）全局结构：属于不同亚群的细胞，聚类尽可能分来   </p>
<ul>
<li>PCA的方法侧重于去抓样本中隐含的主要效应，从而让差异大的样本在图上呈现较远的距离。常规RNA-seq项目中，处理效应、批次效应、离群效应等属于较大的效应，PCA的方法可以良好的去展示这些效应。   </li>
<li>如果影响样本分组的不是主要效应，而是一些更小的效应，PCA则无法对样本进行准确的区分。scRNA-seq的可视化主要期望对各个细胞亚群有良好的区分。每次检测的上万甚至几十万个细胞中，几乎肯定可以区分出几十中细胞亚群，包括一些稀有的细胞。而区分这些细胞亚群（尤其是稀有细胞类型）的效应，往往不是主要效应（即大量基因的差异），而是一些微小效应（少量标记基因差异）。如果使用PCA进行分析的话，就会掩盖掉某些微小的但是有可能非常重要的细胞群。   </li>
<li>tSNE算法就属于可以同时兼顾局部结构和全局结构的非线性降维可视化算法。tSNE不同于PCA（PCA主要目标是尽量去抓取群体中的主要效益），tSNE算法的主要目标是：降维后的数据依然保持最为相似的紧密成簇。这就保证了哪怕某些稀有细胞只是少量基因区别于其他细胞亚群，在tSNE中依然可以与其他细胞有良好的区分。<font color=blue>结论：PCA是常规转录组常用的数据降维和样本关系可视化的方法，但针对群体单细胞转录组数据，tSNE是明显胜过PCA的方法！</font>   </li>
</ul>
<p>参考资料<br><a href="http://www.sohu.com/a/320164491_278730">http://www.sohu.com/a/320164491_278730</a></p>
]]></content>
      <tags>
        <tag>NGS</tag>
      </tags>
  </entry>
</search>
